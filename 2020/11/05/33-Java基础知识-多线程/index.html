
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>33.Java基础知识-多线程 - 秃头小王子</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="秃头小王子的个人博客,线程当我以为我的代码很安全时，等等。。。
程序是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。
进程是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="秃头小王子" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">秃头小王子</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">33.Java基础知识-多线程</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">33.Java基础知识-多线程</h1>
        <div class="stuff">
            <span>十一月 05, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>当我以为我的代码很安全时，等等。。。<br><img src="http://wangzixuan.work/6888" alt="image"></p>
<h6 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h6><p>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</p>
<h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><p>是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。———生命周期</p>
<ul>
<li>程序是静态的，进程是动态的</li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
<h6 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h6><p>进程可进一步细化为线程，是一个程序内部的一条执行路径。</p>
<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li>
<li>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间→它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</li>
</ul>
<h6 id="并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。"><a href="#并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。" class="headerlink" title="并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。"></a>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</h6><h6 id="并发：一个CPU-采用时间片-同时执行多个任务。比如：秒杀、多个人做同一件事。"><a href="#并发：一个CPU-采用时间片-同时执行多个任务。比如：秒杀、多个人做同一件事。" class="headerlink" title="并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。"></a>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</h6><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><h6 id="Thread"><a href="#Thread" class="headerlink" title="Thread()"></a>Thread()</h6><p>创建新的Thread对象</p>
<h6 id="Thread-String-threadname"><a href="#Thread-String-threadname" class="headerlink" title="Thread(String threadname)"></a>Thread(String threadname)</h6><p>创建线程并指定线程实例名</p>
<h6 id="Thread-Runnable-target"><a href="#Thread-Runnable-target" class="headerlink" title="Thread(Runnable target)"></a>Thread(Runnable target)</h6><p>指定创建线程的目标对象，它实现了Runnable接中的run方法</p>
<h6 id="Thread-Runnable-target-String-name"><a href="#Thread-Runnable-target-String-name" class="headerlink" title="Thread(Runnable target, String name)"></a>Thread(Runnable target, String name)</h6><p>创建新的Thread对象</p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="1-start-启动当前线程；调用当前线程的run"><a href="#1-start-启动当前线程；调用当前线程的run" class="headerlink" title="1. start():启动当前线程；调用当前线程的run()"></a>1. start():启动当前线程；调用当前线程的run()</h6><h6 id="2-run-通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中"><a href="#2-run-通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中" class="headerlink" title="2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中"></a>2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</h6><h6 id="3-currentThread-静态方法，返回执行当前代码的线程"><a href="#3-currentThread-静态方法，返回执行当前代码的线程" class="headerlink" title="3. currentThread():静态方法，返回执行当前代码的线程"></a>3. currentThread():静态方法，返回执行当前代码的线程</h6><h6 id="4-getName-获取当前线程的名字"><a href="#4-getName-获取当前线程的名字" class="headerlink" title="4. getName():获取当前线程的名字"></a>4. getName():获取当前线程的名字</h6><h6 id="5-setName-设置当前线程的名字"><a href="#5-setName-设置当前线程的名字" class="headerlink" title="5. setName():设置当前线程的名字"></a>5. setName():设置当前线程的名字</h6><h6 id="6-yield-释放当前cpu的执行权"><a href="#6-yield-释放当前cpu的执行权" class="headerlink" title="6. yield():释放当前cpu的执行权"></a>6. yield():释放当前cpu的执行权</h6><h6 id="7-join-在线程a中调用线程b的join-此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。"><a href="#7-join-在线程a中调用线程b的join-此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。" class="headerlink" title="7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。"></a>7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</h6><h6 id="8-stop-已过时。当执行此方法时，强制结束当前线程。"><a href="#8-stop-已过时。当执行此方法时，强制结束当前线程。" class="headerlink" title="8. stop():已过时。当执行此方法时，强制结束当前线程。"></a>8. stop():已过时。当执行此方法时，强制结束当前线程。</h6><h6 id="9-sleep-long-millitime-让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。"><a href="#9-sleep-long-millitime-让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。" class="headerlink" title="9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。"></a>9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</h6><h6 id="10-isAlive-判断当前线程是否存活"><a href="#10-isAlive-判断当前线程是否存活" class="headerlink" title="10. isAlive():判断当前线程是否存活"></a>10. isAlive():判断当前线程是否存活</h6><h5 id="Java-的线程的调度"><a href="#Java-的线程的调度" class="headerlink" title="Java 的线程的调度"></a>Java 的线程的调度</h5><ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<h5 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h5><h6 id="线程的优先等级"><a href="#线程的优先等级" class="headerlink" title="线程的优先等级"></a>线程的优先等级</h6><ul>
<li><p>MAX_PRIORITY：10</p>
</li>
<li><p>MIN _PRIORITY：1</p>
</li>
<li><p>NORM_PRIORITY：5  –&gt; 默认优先级</p>
</li>
</ul>
<h6 id="如何获取和设置当前线程的优先级："><a href="#如何获取和设置当前线程的优先级：" class="headerlink" title="如何获取和设置当前线程的优先级："></a>如何获取和设置当前线程的优先级：</h6><ul>
<li><p>getPriority():获取线程的优先级</p>
</li>
<li><p>setPriority(int p):设置线程的优先级</p>
</li>
</ul>
<h6 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h6><ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
</ul>
<h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><ul>
<li>JDK1.5之前创建新执行线程的种方法：<ul>
<li>继承Thread类的方式</li>
<li>实现Runnable接口的方式</li>
</ul>
</li>
<li>JDK1.5之后创建新执行线程的两种方法：<ul>
<li>实现Callable</li>
<li>使用线程池</li>
</ul>
</li>
</ul>
<h4 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h4><ol>
<li>直接调用run()方法，那么就只是普通方法，没有启动多线程模式。</li>
<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li>
<li>想要启动多线程，必须调用start()方法。</li>
<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以下的异常“IllegalThreadStateException”。</li>
</ol>
<h5 id="方式一：-继承Thread类"><a href="#方式一：-继承Thread类" class="headerlink" title="方式一： 继承Thread类"></a>方式一： 继承Thread类</h5><ul>
<li>定义子类继承Thread类。</li>
<li>子类中重写Thread类中的run方法。</li>
<li>创建Thread子类对象，即创建了线程对象。</li>
<li>调用线程对象start方法：启动线程，调用run方法。</li>
</ul>
<h5 id="方式二：实现Runnable"><a href="#方式二：实现Runnable" class="headerlink" title="方式二：实现Runnable"></a>方式二：实现Runnable</h5><ul>
<li>定义子类，实现Runnable接口。</li>
<li>子类中重写Runnable接口中的run方法。</li>
<li>通过Thread类含参构造器创建线程对象。</li>
<li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</li>
<li>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</li>
</ul>
<h5 id="继承与实现的联系"><a href="#继承与实现的联系" class="headerlink" title="继承与实现的联系"></a>继承与实现的联系</h5><p>Thread类实现了Runnable接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable</span><br></pre></td></tr></table></figure>


<h5 id="继承与实现的对比"><a href="#继承与实现的对比" class="headerlink" title="继承与实现的对比"></a>继承与实现的对比</h5><h6 id="相同："><a href="#相同：" class="headerlink" title="相同："></a>相同：</h6><p>两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p>
<h6 id="开发中："><a href="#开发中：" class="headerlink" title="开发中："></a>开发中：</h6><p>优先选择–&gt;实现Runnable接口的方式</p>
<h6 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h6><ol>
<li>实现的方式没有类的单继承性的局限性</li>
<li>实现的方式更适合来处理多个线程有共享数据的情况。</li>
</ol>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p><img src="http://wangzixuan.work/6986" alt="image"></p>
<ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建<br>状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已<br>具备了运行的条件，只是没分配到CPU资源</li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线<br>程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中<br>止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<h4 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h4><h5 id="同步锁机制"><a href="#同步锁机制" class="headerlink" title="同步锁机制"></a>同步锁机制</h5><p>对于多用户访问的共同资源，在第一个用户访问时，锁定资源，使其他用户在资源解锁之前无法访问，在第一个用户使用完，解锁资源后，其下一个用户可以锁定应使用该资源。</p>
<h5 id="锁的使用顺序"><a href="#锁的使用顺序" class="headerlink" title="锁的使用顺序"></a>锁的使用顺序</h5><p>Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt; 同步方法<br>（在方法体之外）</p>
<h5 id="如何确定需要加同步锁的代码？"><a href="#如何确定需要加同步锁的代码？" class="headerlink" title="如何确定需要加同步锁的代码？"></a>如何确定需要加同步锁的代码？</h5><ol>
<li>如何找问题 ， 即代码是否存在线程安全 ？ （ 非常重要 ）</li>
</ol>
<ul>
<li>明确哪些代码是多线程运行的代码</li>
<li>明确多个线程是否有共享数据</li>
<li>明确多线程运行代码中是否有多条语句操作共享数据</li>
</ul>
<ol start="2">
<li>如何解决呢 ？ （ 非常重要 ）</li>
</ol>
<ul>
<li>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其<br>他线程不可以参与执行。</li>
<li>即所有操作共享数据的这些语句都要放在同步范围中</li>
</ul>
<ol start="3">
<li>切记 </li>
</ol>
<ul>
<li>范围太小：没锁住所有有安全问题的代码</li>
<li>范围太大：没发挥多线程的功能。</li>
</ul>
<h5 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h5><h6 id="synchronize的锁"><a href="#synchronize的锁" class="headerlink" title="synchronize的锁"></a>synchronize的锁</h6><ul>
<li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。</li>
<li>必须确保使用同一个资源的<strong>多个线程共用一把锁</strong>，这个非常重要，否则就无法保证共享资源的安全</li>
<li>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）</li>
</ul>
<h6 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h6><p>同步代码块：自己指定，很多时候也是指定为this或类名.class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized ( 对象)&#123;</span><br><span class="line">    &#x2F;&#x2F;  需要被同步的代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h6><p>同步方法的锁：静态方法（类名.class）、非静态方法（this）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void show (String name)&#123;</span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h5><ul>
<li>当前线程的同步方法、同步代码块执行结束。</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li>
</ul>
<h5 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a>不会释放锁的操作</h5><ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。</li>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
<h5 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock(锁)"></a>Lock(锁)</h5><ul>
<li>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li>ReentrantLock类实现了Lock，它拥有与synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    private final ReentrantLock lock &#x3D; new ReenTrantLock();</span><br><span class="line">    public void m()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            &#x2F;&#x2F; 保证线程安全的代码;</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h5><table>
<thead>
<tr>
<th>synchronized</th>
<th>lock</th>
</tr>
</thead>
<tbody><tr>
<td>隐式锁</td>
<td>显示锁</td>
</tr>
<tr>
<td>出了作用域自动释放</td>
<td>手动开锁和关锁</td>
</tr>
<tr>
<td>代码块锁和方法锁</td>
<td>代码块锁</td>
</tr>
<tr>
<td>无</td>
<td>JVM将花费较少的时间来调度线程，性能更好</td>
</tr>
</tbody></table>
<h4 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h4><ul>
<li>wait() 与 与 notify() 和 和 notifyAll()<ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li>
<li>notifyAll()：唤醒正在排队等待资源的所有线程结束等待.</li>
</ul>
</li>
<li>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。</li>
<li>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明。</li>
</ul>
<h5 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()  方法"></a>wait()  方法</h5><ul>
<li>在当前线程中调用方法： 对象名.wait()</li>
<li>使当前线程进入等待（某对象）状态，直到另一线程对该对象发出 notify(或notifyAll) 为止。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
<li>调用此方法后，当前线程将释放对象监控权，然后进入等待</li>
<li>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</li>
</ul>
<h5 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h5><ul>
<li>在当前线程中调用方法： 对象名.notify()</li>
<li>功能：唤醒等待该对象监控权的一个/所有线程。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
</ul>
<h4 id="经典例题：生产者-消费者问题"><a href="#经典例题：生产者-消费者问题" class="headerlink" title="经典例题：生产者/ 消费者问题"></a>经典例题：生产者/ 消费者问题</h4><ul>
<li>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处<br>取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图<br>生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通<br>知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如<br>果店中有产品了再通知消费者来取走产品。</li>
<li>这里可能出现两个问题：</li>
<li>生产者比消费者快时，消费者会漏掉一些数据没有取到。</li>
<li>消费者比生产者快时，消费者会取相同的数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">public class PC &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Clerk clerk &#x3D; new Clerk();</span><br><span class="line"></span><br><span class="line">        Productor productor &#x3D; new Productor(clerk);</span><br><span class="line">        Customer c &#x3D; new Customer(clerk);</span><br><span class="line">        Thread customer &#x3D; new Thread(c);</span><br><span class="line"></span><br><span class="line">        productor.start();</span><br><span class="line">        customer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clerk&#123;</span><br><span class="line"></span><br><span class="line">    public int number;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;生产</span><br><span class="line">    public synchronized void Productr()&#123;</span><br><span class="line">        if(number &gt;&#x3D; 20)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(&quot;生产的第&quot; + number + &quot;个产品&quot;);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消费</span><br><span class="line">    public synchronized void Customer()&#123;</span><br><span class="line">        if (number &lt;&#x3D; 0)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;消费的第&quot; + number + &quot;个产品&quot;);</span><br><span class="line">            number--;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Productor extends Thread&#123;</span><br><span class="line">    private Clerk clerk;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            clerk.Productr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Productor(Clerk clerk)&#123;</span><br><span class="line">        this.clerk &#x3D; clerk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Customer implements Runnable&#123;</span><br><span class="line">    private  Clerk clerk;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            clerk.Customer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Customer(Clerk clerk)&#123;</span><br><span class="line">        this.clerk &#x3D; clerk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci='98d8392c61bba8a9f87d'
        data-cs='a5b47de553739830db015b176764355577df22bf'
        data-r='Comment'
        data-o='Programmingmakesmebald'
        data-a='Programmingmakesmebald'
        data-d='true'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#程序"><span class="toc-number">1.0.0.0.1.</span> <span class="toc-text">程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#进程"><span class="toc-number">1.0.0.0.2.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#线程-1"><span class="toc-number">1.0.0.0.3.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。"><span class="toc-number">1.0.0.0.4.</span> <span class="toc-text">并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#并发：一个CPU-采用时间片-同时执行多个任务。比如：秒杀、多个人做同一件事。"><span class="toc-number">1.0.0.0.5.</span> <span class="toc-text">并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread类"><span class="toc-number">1.0.1.</span> <span class="toc-text">Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#构造器"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Thread"><span class="toc-number">1.0.1.1.1.</span> <span class="toc-text">Thread()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Thread-String-threadname"><span class="toc-number">1.0.1.1.2.</span> <span class="toc-text">Thread(String threadname)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Thread-Runnable-target"><span class="toc-number">1.0.1.1.3.</span> <span class="toc-text">Thread(Runnable target)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Thread-Runnable-target-String-name"><span class="toc-number">1.0.1.1.4.</span> <span class="toc-text">Thread(Runnable target, String name)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#常用方法"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-start-启动当前线程；调用当前线程的run"><span class="toc-number">1.0.1.2.1.</span> <span class="toc-text">1. start():启动当前线程；调用当前线程的run()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-run-通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中"><span class="toc-number">1.0.1.2.2.</span> <span class="toc-text">2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-currentThread-静态方法，返回执行当前代码的线程"><span class="toc-number">1.0.1.2.3.</span> <span class="toc-text">3. currentThread():静态方法，返回执行当前代码的线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-getName-获取当前线程的名字"><span class="toc-number">1.0.1.2.4.</span> <span class="toc-text">4. getName():获取当前线程的名字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-setName-设置当前线程的名字"><span class="toc-number">1.0.1.2.5.</span> <span class="toc-text">5. setName():设置当前线程的名字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-yield-释放当前cpu的执行权"><span class="toc-number">1.0.1.2.6.</span> <span class="toc-text">6. yield():释放当前cpu的执行权</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-join-在线程a中调用线程b的join-此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。"><span class="toc-number">1.0.1.2.7.</span> <span class="toc-text">7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-stop-已过时。当执行此方法时，强制结束当前线程。"><span class="toc-number">1.0.1.2.8.</span> <span class="toc-text">8. stop():已过时。当执行此方法时，强制结束当前线程。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#9-sleep-long-millitime-让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。"><span class="toc-number">1.0.1.2.9.</span> <span class="toc-text">9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#10-isAlive-判断当前线程是否存活"><span class="toc-number">1.0.1.2.10.</span> <span class="toc-text">10. isAlive():判断当前线程是否存活</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-的线程的调度"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">Java 的线程的调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#线程的优先级"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">线程的优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#线程的优先等级"><span class="toc-number">1.0.1.4.1.</span> <span class="toc-text">线程的优先等级</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#如何获取和设置当前线程的优先级："><span class="toc-number">1.0.1.4.2.</span> <span class="toc-text">如何获取和设置当前线程的优先级：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#说明"><span class="toc-number">1.0.1.4.3.</span> <span class="toc-text">说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的创建方式"><span class="toc-number">1.0.2.</span> <span class="toc-text">线程的创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的创建和使用"><span class="toc-number">1.0.3.</span> <span class="toc-text">线程的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#方式一：-继承Thread类"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">方式一： 继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方式二：实现Runnable"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">方式二：实现Runnable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#继承与实现的联系"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">继承与实现的联系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#继承与实现的对比"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">继承与实现的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#相同："><span class="toc-number">1.0.3.4.1.</span> <span class="toc-text">相同：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#开发中："><span class="toc-number">1.0.3.4.2.</span> <span class="toc-text">开发中：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#原因："><span class="toc-number">1.0.3.4.3.</span> <span class="toc-text">原因：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的生命周期"><span class="toc-number">1.0.4.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的同步"><span class="toc-number">1.0.5.</span> <span class="toc-text">线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#同步锁机制"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">同步锁机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#锁的使用顺序"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">锁的使用顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#如何确定需要加同步锁的代码？"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">如何确定需要加同步锁的代码？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Synchronized"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">Synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#synchronize的锁"><span class="toc-number">1.0.5.4.1.</span> <span class="toc-text">synchronize的锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#同步代码块"><span class="toc-number">1.0.5.4.2.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#同步方法"><span class="toc-number">1.0.5.4.3.</span> <span class="toc-text">同步方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#释放锁的操作"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">释放锁的操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不会释放锁的操作"><span class="toc-number">1.0.5.6.</span> <span class="toc-text">不会释放锁的操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lock-锁"><span class="toc-number">1.0.5.7.</span> <span class="toc-text">Lock(锁)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#synchronized-与-Lock-的对比"><span class="toc-number">1.0.5.8.</span> <span class="toc-text">synchronized 与 Lock 的对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的通信"><span class="toc-number">1.0.6.</span> <span class="toc-text">线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#wait-方法"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">wait()  方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#notify-notifyAll"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">notify()&#x2F;notifyAll()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#经典例题：生产者-消费者问题"><span class="toc-number">1.0.7.</span> <span class="toc-text">经典例题：生产者&#x2F; 消费者问题</span></a></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
