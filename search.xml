<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01.Java语言概述</title>
    <url>/2020/07/03/01-Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、Java基础知识图解"><a href="#一、Java基础知识图解" class="headerlink" title="一、Java基础知识图解"></a>一、Java基础知识图解</h2><p><img src="http://wangzixuan.work/1753" alt=""></p>
<h2 id="二、Windows操作cmd"><a href="#二、Windows操作cmd" class="headerlink" title="二、Windows操作cmd"></a>二、Windows操作cmd</h2><h4 id="1-常用DOS命令"><a href="#1-常用DOS命令" class="headerlink" title="1. 常用DOS命令"></a>1. 常用DOS命令</h4><ul>
<li>dir：列出当前目录下的文件及文件夹</li>
<li>md：创建目录</li>
<li>rd：删除目录</li>
<li>d：进入D盘</li>
<li>cd：进入到指定目录</li>
<li>cd..：返回上级目录</li>
<li>cd\：退回到根目录</li>
<li>echo&gt;xxx.xxx：创建xxx.xxx文件</li>
<li>echo xxx &gt;xxx.xxx：创建xxx.xxx文件并写入xxx</li>
<li>echo &gt;xxx.xxx xxx：创建xxx.xxx文件并写入xxx</li>
<li>del：删除文件</li>
<li>exit：退出dos命令行即退出cmd<h4 id="2-常用快捷键"><a href="#2-常用快捷键" class="headerlink" title="2. 常用快捷键"></a>2. 常用快捷键</h4></li>
<li>← →：移动光标</li>
<li>↑ ↓：调阅历史操作命令</li>
<li>Delete Backspace：删除字符<h2 id="三、Java语言"><a href="#三、Java语言" class="headerlink" title="三、Java语言"></a>三、Java语言</h2><h4 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a>1. 来源</h4>Java语言是SUN(Stanford University Network,斯坦福大学网络公司) 1995年推出的一门高级编程语言。<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4>Java语言是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序(applet)。applet使用现代的图形用户界面与Web用户进行交互。applet内嵌在HTML代码中。<h4 id="3-现状"><a href="#3-现状" class="headerlink" title="3. 现状"></a>3. 现状</h4>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。<h4 id="4-简史"><a href="#4-简史" class="headerlink" title="4. 简史"></a>4. 简史</h4></li>
<li>1991年Green项目，开发语言最初命名为Oak (橡树)</li>
<li>1994年，开发组意识到Oak非常适合于互联网</li>
<li>1996年，发布JDK 1.0，约8.3万 个网页应用Java技术来制作</li>
<li>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最</li>
<li>1998年，发布JDK 1.2，同年发布企业平台J2EE</li>
<li>1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技 术诞生</li>
<li>2004年，发布里程碑式版本: JDK 1.5，为突出此版本的重要性，更名为JDK 5.0</li>
<li>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE, J2ME -&gt; JavaME</li>
<li>2009年，Oracle公司收购SUN，交易价格74亿美元</li>
<li>2011年，发布JDK 7.0</li>
<li>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本</li>
<li>2017年，发布JDK 9.0，最大限度实现模块化</li>
<li>2018年3月，发布JDK 10.0，版本号也称为18.3</li>
<li>2018年9月，发布JDK 11.0，版本号也称为18.9<h4 id="5-Java语言的诞生"><a href="#5-Java语言的诞生" class="headerlink" title="5. Java语言的诞生"></a>5. Java语言的诞生</h4></li>
<li>java之父James Gosl ing团队在开发”Green”项目时，发现c缺少垃圾回收系统，还有可移植的安全性、分布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。</li>
<li>Java确实是从c语言和C++语言继承了许多成份，甚至可以将Java看成是类c语言发展和衍生的产物。比如Java语言的变量声明，操作符形式，参数传递，流程控制等方面和C语言、C++语言完全相同。但同时，Java是一个纯粹的面向对象的程序设计语言，它继承了C++语言面向对象技术的核心。Java舍弃了c语言中容易引起错误的指针(以引用取代)、运算符重载(operator overloading)、多重继承<br>(以接口取代)等特性，增加了垃圾回收器功能用于回收不再被引用的对象所占据的内存空间。JDK1.5又引入了泛型编程(GenericProgramming)、类型安全的枚举、不定长参数和自动装/拆箱<h4 id="6-Java的主要特性"><a href="#6-Java的主要特性" class="headerlink" title="6. Java的主要特性"></a>6. Java的主要特性</h4></li>
<li><h5 id="Java语言是易学的"><a href="#Java语言是易学的" class="headerlink" title="Java语言是易学的"></a>Java语言是易学的</h5>  Java语言的语法与c语言和C++语言很接近，使得大多数程序员很容易学习和使用Java。</li>
<li><h5 id="Java语言是强制面向对象的"><a href="#Java语言是强制面向对象的" class="headerlink" title="Java语言是强制面向对象的"></a>Java语言是强制面向对象的</h5>  Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制<br>(关键字为implements)。</li>
<li><h5 id="Java语言是分布式的"><a href="#Java语言是分布式的" class="headerlink" title="Java语言是分布式的"></a>Java语言是分布式的</h5>  Java语 言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口(java net) ，它提供了用于网络应用编程的类<br>库，包括URL、URLConnection、 Socket、 ServerSocket等。 Java 的RMI (远程<br>方法激活)机制也是开发分布式应用的重要手段。</li>
<li><h5 id="Java语言是健壮的"><a href="#Java语言是健壮的" class="headerlink" title="Java语言是健壮的"></a>Java语言是健壮的</h5>  Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。</li>
<li><h5 id="Java语言是安全的"><a href="#Java语言是安全的" class="headerlink" title="Java语言是安全的"></a>Java语言是安全的</h5>  Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如:安全防范机制(类ClassLoader)，如分配不同的名字空间以防替代本地的同名类、字节代码检查。</li>
<li><h5 id="Java语言是体系结构中立的"><a href="#Java语言是体系结构中立的" class="headerlink" title="Java语言是体系结构中立的"></a>Java语言是体系结构中立的</h5>  Java程序(后缀为java的文件)在Java平台上被<br>编译为体系结构中立的字节码格式(后缀为class的文件)，然后可以在实现这个</li>
<li><h5 id="Java平台的任何系统中运行"><a href="#Java平台的任何系统中运行" class="headerlink" title="Java平台的任何系统中运行"></a>Java平台的任何系统中运行</h5>  Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统的解释器中运行。</li>
<li><h5 id="Java是性能略高的"><a href="#Java是性能略高的" class="headerlink" title="Java是性能略高的"></a>Java是性能略高的</h5>  与那些解释型的高级脚本语言相比，Java的性能还是较优的。</li>
<li><h5 id="Java语言是原生支持多线程的"><a href="#Java语言是原生支持多线程的" class="headerlink" title="Java语言是原生支持多线程的"></a>Java语言是原生支持多线程的</h5>  在Java语言中，线程是一-种特殊的对象，它必须<br>由Thread类或其子(孙)类来创建。</li>
</ul>
<h4 id="7-Java技术平台"><a href="#7-Java技术平台" class="headerlink" title="7. Java技术平台"></a>7. Java技术平台</h4><ul>
<li><h5 id="Java-SE-Java-Standard-Edition-标准版"><a href="#Java-SE-Java-Standard-Edition-标准版" class="headerlink" title="Java SE(Java Standard Edition)标准版"></a>Java SE(Java Standard Edition)标准版</h5>  支持面向桌面级应用(如Windows’下的应用程序)的Java平台，提供了完整的Java核心API，此版本以前称为J2SE</li>
<li><h5 id="Java-EE-Java-Enterprise-Edition-企业版"><a href="#Java-EE-Java-Enterprise-Edition-企业版" class="headerlink" title="Java EE(Java Enterprise Edition)企业版"></a>Java EE(Java Enterprise Edition)企业版</h5>  是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等 ,主要针对于Web应用程序开发。版本以前称为J2EE<h4 id="8-Java应用领域"><a href="#8-Java应用领域" class="headerlink" title="8.Java应用领域"></a>8.Java应用领域</h4>从Java的应用领域来分，Java语言的应用方向主要表现在以下几个方面:</li>
<li><h5 id="企业级应用"><a href="#企业级应用" class="headerlink" title="企业级应用"></a>企业级应用</h5>  主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</li>
<li><h5 id="Android平台应用"><a href="#Android平台应用" class="headerlink" title="Android平台应用"></a>Android平台应用</h5>  Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实。</li>
<li><h5 id="大数据平台开发"><a href="#大数据平台开发" class="headerlink" title="大数据平台开发"></a>大数据平台开发</h5>  各类框架有Hadoop, spark, storm,flink等，就这类技术生态圈来讲，还有各种中间件如flume, kafka, sqoop等等 ，这些框架以及工具大多数是用Java编写而成，但提供诸如Java, sscala,Python,R等各种语言API供编程。</li>
<li><h5 id="移动领域应用"><a href="#移动领域应用" class="headerlink" title="移动领域应用"></a>移动领域应用</h5>  主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。<h2 id="四、Java语言运行机制及运行过程"><a href="#四、Java语言运行机制及运行过程" class="headerlink" title="四、Java语言运行机制及运行过程"></a>四、Java语言运行机制及运行过程</h2></li>
</ul>
<ol>
<li><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ol>
<li><h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多肽</li>
</ul>
</li>
<li><h5 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h5><ul>
<li>吸收了C/C++语言的优点，但是去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供一个相对安全的内存管理和访问机制</li>
</ul>
</li>
<li><h5 id="跨平台性"><a href="#跨平台性" class="headerlink" title="跨平台性"></a>跨平台性</h5><ul>
<li>跨平台性：通过Java语言编程的应用程序在不同平台上都可以运行。“Write once，Run Anywhere”</li>
<li>原理:只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。<br><img src="http://wangzixuan.work/2003" alt=""></li>
</ul>
</li>
</ol>
</li>
<li><h4 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h4></li>
</ol>
<ul>
<li>Java虚拟机（Java Virtual Machine）</li>
<li>垃圾收集机制（Garbage Collection）</li>
</ul>
<ol start="3">
<li><h4 id="核心机制——Java虚拟机"><a href="#核心机制——Java虚拟机" class="headerlink" title="核心机制——Java虚拟机"></a>核心机制——Java虚拟机</h4></li>
</ol>
<ul>
<li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。<br><img src="http://wangzixuan.work/2047" alt=""></li>
<li>对于不同的平台，有不同的虚拟机。</li>
<li>只有某平台提供了对应的java虚拟机，java程序才可在此平台运行</li>
<li>Java虛拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”<br><img src="http://wangzixuan.work/2049" alt=""></li>
</ul>
<ol start="4">
<li><h4 id="核心机制——垃圾回收"><a href="#核心机制——垃圾回收" class="headerlink" title="核心机制——垃圾回收"></a>核心机制——垃圾回收</h4></li>
</ol>
<ul>
<li><p>不再使用的内存空间应回收一垃圾回收。</p>
<ul>
<li>在C/C++等语言中，由程序员负责回收无用内存。</li>
<li>Java语言消除了程序员回收无用内存空间的责任:它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。</li>
</ul>
</li>
<li><p>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</p>
</li>
<li><p>Java程序还会出现内存泄漏和内存溢出问题吗?会!</p>
<h2 id="五、Java语言的环境搭建"><a href="#五、Java语言的环境搭建" class="headerlink" title="五、Java语言的环境搭建"></a>五、Java语言的环境搭建</h2></li>
<li><h4 id="JDK-Java-Development-Kit-Java开发工具包"><a href="#JDK-Java-Development-Kit-Java开发工具包" class="headerlink" title="JDK(Java Development Kit Java开发工具包)"></a>JDK(Java Development Kit Java开发工具包)</h4><p>  JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。</p>
<h5 id="其中的开发工具"><a href="#其中的开发工具" class="headerlink" title="其中的开发工具:"></a>其中的开发工具:</h5><ul>
<li>译工具(javac.exe)</li>
<li>打包工具(jar.exe)等</li>
</ul>
</li>
<li><h4 id="JRE-Java-Runtime-Environment-Java运-行环境"><a href="#JRE-Java-Runtime-Environment-Java运-行环境" class="headerlink" title="JRE(Java Runtime Environment Java运 行环境)"></a>JRE(Java Runtime Environment Java运 行环境)</h4><p>  包括Java虛拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
</li>
<li><h4 id="JDK、JRE、JVM的关系"><a href="#JDK、JRE、JVM的关系" class="headerlink" title="JDK、JRE、JVM的关系"></a>JDK、JRE、JVM的关系</h4><p>  <img src="http://wangzixuan.work/2085" alt=""><br>  <img src="http://wangzixuan.work/2087" alt=""></p>
</li>
<li><h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><p>  <img src="http://wangzixuan.work/2095" alt=""><br>  <img src="http://wangzixuan.work/2097" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>01.数据结构</title>
    <url>/2020/07/04/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构包括：线性结构和非线性结构。</p>
<ul>
<li><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</li>
<li>线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。</li>
<li>顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。</li>
<li>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</li>
<li>线性结构常见的有：数组、队列、链表和栈。</li>
</ol>
</li>
<li><h4 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h4><ol>
<li>二维数组</li>
<li>多维数组</li>
<li>广义表</li>
<li>树结构</li>
<li>图结构</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>线性结构</tag>
        <tag>非线性结构</tag>
        <tag>顺序存储结构</tag>
        <tag>链式存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title>02.Java基础知识-文档及规范</title>
    <url>/2020/07/03/02-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%96%87%E6%A1%A3%E5%8F%8A%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="一、Java-API文档"><a href="#一、Java-API文档" class="headerlink" title="一、Java API文档"></a>一、Java API文档</h2><ul>
<li>API (Application Programming Interface,应用程序编程接口)是Java提供的基本编程接口。</li>
<li>Java语言提供了大量的基础类，因此Oracle也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。</li>
<li>下载API: <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br><img src="http://wangzixuan.work/2119" alt=""><h2 id="二、良好的编程风格"><a href="#二、良好的编程风格" class="headerlink" title="二、良好的编程风格"></a>二、良好的编程风格</h2></li>
<li><h4 id="正确的注释和注释风格"><a href="#正确的注释和注释风格" class="headerlink" title="正确的注释和注释风格"></a>正确的注释和注释风格</h4><ul>
<li>使用文档注释来注释整个类或整个方法。</li>
<li>如果注释方法中的某一一个步骤，使用单行或多行注释。</li>
</ul>
</li>
<li><h4 id="正确的缩进和空白"><a href="#正确的缩进和空白" class="headerlink" title="正确的缩进和空白"></a>正确的缩进和空白</h4><ul>
<li>使用一次tab操作，实现缩进</li>
<li>运算符两边习惯性各加一一个空格。比如: 2+4* 5。</li>
</ul>
</li>
<li><h4 id="块的风格"><a href="#块的风格" class="headerlink" title="块的风格"></a>块的风格</h4><ul>
<li>JavaAPI源代码选择了行尾风格<br><img src="http://wangzixuan.work/2135" alt=""><h2 id="三、注释"><a href="#三、注释" class="headerlink" title="三、注释"></a>三、注释</h2></li>
</ul>
</li>
<li>用于注解说明解释程序的文字就是注释。</li>
<li>Java中的注释类型:<ul>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释(java特有)</li>
</ul>
</li>
<li>提高了代码的阅读性;调试程序的重要方法。</li>
<li>注释是一个程序员必须要具有的良好编程习惯。</li>
<li>将自己的思想通过注释先整理出来，再用代码去体现</li>
<li><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式: &#x2F;&#x2F;注释文字</span><br></pre></td></tr></table></figure></li>
<li><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式: &#x2F;*注释文字*&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h4><ul>
<li>对于单行和多行注释，被注释的文字，不会被JVM (java虚拟机)解释执行。</li>
<li>多行注释里面不允许有多行注释嵌套。</li>
</ul>
</li>
<li><h4 id="文档注释-Java特有"><a href="#文档注释-Java特有" class="headerlink" title="文档注释(Java特有)"></a>文档注释(Java特有)</h4>  格式:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">@author指定java程序的作者</span><br><span class="line">@version指定源文件的版本</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="javadoc解析"><a href="#javadoc解析" class="headerlink" title="javadoc解析"></a>javadoc解析</h4><ul>
<li>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。<br><img src="http://wangzixuan.work/2176" alt=""><h2 id="四、注释示例"><a href="#四、注释示例" class="headerlink" title="四、注释示例"></a>四、注释示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">1. java规范的三种注释方式：</span><br><span class="line">单行注释</span><br><span class="line">多行注释</span><br><span class="line">文档注释(java特有)</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">单行注释和多行注释的作用：</span><br><span class="line">① 对所写的程序进行解释说明，增强可读性。方便自己，方便别人</span><br><span class="line">② 调试所写的代码</span><br><span class="line"></span><br><span class="line">3. 特点：单行注释和多行注释，注释了的内容不参与编译。</span><br><span class="line">         换句话说，编译以后生成的.class结尾的字节码文件中不包含注释掉的信息</span><br><span class="line"></span><br><span class="line">4. 文档注释的使用：</span><br><span class="line">    注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</span><br><span class="line"></span><br><span class="line">5. 多行注释不可以嵌套使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">文档注释</span><br><span class="line">@author shkstart</span><br><span class="line">@version v1.0</span><br><span class="line">这是我的第一个java程序！非常的开森！</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">public class HelloJava&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	多行注释：</span><br><span class="line">	如下的main方法是程序的入口！</span><br><span class="line">	main的格式是固定的！</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	如下的方式是main()，作用：程序的入口。</span><br><span class="line">	*&#x2F;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		&#x2F;&#x2F;单行注释：如下的语句表示输出到控制台</span><br><span class="line">		&#x2F;&#x2F;System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02.数据结构-稀疏sparsearray数组</title>
    <url>/2020/07/04/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8Fsparsearray%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="稀疏sparsearray数组"><a href="#稀疏sparsearray数组" class="headerlink" title="稀疏sparsearray数组"></a>稀疏sparsearray数组</h2><ol>
<li><h4 id="先看一个实际的需求"><a href="#先看一个实际的需求" class="headerlink" title="先看一个实际的需求"></a>先看一个实际的需求</h4><ul>
<li>编写的五子棋程序中，有存盘退出和续上盘的功能。<br><img src="http://wangzixuan.work/2296" alt=""></li>
<li>分析问题: 因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据→稀疏数组。</li>
</ul>
</li>
<li><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p> 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<h5 id="稀疏数组的处理方法是"><a href="#稀疏数组的处理方法是" class="headerlink" title="稀疏数组的处理方法是:"></a>稀疏数组的处理方法是:</h5><ol>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模<h5 id="稀疏数组举例说明"><a href="#稀疏数组举例说明" class="headerlink" title="稀疏数组举例说明"></a>稀疏数组举例说明</h5><img src="http://wangzixuan.work/2307" alt=""><br><img src="http://wangzixuan.work/2309" alt=""></li>
</ol>
</li>
<li><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ul>
<li><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</p>
</li>
<li><p>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</p>
</li>
<li><p>整体思路分析<br><img src="http://wangzixuan.work/2326" alt=""></p>
</li>
<li><p>二维数组 转 稀疏数组的思路</p>
<ol>
<li>遍历  原始的二维数组，得到有效数据的个数 sum</li>
<li>根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]</li>
<li>将二维数组的有效数据数据存入到 稀疏数组</li>
</ol>
</li>
<li><p>稀疏数组转原始的二维数组的思路</p>
<ol>
<li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</li>
<li>在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.sparsearray;</span><br><span class="line"></span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; 创建11*11的二维数组</span><br><span class="line">		int[][] chessArr1&#x3D;new int[11][11];</span><br><span class="line">		&#x2F;&#x2F; 0代表没有棋子，1代表黑子，2代表蓝子</span><br><span class="line">		chessArr1[1][2]&#x3D;1;</span><br><span class="line">		chessArr1[2][3]&#x3D;2;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出原始二维数组chessArr1</span><br><span class="line">		System.out.println(&quot;输出原始的二维数组chessArr1&quot;);</span><br><span class="line">		for (int[] row : chessArr1)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 将二维数组 转 稀疏数组</span><br><span class="line">		&#x2F;&#x2F; 遍历chessArr1  非0数据的个数计为sum</span><br><span class="line">		int sum&#x3D;0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; chessArr1.length; i++)&#123;</span><br><span class="line">			for(int j &#x3D; 0;j &lt; chessArr1.length; j++)&#123;</span><br><span class="line">				if(chessArr1[i][j] !&#x3D; 0)&#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 输出sum</span><br><span class="line">		System.out.println(&quot;sum&#x3D;&quot;+sum);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建稀疏数组</span><br><span class="line">		int[][] sparseArr &#x3D; new int[sum+1][3];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 给稀疏数组赋值</span><br><span class="line">		sparseArr[0][0] &#x3D; 11;</span><br><span class="line">		sparseArr[0][1] &#x3D; 11;</span><br><span class="line">		sparseArr[0][2] &#x3D; sum;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 遍历原始二维数组，将非0的值存放到 sparseArr中</span><br><span class="line">		int count &#x3D; 0; &#x2F;&#x2F;count 用于记录是第几个非0数据</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 11; i++)&#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 11; j++)&#123;</span><br><span class="line">				if (chessArr1[i][j] !&#x3D;0 )&#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][0] &#x3D; i;</span><br><span class="line">					sparseArr[count][1] &#x3D; j;</span><br><span class="line">					sparseArr[count][2] &#x3D; chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出稀疏数组</span><br><span class="line">		System.out.println(&quot;得到稀疏数组为~~~~&quot;);</span><br><span class="line">		for (int[] row : sparseArr)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 将稀疏数组 --》 恢复成 原始的二维数组</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 &#x3D; int [11][11]</span><br><span class="line">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span><br><span class="line">		int[][] chessArr2 &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span><br><span class="line">		for (int i &#x3D; 1; i &lt; sparseArr.length; i++)&#123;</span><br><span class="line">			chessArr2[sparseArr[1][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出原始二维数组chessArr2</span><br><span class="line">		System.out.println(&quot;恢复后的二维数组chessArr2&quot;);</span><br><span class="line">		for (int[] row : chessArr2)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>稀疏数组</tag>
        <tag>sparsearray</tag>
      </tags>
  </entry>
  <entry>
    <title>03.Java基础知识-HelloWorld</title>
    <url>/2020/07/03/03-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-HelloWorld/</url>
    <content><![CDATA[<h2 id="一、开发步骤"><a href="#一、开发步骤" class="headerlink" title="一、开发步骤"></a>一、开发步骤</h2><ol>
<li><h5 id="将Java代码编写到扩展名为-java的文件中"><a href="#将Java代码编写到扩展名为-java的文件中" class="headerlink" title="将Java代码编写到扩展名为.java的文件中"></a>将Java代码编写到扩展名为.java的文件中</h5></li>
<li><h5 id="通过javac命令对该java文件进行编译。"><a href="#通过javac命令对该java文件进行编译。" class="headerlink" title="通过javac命令对该java文件进行编译。"></a>通过javac命令对该java文件进行编译。</h5></li>
<li><h5 id="通过java命令对生成的class文件进行运行"><a href="#通过java命令对生成的class文件进行运行" class="headerlink" title="通过java命令对生成的class文件进行运行"></a>通过java命令对生成的class文件进行运行</h5><h2 id="二、步骤一：编写"><a href="#二、步骤一：编写" class="headerlink" title="二、步骤一：编写"></a>二、步骤一：编写</h2></li>
</ol>
<ul>
<li>选择最简单的编辑器:记事本。敲入代码  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>将文件保存成Test.java,这个文件是存放java代码的文件，称为源文件。</li>
<li>注意拓展名是否隐藏<br><img src="http://wangzixuan.work/2202" alt=""><h2 id="三、步骤二：编译"><a href="#三、步骤二：编译" class="headerlink" title="三、步骤二：编译"></a>三、步骤二：编译</h2><img src="http://wangzixuan.work/2229" alt=""></li>
<li>有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件。</li>
<li>在该源文件目录下，通过javac编译工具对Test.java文件进行编译。</li>
<li>如果程序没有错误，没有任何提示，但在当前目录下会出现一个Test.class文件，该文件称为字节码文件，也是可以执行的java的程序。<h2 id="四、步骤三：运行"><a href="#四、步骤三：运行" class="headerlink" title="四、步骤三：运行"></a>四、步骤三：运行</h2></li>
<li>有了可执行的java程序(Test.class字节码文件)</li>
<li>通过运行工具java.exe对字节码文件进行执行。</li>
<li>出现提示:缺少一个名称为main的方法。<br><img src="http://wangzixuan.work/2231" alt=""></li>
<li>因为一个程序的执行需要-一个起始点或者入口，所以在Test类中的加入  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void</span><br><span class="line">main(String] args)&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>对修改后的Test.java源文件需要重新编译，生成新的class文件后，再进行执行。</li>
<li>发现没有编译失败，但也没有任何效果，因为并没有告诉JVM要帮我们做什么事情，也就是没有可以具体执行的语句。</li>
<li>想要和JVM来个互动，只要在main方法中加入一句  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.printn(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure></li>
<li>因为程序进行改动，所以再重新编译，运行即可。<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2></li>
<li>学习编程最容易犯的错是语法错误。</li>
<li>Java要求你必须按照语法规则编写代码。</li>
<li>如果你的程序违反了语法规则。例如:忘记了分号、大括号、引号，或者拼错了单词，java编译器都会报语法错误。</li>
<li>尝试着去看懂编译器会报告的错误信息。</li>
</ul>
<p><img src="http://wangzixuan.work/2233" alt=""><br><img src="http://wangzixuan.work/2235" alt=""></p>
<h2 id="六、代码示例"><a href="#六、代码示例" class="headerlink" title="六、代码示例"></a>六、代码示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">对第一个java程序进行总结</span><br><span class="line">1. java程序编写-编译-运行的过程</span><br><span class="line">编写：我们将编写的java代码保存在以&quot;.java&quot;结尾的源文件中</span><br><span class="line">编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java</span><br><span class="line">运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。</span><br><span class="line">而且要求声明为public的类的类名必须与源文件名相同。</span><br><span class="line"></span><br><span class="line">3. 程序的入口是main()方法。格式是固定的。</span><br><span class="line"></span><br><span class="line">4. 输出语句：</span><br><span class="line">System.out.println():先输出数据，然后换行</span><br><span class="line">System.out.print():只输出数据</span><br><span class="line"></span><br><span class="line">5.每一行执行语句都以&quot;;&quot;结束。</span><br><span class="line"></span><br><span class="line">6.编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">	public static void main(String[] args) &#123;&#x2F;&#x2F;public static void main(String a[]) &#123;&#x2F;&#x2F;arguments:参数</span><br><span class="line">		System.out.print(&quot;Hello World!&quot;);</span><br><span class="line">		System.out.println();&#x2F;&#x2F;换行</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>03.数据结构-队列</title>
    <url>/2020/07/05/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列-数组实现"><a href="#队列-数组实现" class="headerlink" title="队列-数组实现"></a>队列-数组实现</h2><ol>
<li><h4 id="队列的一个使用场景"><a href="#队列的一个使用场景" class="headerlink" title="队列的一个使用场景"></a>队列的一个使用场景</h4><p> 银行排队的案例:<br> <img src="http://wangzixuan.work/2346" alt=""></p>
</li>
<li><h4 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h4><ol>
<li>队列是一个 有序列表，可以用 数组或是链表来实现。</li>
<li>遵循 先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li>
<li>示意图：(使用数组模拟队列示意图)<br><img src="http://wangzixuan.work/2361" alt=""></li>
</ol>
</li>
<li><h4 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h4><ul>
<li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中maxSize 是该队列的最大容量。</p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标，front会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示:<br><img src="http://wangzixuan.work/2361" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; 创建一个队列</span><br><span class="line">		ArrayQueue queue &#x3D; new ArrayQueue(3);</span><br><span class="line">		&#x2F;&#x2F; 接受用户输入</span><br><span class="line">		char key &#x3D; &#39; &#39;;</span><br><span class="line">		&#x2F;&#x2F; 创建输出</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		boolean loop &#x3D; true;</span><br><span class="line">		&#x2F;&#x2F;输出一个菜单</span><br><span class="line">		while (loop) &#123;</span><br><span class="line">			System.out.println(&quot;\t\ts(show): 显示队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\te(exit): 退出程序&quot;);</span><br><span class="line">			System.out.println(&quot;\t\ta(add): 添加数据到队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\tg(get): 从队列取出数据&quot;);</span><br><span class="line">			System.out.println(&quot;\t\th(head): 查看队列头的数据&quot;);</span><br><span class="line">			key &#x3D; sc.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">			switch (key) &#123;</span><br><span class="line">				case &#39;a&#39; : &#x2F;&#x2F; 添加数据到队列</span><br><span class="line">					System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">					int n &#x3D; sc.nextInt();</span><br><span class="line">					queue.addQueue(n);</span><br><span class="line">					break;</span><br><span class="line">				case &#39;g&#39; : &#x2F;&#x2F; 从队列取出数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;取出的数据是：%d\n&quot;,queue.getQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;s&#39; : &#x2F;&#x2F; 显示队列</span><br><span class="line">					queue.showQueue();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;h&#39; : &#x2F;&#x2F; 查看队列头的数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;队列头的数据是：%d\n&quot;,queue.headQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;e&#39; : &#x2F;&#x2F; 退出程序</span><br><span class="line">	    sc.close();</span><br><span class="line">					loop &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;程序退出~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ArrayQueue&#123;</span><br><span class="line">	private int MaxSize; &#x2F;&#x2F; 队列的最大容量</span><br><span class="line">	private int front; &#x2F;&#x2F; 队列头</span><br><span class="line">	private int rear; &#x2F;&#x2F; 队列尾</span><br><span class="line">	private int[] arr; &#x2F;&#x2F; 该数据用于存放数据, 模拟队列</span><br><span class="line">	</span><br><span class="line">	public ArrayQueue(int arrMaxSize)&#123;</span><br><span class="line">		arr &#x3D;  new int[arrMaxSize];</span><br><span class="line">		MaxSize &#x3D; arrMaxSize;</span><br><span class="line">		front &#x3D; -1; &#x2F;&#x2F; 指向队列头部，分析出front是指向队列头的前一个位置.</span><br><span class="line">		rear &#x3D; -1; &#x2F;&#x2F; 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否满</span><br><span class="line">	public boolean isFull()&#123;</span><br><span class="line">		return rear &#x3D;&#x3D; MaxSize-1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	public boolean isEmpty()&#123;</span><br><span class="line">		return front &#x3D;&#x3D; rear;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 添加数据到队列</span><br><span class="line">	public void addQueue(int n)&#123;</span><br><span class="line">		if (isFull()) &#123;</span><br><span class="line">			System.out.println(&quot;队列已满，不能添加！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		rear++; &#x2F;&#x2F; 进队列，rear后移一位</span><br><span class="line">		arr[rear] &#x3D; n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 获取队列的数据, 出队列</span><br><span class="line">	public int getQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		front++; &#x2F;&#x2F; 出队列，front后移一位</span><br><span class="line">		return arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的所有数据</span><br><span class="line">	public void showQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			System.out.println(&quot;队列空的，没有数据~~&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 遍历</span><br><span class="line">		for (int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">			System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的头数据， 注意不是取出数据</span><br><span class="line">	public int headQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[front+1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>问题分析并优化</p>
<ol>
<li>目前数组使用一次就不能用， 没有达到复用的效果</li>
<li>将这个数组使用算法，改进成一个列 环形的队列 取模：%</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h4><p> 对前面的数组模拟队列的优化，充分利用数组。 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<ul>
<li><p>分析说明</p>
<ol>
<li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front 满]</li>
<li>rear == front [空]</li>
<li>分析示意图<br><img src="http://wangzixuan.work/2361" alt=""></li>
<li>思路如下<ol>
<li>front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素<br>front 的初始值 = 0</li>
<li>rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.<br>rear 的初始值 = 0</li>
<li>当队列满时，条件是  (rear  + 1) % maxSize == front 【满】</li>
<li>对队列为空的条件， rear == front 【空】</li>
<li>当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize</li>
</ol>
</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试一把</span><br><span class="line">		System.out.println(&quot;测试数组模拟环形队列的案例~~~&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建一个环形队列</span><br><span class="line">		CircleArrayQueue queue &#x3D; new CircleArrayQueue(4); &#x2F;&#x2F;说明设置4, 其队列的有效数据最大是3</span><br><span class="line">		&#x2F;&#x2F; 接受用户输入</span><br><span class="line">		char key &#x3D; &#39; &#39;;</span><br><span class="line">		&#x2F;&#x2F; 创建输出</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		boolean loop &#x3D; true;</span><br><span class="line">		&#x2F;&#x2F;输出一个菜单</span><br><span class="line">		while (loop) &#123;</span><br><span class="line">			System.out.println(&quot;\t\ts(show): 显示队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\te(exit): 退出程序&quot;);</span><br><span class="line">			System.out.println(&quot;\t\ta(add): 添加数据到队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\tg(get): 从队列取出数据&quot;);</span><br><span class="line">			System.out.println(&quot;\t\th(head): 查看队列头的数据&quot;);</span><br><span class="line">			key &#x3D; sc.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">			switch (key) &#123;</span><br><span class="line">				case &#39;a&#39; : &#x2F;&#x2F; 添加数据到队列</span><br><span class="line">					System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">					int n &#x3D; sc.nextInt();</span><br><span class="line">					queue.addQueue(n);</span><br><span class="line">					break;</span><br><span class="line">				case &#39;g&#39; : &#x2F;&#x2F; 从队列取出数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;取出的数据是：%d\n&quot;,queue.getQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;s&#39; : &#x2F;&#x2F; 显示队列</span><br><span class="line">					queue.showQueue();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;h&#39; : &#x2F;&#x2F; 查看队列头的数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;队列头的数据是：%d\n&quot;,queue.headQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;e&#39; : &#x2F;&#x2F; 退出程序</span><br><span class="line">					sc.close();</span><br><span class="line">					loop &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;程序退出~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class CircleArrayQueue&#123;</span><br><span class="line">	private int MaxSize; &#x2F;&#x2F; 表示数组的最大容量</span><br><span class="line">	&#x2F;&#x2F; front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span><br><span class="line">	&#x2F;&#x2F; front 的初始值 &#x3D; 0</span><br><span class="line">	private int front; </span><br><span class="line">	&#x2F;&#x2F; rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span><br><span class="line">	&#x2F;&#x2F; rear 的初始值 &#x3D; 0</span><br><span class="line">	private int rear; &#x2F;&#x2F; 队列尾</span><br><span class="line">	private int[] arr; &#x2F;&#x2F; 该数据用于存放数据, 模拟队列</span><br><span class="line"></span><br><span class="line">	public CircleArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">		arr &#x3D; new int[arrMaxSize];</span><br><span class="line">		MaxSize &#x3D; arrMaxSize;</span><br><span class="line">		front &#x3D; 0; &#x2F;&#x2F; 指向队列头部，分析出front是指向队列头的位置</span><br><span class="line">		rear &#x3D; 0; &#x2F;&#x2F; 指向队列尾，指向队列尾的后一个位置</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 当前队列有效的数据的个数</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return ( rear + MaxSize - front ) % MaxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 判断队列是否满</span><br><span class="line">	public boolean isFull()&#123;</span><br><span class="line">		return ( rear + 1 ) % MaxSize &#x3D;&#x3D; front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	public boolean isEmpty()&#123;</span><br><span class="line">		return front &#x3D;&#x3D; rear;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 添加数据到队列</span><br><span class="line">	public void addQueue(int n)&#123;</span><br><span class="line">		if (isFull()) &#123;</span><br><span class="line">			System.out.println(&quot;队列已满，不能添加！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;直接将数据加入</span><br><span class="line">		arr[rear] &#x3D; n;</span><br><span class="line">		&#x2F;&#x2F;将 rear 后移, 这里必须考虑取模</span><br><span class="line">		rear &#x3D; ( rear + 1 ) % MaxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 获取队列的数据, 出队列</span><br><span class="line">	public int getQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 这里需要分析出 front是指向队列的第一个元素</span><br><span class="line">		&#x2F;&#x2F; 1. 先把 front 对应的值保留到一个临时变量</span><br><span class="line">		&#x2F;&#x2F; 2. 将 front 后移, 考虑取模</span><br><span class="line">		&#x2F;&#x2F; 3. 将临时保存的变量返回</span><br><span class="line">		int temp &#x3D; arr[front];</span><br><span class="line">		front &#x3D; ( front + 1 ) % MaxSize;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的所有数据</span><br><span class="line">	public void showQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			System.out.println(&quot;队列空的，没有数据~~&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 思路：从front开始遍历，遍历多少个元素</span><br><span class="line">		&#x2F;&#x2F; 动脑筋</span><br><span class="line">		for (int i &#x3D; front; i &lt; front + size(); i++)&#123;</span><br><span class="line">			System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i % MaxSize, arr[i % MaxSize]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的头数据， 注意不是取出数据</span><br><span class="line">	public int headQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，没有数据~~&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>队列</tag>
        <tag>环形队列</tag>
        <tag>数组模拟队列</tag>
        <tag>数组模拟环形队列</tag>
      </tags>
  </entry>
  <entry>
    <title>04.Java基础知识-关键字、保留字与标识符</title>
    <url>/2020/07/05/04-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h2><ul>
<li><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul>
<li><strong>定义</strong>：被Java 语言赋予了特殊含义，用做专门用途的字符串（单词）</li>
<li><strong>特点</strong>：关键字中所有字母都为小写</li>
<li><strong>官方地址</strong>： <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a><br><img src="http://wangzixuan.work/2416" alt=""><br><img src="http://wangzixuan.work/2419" alt=""></li>
<li><strong>注</strong>：true、false、null虽然不是关键字，但是命名时不可用。</li>
</ul>
</li>
<li><h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><ul>
<li><strong>Java保留字</strong>：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字goto 、const<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2></li>
</ul>
</li>
<li><h4 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li>
<li><strong>技巧</strong>：凡是自己可以起名字的地方都叫标识符。</li>
</ul>
</li>
<li><h4 id="定义合法标识符规则"><a href="#定义合法标识符规则" class="headerlink" title="定义合法标识符规则"></a>定义合法标识符规则</h4><ul>
<li>由26 个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格</li>
</ul>
</li>
<li><h4 id="Java中的名称命名规范"><a href="#Java中的名称命名规范" class="headerlink" title="Java中的名称命名规范"></a>Java中的名称命名规范</h4><ul>
<li><strong>包名</strong>：多单词组成时所有字母都小写：xxxyyyzzz</li>
<li><strong>类名、接口名</strong>：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
<li><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li>
<li><strong>常量名</strong>：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ul>
</li>
<li><strong>注意1</strong>：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</li>
<li><strong>注意2</strong>：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>关键字</tag>
        <tag>保留字</tag>
        <tag>标识符</tag>
      </tags>
  </entry>
  <entry>
    <title>04.数据结构-链表</title>
    <url>/2020/07/06/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一、链表-Linked-List-介绍"><a href="#一、链表-Linked-List-介绍" class="headerlink" title="一、链表(Linked List)介绍"></a>一、链表(Linked List)介绍</h2><p>链表是有序的列表，但是它在内存中是存储如下</p>
<p><img src="http://wangzixuan.work/2630" alt=""></p>
<p><strong>上图小结:</strong></p>
<ul>
<li>链表是以节点的方式来存储,是链式存储</li>
<li>每个节点包含 data 域， next 域：指向下一个节点.</li>
<li>如图：发现链表的各个节点不一定是连续存储.</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定<ul>
<li>单链表(带头结点) 逻辑结构示意图如下<br><img src="http://wangzixuan.work/2633" alt=""><h2 id="二、单链表的应用实例"><a href="#二、单链表的应用实例" class="headerlink" title="二、单链表的应用实例"></a>二、单链表的应用实例</h2>使用带 head 头的单向链表实现–水浒英雄排行榜管理完成对英雄人物的增删改查操作。<br><img src="http://wangzixuan.work/2635" alt=""></li>
</ul>
</li>
</ul>
<ol>
<li><p>第一种方法在添加英雄时，直接添加到链表的尾部<br>思路分析示意图:<br><img src="http://wangzixuan.work/2637" alt=""></p>
</li>
<li><p>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)<br>思路的分析示意图:<br><img src="http://wangzixuan.work/2639" alt=""></p>
</li>
<li><p>修改节点功能<br>思路<br>先找到该节点，通过遍历</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.name &#x3D; newHeroNode.name ;</span><br><span class="line">temp.nickname&#x3D; newHeroNode.nickname</span><br></pre></td></tr></table></figure></li>
<li><p>删除节点<br>思路分析的示意图:<br><img src="http://wangzixuan.work/2641" alt=""></p>
</li>
<li><p>代码演示:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个链表</span><br><span class="line">		SingleLinkedList singlelinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode h1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">		HeroNode h2 &#x3D; new HeroNode(2,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">		HeroNode h3 &#x3D; new HeroNode(3,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode h4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		&#x2F;&#x2F;直接添加无排序</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h1);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h2);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h3);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h4);</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		singlelinkedList.addByOrder(h3);</span><br><span class="line">		singlelinkedList.addByOrder(h2);</span><br><span class="line">		singlelinkedList.addByOrder(h4);</span><br><span class="line">		singlelinkedList.addByOrder(h1);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		System.out.println(&quot;修改豹子头林冲&quot;);</span><br><span class="line">		HeroNode h5 &#x3D; new HeroNode(4,&quot;林冲~~~&quot;,&quot;豹子头~~~&quot;);</span><br><span class="line">		singlelinkedList.update(h5);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		&#x2F;&#x2F;删除</span><br><span class="line">		System.out.println(&quot;删除豹子头林冲&quot;);</span><br><span class="line">		singlelinkedList.delete(1);</span><br><span class="line">		singlelinkedList.delete(2);</span><br><span class="line">		singlelinkedList.delete(3);</span><br><span class="line">		singlelinkedList.delete(4);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义SingleLinkedList 管理我们的英雄</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">	&#x2F;&#x2F;思路，当不考虑编号顺序时</span><br><span class="line">	&#x2F;&#x2F;1. 找到当前链表的最后节点</span><br><span class="line">	&#x2F;&#x2F;2. 将最后这个节点的next 指向 新的节点</span><br><span class="line">	public void add(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		&#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			&#x2F;&#x2F;找到链表的最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;遍历结束</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;如果没有找到最后, 将将temp后移</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;当退出while循环时，temp就指向了链表的最后</span><br><span class="line">		&#x2F;&#x2F;将最后这个节点的next 指向 新的节点</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;添加成功&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span><br><span class="line">	&#x2F;&#x2F;(如果有这个排名，则添加失败，并给出提示)</span><br><span class="line">	public void addByOrder(HeroNode heroNode)&#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span><br><span class="line">		&#x2F;&#x2F;因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F; flag标志添加的编号是否存在，默认为false</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break ;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else if(temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;后移，遍历当前链表</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			System.out.printf(&quot;添加失败，排名为%d的英雄已经存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;插入到链表中, temp的后面</span><br><span class="line">			heroNode.next &#x3D; temp.next;</span><br><span class="line">			temp.next &#x3D; heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改节点的信息, 根据no编号来修改，即no编号不能改.</span><br><span class="line">	&#x2F;&#x2F;说明</span><br><span class="line">	&#x2F;&#x2F;1. 根据 newHeroNode 的 no 来修改即可</span><br><span class="line">	public void update(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;遍历</span><br><span class="line">		&#x2F;&#x2F;找到需要修改的节点, 根据no编号</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F;表示是否找到该节点</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;&#x2F;&#x2F;已经遍历完链表</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;&#x2F;&#x2F;找到</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;根据flag 判断是否找到要修改的节点</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			temp.next.name &#x3D; heroNode.name;</span><br><span class="line">			temp.next.nickName &#x3D; heroNode.nickName;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	&#x2F;&#x2F;思路</span><br><span class="line">	&#x2F;&#x2F;1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span><br><span class="line">	&#x2F;&#x2F;2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span><br><span class="line">	public void delete(int no)&#123;</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false; &#x2F;&#x2F; 标志是否找到待删除节点的</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; no)&#123;&#x2F;&#x2F;找到的待删除节点的前一个节点temp</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;temp后移，遍历</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;判断flag</span><br><span class="line">		if (flag)&#123; &#x2F;&#x2F;找到</span><br><span class="line">			temp.next &#x3D; temp.next.next;&#x2F;&#x2F;可以删除</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示链表[遍历]</span><br><span class="line">	public void list()&#123;</span><br><span class="line">		&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;链表为空，没有数据！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;输出节点的信息</span><br><span class="line">			System.out.println(temp.next);</span><br><span class="line">			&#x2F;&#x2F;将temp后移， 一定小心</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">	int no;</span><br><span class="line">	String name;</span><br><span class="line">	String nickName;</span><br><span class="line">	HeroNode next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode(int no, String name, String nickName)&#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickName &#x3D; nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickName&#x3D;&quot; + nickName  + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title>05.Java基础知识-变量与数据类型</title>
    <url>/2020/07/05/05-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><ul>
<li><p><strong>变量的概念</strong>：</p>
<ul>
<li>内存中的一个存储区域</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元。包含变量类型、变变量名和存储的值</li>
</ul>
</li>
<li><p><strong>变量的作用</strong>：</p>
<ul>
<li>用于在内存中保存数据</li>
</ul>
</li>
<li><p><strong>使用变量注意</strong>：</p>
<ul>
<li>Java中每个变量必须先声明，后使用</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量的作用域：其定义所在的一对{ }内</li>
<li>变量只有在其作用域内才有效</li>
<li>同一个作用域内，不能定义重名的变量</li>
</ul>
</li>
<li><p><strong>声明变量</strong></p>
<ul>
<li>语法：&lt;数据类型&gt; &lt;变量名称&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int var;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>变量的赋值</strong></p>
<ul>
<li>语法：&lt;变量名称&gt; = &lt;值&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var &#x3D; 10;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>声明和赋值变量</strong></p>
<ul>
<li>语法： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int var &#x3D; 10;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>变量的分类-按数据类型</strong></p>
<ul>
<li>对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间。<br><img src="http://wangzixuan.work/2483" alt=""></li>
</ul>
</li>
<li><p><strong>变量的分类-按声明的位置的不同</strong></p>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量<br><img src="http://wangzixuan.work/2486" alt=""></li>
<li>注意：二者在初始化值方面的异同:<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，需显式初始化。<h2 id="二、整数类型"><a href="#二、整数类型" class="headerlink" title="二、整数类型"></a>二、整数类型</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。</p>
</li>
<li><p>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</p>
</li>
<li><p>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long<br><img src="http://wangzixuan.work/2510" alt=""></p>
</li>
<li><p>500MB 1MB = 1024KB 1KB= 1024B B= byte ? bit?<br>bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。</p>
<h2 id="三、浮点类型"><a href="#三、浮点类型" class="headerlink" title="三、浮点类型"></a>三、浮点类型</h2></li>
<li><p>与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。</p>
</li>
<li><p>浮点型常量有两种表示形式：</p>
<ul>
<li>十进制数形式：如：5.12、512.0f、.512 (必须有小数点）</li>
<li>科学计数法形式:如：5.12e2、512E2、100E-2</li>
</ul>
</li>
<li><p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。</p>
</li>
<li><p>double:双精度，精度是float的两倍。通常采用此类型。</p>
</li>
<li><p>Java 的浮点型常量默认为double型，声明float 型常量，须后加‘f’ 或‘F’ 。<br><img src="http://wangzixuan.work/2512" alt=""></p>
<h2 id="四、字符类型"><a href="#四、字符类型" class="headerlink" title="四、字符类型"></a>四、字符类型</h2></li>
<li><p>char 型数据用来表示通常意义上“字符”(2字节)</p>
</li>
<li><p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</p>
</li>
<li><p>字符型变量的三种表现形式：</p>
<ul>
<li>字符常量是用单引号(‘ ‘)括起来的单个字符。例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c1 &#x3D; &#39;a&#39;;</span><br><span class="line">char c2&#x3D; &#39;中&#39;;</span><br><span class="line">char c3 &#x3D; &#39;9&#39;;</span><br></pre></td></tr></table></figure></li>
<li>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c3 &#x3D; ‘\n’; &#x2F;&#x2F; &#39;\n&#39;表示换行符</span><br></pre></td></tr></table></figure>
  <img src="http://wangzixuan.work/2514" alt=""></li>
<li>直接使用 Unicode值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个十六进制整数。如：\u000a 表示 \n。</li>
</ul>
</li>
<li><p>char类型是可以进行运算的。因为它都对应有Unicode码。</p>
<h2 id="五、布尔类型"><a href="#五、布尔类型" class="headerlink" title="五、布尔类型"></a>五、布尔类型</h2></li>
<li><p>boolean 类型用来判断逻辑条件，一般用于程序流程控制：</p>
<ul>
<li>if条件控制语句；</li>
<li>while循环控制语句；</li>
<li>do-while循环控制语句；</li>
<li>for循环控制语句；</li>
</ul>
</li>
<li><p>boolean类型数据只允许取值true和false，无null。</p>
<ul>
<li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</li>
<li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。———《java虚拟机规范 8版》<h2 id="六、String字符串类型"><a href="#六、String字符串类型" class="headerlink" title="六、String字符串类型"></a>六、String字符串类型</h2></li>
</ul>
</li>
<li><p>String不是基本数据类型，属于引用数据类型</p>
</li>
<li><p>使用方式与基本数据类型一致。例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; “abcd”;</span><br></pre></td></tr></table></figure></li>
<li><p>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; str + “xyz” ;</span><br><span class="line">int n &#x3D; 100;</span><br><span class="line">str &#x3D; str + n;</span><br></pre></td></tr></table></figure>
<h2 id="七、类型转换"><a href="#七、类型转换" class="headerlink" title="七、类型转换"></a>七、类型转换</h2></li>
<li><p>基本数据类型转换</p>
<ul>
<li>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：<img src="http://wangzixuan.work/2584" alt=""></li>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。</li>
<li>byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</li>
<li>boolean类型不能与其它数据类型运算。</li>
<li>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。</li>
</ul>
</li>
<li><p>强制类型转换</p>
<ul>
<li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</li>
<li>如：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double a &#x3D; 1.23;</span><br><span class="line">int i &#x3D; (int)a;</span><br></pre></td></tr></table></figure></li>
<li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。</li>
<li>如：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a &#x3D; “43”;</span><br><span class="line">int i &#x3D; Integer.parseInt(a);</span><br></pre></td></tr></table></figure></li>
<li>boolean类型不可以转换为其它的数据类型。</li>
</ul>
</li>
</ul>
<h2 id="八、了解"><a href="#八、了解" class="headerlink" title="八、了解"></a>八、了解</h2><p><img src="http://wangzixuan.work/2551" alt=""><br><img src="http://wangzixuan.work/2553" alt=""><br><img src="http://wangzixuan.work/2555" alt=""></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>变量</tag>
        <tag>整数类型</tag>
        <tag>浮点类型</tag>
        <tag>字符类型</tag>
        <tag>布尔类型</tag>
        <tag>String字符串类型</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>05.数据结构-单链表面试题</title>
    <url>/2020/07/08/05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="单链表的常见面试题有如下"><a href="#单链表的常见面试题有如下" class="headerlink" title="单链表的常见面试题有如下:"></a>单链表的常见面试题有如下:</h2><ul>
<li><p>求单链表中有效节点的个数</p>
<ul>
<li><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span><br><span class="line">public static int getLength(HeroNode head) &#123;</span><br><span class="line">	if (head.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;空链表</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int length &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助的变量, 这里我们没有统计头节点</span><br><span class="line">	HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">	while (cur.next !&#x3D; null) &#123; &#x2F;&#x2F; while(cur !&#x3D; null) &#123;</span><br><span class="line">		length++;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查找单链表中的倒数第k个结点 【新浪面试题】</p>
<ul>
<li><p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;查找单链表中的倒数第k个结点 【新浪面试题】</span><br><span class="line">&#x2F;&#x2F;思路</span><br><span class="line">&#x2F;&#x2F;1. 编写一个方法，接收head节点，同时接收一个index </span><br><span class="line">&#x2F;&#x2F;2. index 表示是倒数第index个节点</span><br><span class="line">&#x2F;&#x2F;3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span><br><span class="line">&#x2F;&#x2F;4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span><br><span class="line">&#x2F;&#x2F;5. 如果找到了，则返回该节点，否则返回nulll</span><br><span class="line">public static HeroNode findLastIndexNode(HeroNode head, int index)&#123;</span><br><span class="line">	&#x2F;&#x2F;判断如果链表为空，返回null</span><br><span class="line">	if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;第一个遍历得到链表的长度(节点个数)</span><br><span class="line">	int length &#x3D; getLength(head);</span><br><span class="line">	&#x2F;&#x2F;第二次遍历  size-index 位置，就是我们倒数的第K个节点</span><br><span class="line">	&#x2F;&#x2F;先做一个index的校验</span><br><span class="line">	if (index &lt;&#x3D; 0 || index &gt; length)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">	for(int i &#x3D; 0; i &lt;&#x3D; length - index; i++) &#123;&#x2F;&#x2F; for(int i &#x3D;0; i&lt; size - index; i++) &#123;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单链表的反转【腾讯面试题，有点难度】</p>
<ul>
<li><p>图解思路</p>
<ol>
<li>先定义一个节点 reverseHead = new HeroNode();</li>
<li>从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端.</li>
<li>原来的链表的head.next = reverseHead.next</li>
</ol>
<p><img src="http://wangzixuan.work/2970" alt=""><br><img src="http://wangzixuan.work/2973" alt=""></p>
</li>
<li><p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将单链表反转</span><br><span class="line">public static void reversetList(HeroNode head)&#123;</span><br><span class="line">	&#x2F;&#x2F;如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">	if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	HeroNode reverseHead &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span><br><span class="line">	HeroNode cur &#x3D; head.next ;</span><br><span class="line">	HeroNode next &#x3D; null;&#x2F;&#x2F; 指向当前节点[cur]的下一个节点</span><br><span class="line">	&#x2F;&#x2F;遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span><br><span class="line">	while(cur !&#x3D; null) &#123;</span><br><span class="line">		next &#x3D; cur.next;&#x2F;&#x2F;先暂时保存当前节点的下一个节点，因为后面需要使用</span><br><span class="line">		cur.next &#x3D; reverseHead.next;&#x2F;&#x2F;将cur的下一个节点指向新的链表的最前端</span><br><span class="line">		reverseHead.next &#x3D; cur;&#x2F;&#x2F;将cur 连接到新的链表上</span><br><span class="line">		cur &#x3D; next;&#x2F;&#x2F;让cur后移</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将head.next 指向 reverseHead.next , 实现单链表的反转</span><br><span class="line">	head.next &#x3D; reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】</p>
<ul>
<li><p>图解思路</p>
<p><img src="http://wangzixuan.work/2975" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;方式2：</span><br><span class="line">&#x2F;&#x2F;可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span><br><span class="line">public static void reversePrint(HeroNode head) &#123;</span><br><span class="line">	if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return;&#x2F;&#x2F;空链表，不能打印</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;创建要给一个栈，将各个节点压入栈</span><br><span class="line">	Stack&lt;HeroNode&gt; stack &#x3D; new Stack&lt;HeroNode&gt;();</span><br><span class="line">	HeroNode cur &#x3D; head.next;</span><br><span class="line">	&#x2F;&#x2F;将链表的所有节点压入栈</span><br><span class="line">	while(cur !&#x3D; null) &#123;</span><br><span class="line">		stack.push(cur);</span><br><span class="line">		cur &#x3D; cur.next; &#x2F;&#x2F;cur后移，这样就可以压入下一个节点</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将栈中的节点进行打印,pop 出栈</span><br><span class="line">	while (stack.size() &gt; 0) &#123;</span><br><span class="line">		System.out.println(stack.pop()); &#x2F;&#x2F;stack的特点是先进后出</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>合并两个有序的单链表，合并之后的链表依然有序</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.linkedlist;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个链表</span><br><span class="line">		SingleLinkedList singlelinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode h1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">		HeroNode h2 &#x3D; new HeroNode(2,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">		HeroNode h3 &#x3D; new HeroNode(3,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode h4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		singlelinkedList.addByOrder(h3);</span><br><span class="line">		singlelinkedList.addByOrder(h2);</span><br><span class="line">		singlelinkedList.addByOrder(h4);</span><br><span class="line">		singlelinkedList.addByOrder(h1);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;创建第二个链表</span><br><span class="line">		SingleLinkedList singlelinkedList1 &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode h11 &#x3D; new HeroNode(10,&quot;张三&quot;,&quot;张三&quot;);</span><br><span class="line">		HeroNode h22 &#x3D; new HeroNode(21,&quot;李四&quot;,&quot;李四&quot;);</span><br><span class="line">		HeroNode h33 &#x3D; new HeroNode(13,&quot;王五&quot;,&quot;王五&quot;);</span><br><span class="line">		HeroNode h44 &#x3D; new HeroNode(45,&quot;刘六&quot;,&quot;刘六&quot;);</span><br><span class="line">		singlelinkedList1.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		singlelinkedList1.addByOrder(h11);</span><br><span class="line">		singlelinkedList1.addByOrder(h22);</span><br><span class="line">		singlelinkedList1.addByOrder(h33);</span><br><span class="line">		singlelinkedList1.addByOrder(h44);</span><br><span class="line">		singlelinkedList1.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;直接添加无排序</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h11);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h22);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h33);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h44);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList1.list();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;合并两个有序的单链表，合并之后的链表依然有序</span><br><span class="line">		System.out.println(&quot;合并两个有序的单链表，合并之后的链表依然有序&quot;);</span><br><span class="line">		singlelinkedListTwo(singlelinkedList1.getHead(),singlelinkedList.getHead());</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;获取有效节点的个数</span><br><span class="line">		&#x2F;*System.out.println(&quot;有效节点个数：&quot;+getLength(singlelinkedList.getHead()));*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;倒数第k个节点</span><br><span class="line">		&#x2F;*System.out.println(&quot;倒数第k个节点：&quot;+findLastIndexNode(singlelinkedList.getHead(),1));*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;翻转</span><br><span class="line">		&#x2F;*System.out.println(&quot;反转&quot;);</span><br><span class="line">		reversetList(singlelinkedList.getHead());</span><br><span class="line">		singlelinkedList.list();*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;逆序打印</span><br><span class="line">		&#x2F;*System.out.println(&quot;反转&quot;);</span><br><span class="line">		reversePrint(singlelinkedList.getHead());*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		&#x2F;*System.out.println(&quot;修改豹子头林冲&quot;);</span><br><span class="line">		HeroNode h5 &#x3D; new HeroNode(4,&quot;林冲~~~&quot;,&quot;豹子头~~~&quot;);</span><br><span class="line">		singlelinkedList.update(h5);</span><br><span class="line">		singlelinkedList.list();*&#x2F;</span><br><span class="line">		&#x2F;&#x2F;删除</span><br><span class="line">		&#x2F;*System.out.println(&quot;删除豹子头林冲&quot;);</span><br><span class="line">		singlelinkedList.delete(1);</span><br><span class="line">		singlelinkedList.delete(2);</span><br><span class="line">		singlelinkedList.delete(3);</span><br><span class="line">		singlelinkedList.delete(4);</span><br><span class="line">		singlelinkedList.list();*&#x2F;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;合并两个有序的单链表，合并之后的链表依然有序</span><br><span class="line">	public static void singlelinkedListTwo(HeroNode head1 , HeroNode head2)&#123;</span><br><span class="line">		SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode  head&#x3D; singleLinkedList.getHead();</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">		HeroNode cur &#x3D; head;</span><br><span class="line">		HeroNode cur1 &#x3D; head1.next;</span><br><span class="line">		HeroNode cur2 &#x3D; head2.next;</span><br><span class="line">		while (cur1 !&#x3D; null &amp;&amp; cur2 !&#x3D; null) &#123;</span><br><span class="line">            if (cur1.no &lt;&#x3D; cur2.no) &#123;</span><br><span class="line">            	cur.next &#x3D; cur1;</span><br><span class="line">            	cur &#x3D; cur.next;</span><br><span class="line">                cur1 &#x3D; cur1.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	cur.next &#x3D; cur2;</span><br><span class="line">            	cur &#x3D; cur.next;</span><br><span class="line">                cur2 &#x3D; cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            while (cur2 !&#x3D; null) &#123;</span><br><span class="line">            	cur.next &#x3D; cur2;</span><br><span class="line">                cur &#x3D; cur.next;</span><br><span class="line">                cur2 &#x3D; cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (cur1 !&#x3D; null) &#123;</span><br><span class="line">            	cur.next &#x3D; cur1;</span><br><span class="line">            	cur &#x3D; cur.next;</span><br><span class="line">                cur1 &#x3D; cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span><br><span class="line">	public static int getLength(HeroNode head) &#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;空链表</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		int length &#x3D; 0;</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助的变量, 这里我们没有统计头节点</span><br><span class="line">		HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">		while (cur.next !&#x3D; null) &#123; &#x2F;&#x2F; while(cur !&#x3D; null) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			cur &#x3D; cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;查找单链表中的倒数第k个结点 【新浪面试题】</span><br><span class="line">	&#x2F;&#x2F;思路</span><br><span class="line">	&#x2F;&#x2F;1. 编写一个方法，接收head节点，同时接收一个index </span><br><span class="line">	&#x2F;&#x2F;2. index 表示是倒数第index个节点</span><br><span class="line">	&#x2F;&#x2F;3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span><br><span class="line">	&#x2F;&#x2F;4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span><br><span class="line">	&#x2F;&#x2F;5. 如果找到了，则返回该节点，否则返回null</span><br><span class="line">	public static HeroNode findLastIndexNode(HeroNode head, int index)&#123;</span><br><span class="line">		&#x2F;&#x2F;判断如果链表为空，返回null</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;第一个遍历得到链表的长度(节点个数)</span><br><span class="line">		int length &#x3D; getLength(head);</span><br><span class="line">		&#x2F;&#x2F;第二次遍历  size-index 位置，就是我们倒数的第K个节点</span><br><span class="line">		&#x2F;&#x2F;先做一个index的校验</span><br><span class="line">		if (index &lt;&#x3D; 0 || index &gt; length)&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">		for(int i &#x3D; 0; i &lt;&#x3D; length - index; i++) &#123;&#x2F;&#x2F; for(int i &#x3D;0; i&lt; size - index; i++) &#123;</span><br><span class="line">			cur &#x3D; cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return cur;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;将单链表反转</span><br><span class="line">	public static void reversetList(HeroNode head)&#123;</span><br><span class="line">		&#x2F;&#x2F;如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">		if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		HeroNode reverseHead &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span><br><span class="line">		HeroNode cur &#x3D; head.next ;</span><br><span class="line">		HeroNode next &#x3D; null;&#x2F;&#x2F; 指向当前节点[cur]的下一个节点</span><br><span class="line">		&#x2F;&#x2F;遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span><br><span class="line">		while(cur !&#x3D; null) &#123;</span><br><span class="line">			next &#x3D; cur.next;&#x2F;&#x2F;先暂时保存当前节点的下一个节点，因为后面需要使用</span><br><span class="line">			cur.next &#x3D; reverseHead.next;&#x2F;&#x2F;将cur的下一个节点指向新的链表的最前端</span><br><span class="line">			reverseHead.next &#x3D; cur;&#x2F;&#x2F;将cur 连接到新的链表上</span><br><span class="line">			cur &#x3D; next;&#x2F;&#x2F;让cur后移</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;将head.next 指向 reverseHead.next , 实现单链表的反转</span><br><span class="line">		head.next &#x3D; reverseHead.next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;方式2：</span><br><span class="line">	&#x2F;&#x2F;可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span><br><span class="line">	public static void reversePrint(HeroNode head) &#123;</span><br><span class="line">		if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return;&#x2F;&#x2F;空链表，不能打印</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;创建要给一个栈，将各个节点压入栈</span><br><span class="line">		Stack&lt;HeroNode&gt; stack &#x3D; new Stack&lt;HeroNode&gt;();</span><br><span class="line">		HeroNode cur &#x3D; head.next;</span><br><span class="line">		&#x2F;&#x2F;将链表的所有节点压入栈</span><br><span class="line">		while(cur !&#x3D; null) &#123;</span><br><span class="line">			stack.push(cur);</span><br><span class="line">			cur &#x3D; cur.next; &#x2F;&#x2F;cur后移，这样就可以压入下一个节点</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;将栈中的节点进行打印,pop 出栈</span><br><span class="line">		while (stack.size() &gt; 0) &#123;</span><br><span class="line">			System.out.println(stack.pop()); &#x2F;&#x2F;stack的特点是先进后出</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义SingleLinkedList 管理我们的英雄</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	public HeroNode getHead() &#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setHead(HeroNode head) &#123;</span><br><span class="line">		this.head &#x3D; head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">	&#x2F;&#x2F;思路，当不考虑编号顺序时</span><br><span class="line">	&#x2F;&#x2F;1. 找到当前链表的最后节点</span><br><span class="line">	&#x2F;&#x2F;2. 将最后这个节点的next 指向 新的节点</span><br><span class="line">	public void add(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		&#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			&#x2F;&#x2F;找到链表的最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;遍历结束</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;如果没有找到最后, 将将temp后移</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;当退出while循环时，temp就指向了链表的最后</span><br><span class="line">		&#x2F;&#x2F;将最后这个节点的next 指向 新的节点</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;添加成功&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span><br><span class="line">	&#x2F;&#x2F;(如果有这个排名，则添加失败，并给出提示)</span><br><span class="line">	public void addByOrder(HeroNode heroNode)&#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span><br><span class="line">		&#x2F;&#x2F;因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F; flag标志添加的编号是否存在，默认为false</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break ;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else if(temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;后移，遍历当前链表</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			System.out.printf(&quot;添加失败，排名为%d的英雄已经存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;插入到链表中, temp的后面</span><br><span class="line">			heroNode.next &#x3D; temp.next;</span><br><span class="line">			temp.next &#x3D; heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改节点的信息, 根据no编号来修改，即no编号不能改.</span><br><span class="line">	&#x2F;&#x2F;说明</span><br><span class="line">	&#x2F;&#x2F;1. 根据 newHeroNode 的 no 来修改即可</span><br><span class="line">	public void update(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;遍历</span><br><span class="line">		&#x2F;&#x2F;找到需要修改的节点, 根据no编号</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F;表示是否找到该节点</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;&#x2F;&#x2F;已经遍历完链表</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;&#x2F;&#x2F;找到</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;根据flag 判断是否找到要修改的节点</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			temp.next.name &#x3D; heroNode.name;</span><br><span class="line">			temp.next.nickName &#x3D; heroNode.nickName;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	&#x2F;&#x2F;思路</span><br><span class="line">	&#x2F;&#x2F;1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span><br><span class="line">	&#x2F;&#x2F;2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span><br><span class="line">	public void delete(int no)&#123;</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false; &#x2F;&#x2F; 标志是否找到待删除节点的</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; no)&#123;&#x2F;&#x2F;找到的待删除节点的前一个节点temp</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;temp后移，遍历</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;判断flag</span><br><span class="line">		if (flag)&#123; &#x2F;&#x2F;找到</span><br><span class="line">			temp.next &#x3D; temp.next.next;&#x2F;&#x2F;可以删除</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示链表[遍历]</span><br><span class="line">	public void list()&#123;</span><br><span class="line">		&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;链表为空，没有数据！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;输出节点的信息</span><br><span class="line">			System.out.println(temp.next);</span><br><span class="line">			&#x2F;&#x2F;将temp后移， 一定小心</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">	int no;</span><br><span class="line">	String name;</span><br><span class="line">	String nickName;</span><br><span class="line">	HeroNode next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode(int no, String name, String nickName)&#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickName &#x3D; nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickName&#x3D;&quot; + nickName  + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>单链表</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>06.Java基础知识-进制</title>
    <url>/2020/07/06/06-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<h2 id="世界上有10人种人，认识和不认识二进制的。"><a href="#世界上有10人种人，认识和不认识二进制的。" class="headerlink" title="世界上有10人种人，认识和不认识二进制的。"></a>世界上有10人种人，认识和不认识二进制的。</h2><h4 id="所有数字在计算机底层都以-二进制形式存在。"><a href="#所有数字在计算机底层都以-二进制形式存在。" class="headerlink" title="所有数字在计算机底层都以 二进制形式存在。"></a>所有数字在计算机底层都以 二进制形式存在。</h4><h4 id="对于整数，有四种表示方式："><a href="#对于整数，有四种表示方式：" class="headerlink" title="对于整数，有四种表示方式："></a>对于整数，有四种表示方式：</h4><ul>
<li>二进制(binary) ：0,1 ，满2进1.以0b或0B开头。</li>
<li>十进制(decimal) ：0-9 ，满10进1。</li>
<li>八进制(octal) ：0-7 ，满8进1. 以数字0开头表示。</li>
<li>十六进制(hex) ：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。</li>
<li>如：0x21AF +1= 0X21B0<br><img src="http://wangzixuan.work/2707" alt=""><br><img src="http://wangzixuan.work/2709" alt=""><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2></li>
<li>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位</li>
<li>二进制的整数有如下三种形式：<ul>
<li>原码：直接将一个数值换成二进制数。最高位是符号位</li>
<li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</li>
<li>负数的补码：其反码加1。</li>
</ul>
</li>
<li>计算机以二进制补码的形式保存所有的整数。<ul>
<li>正数的原码、反码、补码都相同</li>
<li>负数的补码是其反码+1<h2 id="为什么要使用原码、反码、补码表示形式呢？"><a href="#为什么要使用原码、反码、补码表示形式呢？" class="headerlink" title="为什么要使用原码、反码、补码表示形式呢？"></a>为什么要使用原码、反码、补码表示形式呢？</h2>计算机辨别“符号位”显然会让计算机的基础电路设计变得十分复杂! 于是<br>人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法,这样计算机运算的设计就更简单了。<br><img src="http://wangzixuan.work/2726" alt=""><br><img src="http://wangzixuan.work/2728" alt=""><br><img src="http://wangzixuan.work/2730" alt=""><br><img src="http://wangzixuan.work/2732" alt=""><br><img src="http://wangzixuan.work/2734" alt=""><br><img src="http://wangzixuan.work/2736" alt=""><br><img src="http://wangzixuan.work/2738" alt=""><br><img src="http://wangzixuan.work/2740" alt=""><br><img src="http://wangzixuan.work/2742" alt=""><br><img src="http://wangzixuan.work/2744" alt=""><br><img src="http://wangzixuan.work/2746" alt=""><br><img src="http://wangzixuan.work/2748" alt=""><br><img src="http://wangzixuan.work/2750" alt=""><h2 id="进制间转化"><a href="#进制间转化" class="headerlink" title="进制间转化"></a>进制间转化</h2><h4 id="进制的基本转换"><a href="#进制的基本转换" class="headerlink" title="进制的基本转换"></a>进制的基本转换</h4></li>
</ul>
</li>
<li>十进制 二进制互转<ul>
<li>二进制转成十进制  乘以2 的幂数</li>
<li>十进制转成二进制  除以2 取余数</li>
</ul>
</li>
<li>二进制 八进制互转</li>
<li>二进制 十六进制互转</li>
<li>十进制 八进制互转</li>
<li>十进制 十六进制互转<br><img src="http://wangzixuan.work/2776" alt=""><br><img src="http://wangzixuan.work/2778" alt=""><br><img src="http://wangzixuan.work/2780" alt=""></li>
</ul>
<h2 id="求一个0-255范围内的整数的十六进制值"><a href="#求一个0-255范围内的整数的十六进制值" class="headerlink" title="求一个0~255范围内的整数的十六进制值"></a>求一个0~255范围内的整数的十六进制值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 如何求一个0~255范围内的整数的十六进制值，例如60的十六进制表示形式3C</span><br><span class="line">		&#x2F;&#x2F; 0~255范围代表二进制控制在8位以内</span><br><span class="line">		int temp &#x3D; 60;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 方式一：自动实现</span><br><span class="line">		System.out.println(&quot;自动实现&quot;);</span><br><span class="line">		String str1 &#x3D; Integer.toBinaryString(temp);</span><br><span class="line">		System.out.println(temp+&quot;转换二进制:\t&quot; + str1);</span><br><span class="line">		</span><br><span class="line">		String str2 &#x3D; Integer.toHexString(temp);</span><br><span class="line">		System.out.println(temp+&quot;转换十六进制:\t&quot; + str2);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 方式二：自动实现</span><br><span class="line">		System.out.println(&quot;手动实现&quot;);</span><br><span class="line">		&#x2F;&#x2F; &amp;位运算符（与）：按底层二进制进行计算 相同为1，不同为0</span><br><span class="line">		&#x2F;&#x2F; 15二进制为1111 与 temp 进行&amp;运算可以求出 temp 二进制后四位的和</span><br><span class="line">		int k &#x3D; temp &amp; 15;</span><br><span class="line">		&#x2F;&#x2F; 判断是否超过9转换为（A-F）</span><br><span class="line">		char k1 &#x3D; (char)(k - 10 + 97);</span><br><span class="line">		&#x2F;&#x2F; 转换为String类型保存</span><br><span class="line">		String i &#x3D; k &gt; 9 ? k1 + &quot;&quot; : k + &quot;&quot; ;</span><br><span class="line">		&#x2F;&#x2F; &gt;&gt;位运算符（右移）：按底层二进制进行右移四位，剩余的正好是前四位</span><br><span class="line">		k &#x3D; temp &gt;&gt; 4;</span><br><span class="line">		&#x2F;&#x2F; 判断是否超过9转换为（A-F）</span><br><span class="line">		k1 &#x3D; (char)(k - 10 + 97);</span><br><span class="line">		&#x2F;&#x2F; 转换为String类型保存</span><br><span class="line">		String j &#x3D; k &gt; 9 ? k1 + &quot;&quot; : k + &quot;&quot; ;</span><br><span class="line">		</span><br><span class="line">		System.out.println(temp+&quot;转换十六进制:\t&quot; + j + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>进制</tag>
        <tag>二进制</tag>
        <tag>十进制</tag>
        <tag>八进制</tag>
        <tag>十六进制</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>06.数据结构-双链表</title>
    <url>/2020/07/09/06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点</p>
<h4 id="单链表与双链表区别"><a href="#单链表与双链表区别" class="headerlink" title="单链表与双链表区别"></a>单链表与双链表区别</h4><p>逻辑上没有区别。他们均是完成线性表的内容。主要的区别是结构上的构造有所区别。</p>
<ul>
<li>单链表<ul>
<li>对于一个节点，有储存数据的data。和next后驱节点(指针)。也就是这个单链表想要一些遍历的操作都得通过前节点—&gt;后节点。<br><img src="http://wangzixuan.work/3155" alt=""></li>
</ul>
</li>
<li>双链表<ul>
<li>对于一个节点，有些和单链表一样有存储数据的data,指向后方的next（指针）。它拥有单链表的所有操作和内容。但是他还有一个前驱节点pre(指针)。<br><img src="http://wangzixuan.work/3157" alt=""><h4 id="双向链表应用实例"><a href="#双向链表应用实例" class="headerlink" title="双向链表应用实例"></a>双向链表应用实例</h4></li>
</ul>
</li>
</ul>
<p><strong>使用带 head 头的双向链表实现 –水浒英雄排行榜</strong></p>
<ul>
<li>管理单向链表的缺点分析: <ul>
<li>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</li>
<li>单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).</li>
</ul>
</li>
<li>双链表图解:<br>  <img src="http://wangzixuan.work/3179" alt=""></li>
<li>图解思路:</li>
</ul>
<ol>
<li>遍历方发和单链表一样，只是可以向前，也可以向后查找</li>
<li>添加 (默认添加到双向链表的最后)<ol>
<li>先找到双向链表的最后这个节点</li>
<li>temp.next = heroNode</li>
<li>heroNode.pre = temp;</li>
</ol>
</li>
<li>修改思路和原来的单向链表一样.</li>
<li>删除<ol>
<li>因为是双向链表，因此，我们可以实现自我删除某个节点</li>
<li>直接找到要删除的这个节点，比如 temp</li>
<li>temp.pre.next = temp.next</li>
<li>temp.next.pre = temp.pre;</li>
</ol>
</li>
</ol>
<ul>
<li><p>代码实现:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		DoubleLinkedList doubleLinkedList &#x3D; new DoubleLinkedList();</span><br><span class="line">		HeroNode2 h1 &#x3D; new HeroNode2(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">		HeroNode2 h2 &#x3D; new HeroNode2(2,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">		HeroNode2 h3 &#x3D; new HeroNode2(3,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode2 h4 &#x3D; new HeroNode2(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">		HeroNode2 h5 &#x3D; new HeroNode2(4,&quot;张三&quot;,&quot;李四&quot;);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;顺序添加</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h1);</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h2);</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h3);</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h4);</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		doubleLinkedList.addByOrder(h3);</span><br><span class="line">		doubleLinkedList.addByOrder(h2);</span><br><span class="line">		doubleLinkedList.addByOrder(h4);</span><br><span class="line">		doubleLinkedList.addByOrder(h1);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		System.out.println(&quot;修改后的双链表&quot;);</span><br><span class="line">		doubleLinkedList.update(h5);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;删除</span><br><span class="line">		System.out.println(&quot;删除后的双链表&quot;);</span><br><span class="line">		doubleLinkedList.delete(3);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">class DoubleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode2 head &#x3D; new HeroNode2(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	public HeroNode2 getHead() &#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	public void delete(int no)&#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;双链表为空，无法删除！！！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;辅助节点</span><br><span class="line">		HeroNode2 temp &#x3D; head.next;</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		while(temp !&#x3D; null)&#123;</span><br><span class="line">			if (temp.no &#x3D;&#x3D; no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D;temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag)&#123;</span><br><span class="line">			temp.pre.next &#x3D; temp.next;</span><br><span class="line">			&#x2F;&#x2F;如果删除的节点是最后一个，不执行temp.next.pre &#x3D; temp.pre;</span><br><span class="line">			&#x2F;&#x2F; 因为temp.next &#x3D; null , temp.next.pre报空指针异常</span><br><span class="line">			if(temp.next !&#x3D; null)&#123;</span><br><span class="line">				temp.next.pre &#x3D; temp.pre;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;双链表中没有排名为%d的英雄！！！&quot;,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改节点</span><br><span class="line">	public void update(HeroNode2 heroNode)&#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;双链表为空，无法修改！！！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		while (temp.next !&#x3D; null)&#123;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			temp.next.name &#x3D; heroNode.name;</span><br><span class="line">			temp.next.nickName &#x3D; heroNode.nickName;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;双链表中没有排名为%d的英雄！！！&quot;,heroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;1.结尾添加节点</span><br><span class="line">	public void add(HeroNode2 heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head; </span><br><span class="line">		while(temp.next !&#x3D; null)&#123;</span><br><span class="line">			temp &#x3D; temp.next;&#x2F;&#x2F;后移</span><br><span class="line">		&#125;&#x2F;&#x2F;遍历结束后指向最后一个节点</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">		heroNode.pre &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;1.按英雄的排名添加节点</span><br><span class="line">	public void addByOrder(HeroNode2 heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		while (temp.next !&#x3D; null)&#123;</span><br><span class="line">			if (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;&#x2F;&#x2F;遍历结束后指向最后一个节点 或者 指向比排名大的前一个节点</span><br><span class="line">		&#x2F;&#x2F;如果查入的位置是最后一个节点，不执行 temp.next.pre &#x3D; heroNode;</span><br><span class="line">		&#x2F;&#x2F; 因为temp.next &#x3D; null , temp.next.pre报空指针异常</span><br><span class="line">		if (temp.next !&#x3D; null)&#123;</span><br><span class="line">			temp.next.pre &#x3D; heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">		heroNode.next &#x3D; temp.next;</span><br><span class="line">		heroNode.pre &#x3D; temp; </span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;遍历显示</span><br><span class="line">	public void list()&#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;双链表为空！！！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head; </span><br><span class="line">		while(temp.next !&#x3D; null)&#123;</span><br><span class="line">			System.out.println(temp.next);</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">	int no;</span><br><span class="line">	String name;</span><br><span class="line">	String nickName;</span><br><span class="line">	HeroNode2 next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">	HeroNode2 pre;&#x2F;&#x2F;指向上一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode2(int no, String name, String nickName)&#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickName &#x3D; nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickName&#x3D;&quot; + nickName  + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>双链表</tag>
      </tags>
  </entry>
  <entry>
    <title>07.Java基础知识-运算符</title>
    <url>/2020/07/06/07-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p>
<h2 id="一、算术运算符"><a href="#一、算术运算符" class="headerlink" title="一、算术运算符"></a>一、算术运算符</h2><p><img src="http://wangzixuan.work/2792" alt=""><br>算术运算符的注意问题</p>
<ul>
<li>如果对负数取模，可以把模数负号忽略不记，如：5%-2=1。 但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。</li>
<li>对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。 例如：int x=3510;x=x/1000*1000; x的结果是？</li>
<li>“+”除字符串相加功能外，还能把非字符串转换成字符串.例如：System.out.println(“5+5=”+5+5);//打印结果是？ 5+5=55 ?</li>
<li>示例  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之一：算术运算符</span><br><span class="line">+ - + - * &#x2F; % (前)++ (后)++ (前)-- (后)-- +</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">class AriTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;除号：&#x2F;</span><br><span class="line">		int num1 &#x3D; 12;</span><br><span class="line">		int num2 &#x3D; 5;</span><br><span class="line">		int result1 &#x3D; num1 &#x2F; num2;</span><br><span class="line">		System.out.println(result1);&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">		int result2 &#x3D; num1 &#x2F; num2 * num2;</span><br><span class="line">		System.out.println(result2);&#x2F;&#x2F;10</span><br><span class="line"></span><br><span class="line">		double result3 &#x3D; num1 &#x2F; num2;</span><br><span class="line">		System.out.println(result3);&#x2F;&#x2F;2.0</span><br><span class="line"></span><br><span class="line">		double result4 &#x3D; num1 &#x2F; num2 + 0.0;&#x2F;&#x2F;2.0</span><br><span class="line">		double result5 &#x3D; num1 &#x2F; (num2 + 0.0);&#x2F;&#x2F;2.4</span><br><span class="line">		double result6 &#x3D; (double)num1 &#x2F; num2;&#x2F;&#x2F;2.4</span><br><span class="line">		double result7 &#x3D; (double)(num1 &#x2F; num2);&#x2F;&#x2F;2.0</span><br><span class="line">		System.out.println(result5);</span><br><span class="line">		System.out.println(result6);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; %:取余运算</span><br><span class="line">		&#x2F;&#x2F;结果的符号与被模数的符号相同</span><br><span class="line">		&#x2F;&#x2F;开发中，经常使用%来判断能否被除尽的情况。</span><br><span class="line">		int m1 &#x3D; 12;</span><br><span class="line">		int n1 &#x3D; 5;</span><br><span class="line">		System.out.println(&quot;m1 % n1 &#x3D; &quot; + m1 % n1);</span><br><span class="line"></span><br><span class="line">		int m2 &#x3D; -12;</span><br><span class="line">		int n2 &#x3D; 5;</span><br><span class="line">		System.out.println(&quot;m2 % n2 &#x3D; &quot; + m2 % n2);</span><br><span class="line"></span><br><span class="line">		int m3 &#x3D; 12;</span><br><span class="line">		int n3 &#x3D; -5;</span><br><span class="line">		System.out.println(&quot;m3 % n3 &#x3D; &quot; + m3 % n3);</span><br><span class="line"></span><br><span class="line">		int m4 &#x3D; -12;</span><br><span class="line">		int n4 &#x3D; -5;</span><br><span class="line">		System.out.println(&quot;m4 % n4 &#x3D; &quot; + m4 % n4);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;(前)++ :先自增1，后运算</span><br><span class="line">		&#x2F;&#x2F;(后)++ :先运算，后自增1</span><br><span class="line">		int a1 &#x3D; 10;</span><br><span class="line">		int b1 &#x3D; ++a1;</span><br><span class="line">		System.out.println(&quot;a1 &#x3D; &quot; + a1 + &quot;,b1 &#x3D; &quot; + b1);</span><br><span class="line">		</span><br><span class="line">		int a2 &#x3D; 10;</span><br><span class="line">		int b2 &#x3D; a2++;</span><br><span class="line">		System.out.println(&quot;a2 &#x3D; &quot; + a2 + &quot;,b2 &#x3D; &quot; + b2);</span><br><span class="line">		</span><br><span class="line">		int a3 &#x3D; 10;</span><br><span class="line">		++a3;&#x2F;&#x2F;a3++;</span><br><span class="line">		int b3 &#x3D; a3;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;注意点：</span><br><span class="line">		short s1 &#x3D; 10;</span><br><span class="line">		&#x2F;&#x2F;s1 &#x3D; s1 + 1;&#x2F;&#x2F;编译失败</span><br><span class="line">		&#x2F;&#x2F;s1 &#x3D; (short)(s1 + 1);&#x2F;&#x2F;正确的</span><br><span class="line">		s1++;&#x2F;&#x2F;自增1不会改变本身变量的数据类型</span><br><span class="line">		System.out.println(s1);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;问题：</span><br><span class="line">		byte bb1 &#x3D;127;</span><br><span class="line">		bb1++;</span><br><span class="line">		System.out.println(&quot;bb1 &#x3D; &quot; + bb1);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;(前)-- :先自减1，后运算</span><br><span class="line">		&#x2F;&#x2F;(后)-- :先运算，后自减1</span><br><span class="line">		</span><br><span class="line">		int a4 &#x3D; 10;</span><br><span class="line">		int b4 &#x3D; a4--;&#x2F;&#x2F;int b4 &#x3D; --a4;</span><br><span class="line">		System.out.println(&quot;a4 &#x3D; &quot; + a4 + &quot;,b4 &#x3D; &quot; + b4);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二、赋值运算符"><a href="#二、赋值运算符" class="headerlink" title="二、赋值运算符"></a>二、赋值运算符</h2><ul>
<li>符号：=<ul>
<li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。</li>
<li>支持连续赋值。</li>
</ul>
</li>
<li>扩展赋值运算符： +=, -=, *=, /=, %=</li>
<li>示例  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之二：赋值运算符</span><br><span class="line">&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;  &#x2F;&#x3D;  %&#x3D; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">class SetValueTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;赋值符号：&#x3D;</span><br><span class="line">		int i1 &#x3D; 10;</span><br><span class="line">		int j1 &#x3D; 10;</span><br><span class="line"></span><br><span class="line">		int i2,j2;</span><br><span class="line">		&#x2F;&#x2F;连续赋值</span><br><span class="line">		i2 &#x3D; j2 &#x3D; 10;</span><br><span class="line"></span><br><span class="line">		int i3 &#x3D; 10,j3 &#x3D; 20;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;*********************</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		num1 +&#x3D; 2;&#x2F;&#x2F;num1 &#x3D; num1 + 2;</span><br><span class="line">		System.out.println(num1);&#x2F;&#x2F;12</span><br><span class="line"></span><br><span class="line">		int num2 &#x3D; 12;</span><br><span class="line">		num2 %&#x3D; 5;&#x2F;&#x2F;num2 &#x3D; num2 % 5;</span><br><span class="line">		System.out.println(num2);</span><br><span class="line"></span><br><span class="line">		short s1 &#x3D; 10;</span><br><span class="line">		&#x2F;&#x2F;s1 &#x3D; s1 + 2;&#x2F;&#x2F;编译失败</span><br><span class="line">		s1 +&#x3D; 2;&#x2F;&#x2F;结论：不会改变变量本身的数据类型</span><br><span class="line">		System.out.println(s1);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num &#x3D; 10;)</span><br><span class="line">		&#x2F;&#x2F;方式一：num &#x3D; num + 2;</span><br><span class="line">		&#x2F;&#x2F;方式二：num +&#x3D; 2; (推荐)</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num &#x3D; 10;)</span><br><span class="line">		&#x2F;&#x2F;方式一：num &#x3D; num + 1;</span><br><span class="line">		&#x2F;&#x2F;方式二：num +&#x3D; 1; </span><br><span class="line">		&#x2F;&#x2F;方式三：num++; (推荐)</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;练习1</span><br><span class="line">		int i &#x3D; 1;</span><br><span class="line">		i *&#x3D; 0.1;</span><br><span class="line">		System.out.println(i);&#x2F;&#x2F;0</span><br><span class="line">		i++;</span><br><span class="line">		System.out.println(i);&#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;练习2</span><br><span class="line">		int m &#x3D; 2;</span><br><span class="line">		int n &#x3D; 3;</span><br><span class="line">		n *&#x3D; m++; &#x2F;&#x2F;n &#x3D; n * m++;	</span><br><span class="line">		System.out.println(&quot;m&#x3D;&quot; + m);&#x2F;&#x2F;3</span><br><span class="line">		System.out.println(&quot;n&#x3D;&quot; + n);&#x2F;&#x2F;6</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;练习3</span><br><span class="line">		int n1 &#x3D; 10;</span><br><span class="line">		n1 +&#x3D; (n1++) + (++n1);&#x2F;&#x2F;n1 &#x3D; n1 + (n1++) + (++n1);</span><br><span class="line">		System.out.println(n1);&#x2F;&#x2F;32</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="三、比较运算符（关系运算符）"><a href="#三、比较运算符（关系运算符）" class="headerlink" title="三、比较运算符（关系运算符）"></a>三、比较运算符（关系运算符）</h2><p><img src="http://wangzixuan.work/2809" alt=""></p>
<ul>
<li><p>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</p>
</li>
<li><p>比较运算符“==” 不能误写成“=” 。</p>
</li>
<li><p>区分好==和=的区别。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean b1 &#x3D; false;</span><br><span class="line">if(b1&#x3D;&#x3D;true)</span><br><span class="line">System.out.println(&quot;结果为真&quot;);</span><br><span class="line">else</span><br><span class="line">System.out.println(&quot;结果为假&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之三：比较运算符</span><br><span class="line">&#x3D;&#x3D;  !&#x3D;  &gt;  &lt;  &gt;&#x3D; &lt;&#x3D;  instanceof</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">1.比较运算符的结果是boolean类型</span><br><span class="line">2.区分 &#x3D;&#x3D;  和  &#x3D; </span><br><span class="line">*&#x2F;</span><br><span class="line">class CompareTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 10;</span><br><span class="line">		int j &#x3D; 20;</span><br><span class="line"></span><br><span class="line">		System.out.println(i &#x3D;&#x3D; j);&#x2F;&#x2F;false</span><br><span class="line">		System.out.println(i &#x3D; j);&#x2F;&#x2F;20</span><br><span class="line"></span><br><span class="line">		boolean b1 &#x3D; true;</span><br><span class="line">		boolean b2 &#x3D; false;</span><br><span class="line">		System.out.println(b2 &#x3D;&#x3D; b1);&#x2F;&#x2F;false</span><br><span class="line">		System.out.println(b2 &#x3D; b1);&#x2F;&#x2F;true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="四、逻辑运算符"><a href="#四、逻辑运算符" class="headerlink" title="四、逻辑运算符"></a>四、逻辑运算符</h2><p><img src="http://wangzixuan.work/2811" alt=""></p>
<ul>
<li><p>逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。</p>
</li>
<li><p>“&amp;”和“&amp;&amp;”的区别：</p>
<ul>
<li>单&amp;时，左边无论真假，右边都进行运算；</li>
<li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</li>
</ul>
</li>
<li><p>“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</p>
</li>
<li><p>异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。</p>
<ul>
<li>理解：异或，追求的是“异”!</li>
</ul>
</li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之四：逻辑运算符</span><br><span class="line"></span><br><span class="line">&amp;  &amp;&amp; |  || ! ^</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">1.逻辑运算符操作的都是boolean类型的变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">class LogicTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;区分&amp; 与 &amp;&amp;</span><br><span class="line">		&#x2F;&#x2F;相同点1：&amp; 与  &amp;&amp; 的运算结果相同</span><br><span class="line">		&#x2F;&#x2F;相同点2：当符号左边是true时，二者都会执行符号右边的运算</span><br><span class="line">		&#x2F;&#x2F;不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</span><br><span class="line">		&#x2F;&#x2F;开发中，推荐使用&amp;&amp;</span><br><span class="line">		boolean b1 &#x3D; true;</span><br><span class="line">		b1 &#x3D; false;</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		if(b1 &amp; (num1++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;num1 &#x3D; &quot; + num1);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		boolean b2 &#x3D; true;</span><br><span class="line">		b2 &#x3D; false;</span><br><span class="line">		int num2 &#x3D; 10;</span><br><span class="line">		if(b2 &amp;&amp; (num2++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;num2 &#x3D; &quot; + num2);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 区分：| 与 || </span><br><span class="line">		&#x2F;&#x2F;相同点1：| 与  || 的运算结果相同</span><br><span class="line">		&#x2F;&#x2F;相同点2：当符号左边是false时，二者都会执行符号右边的运算</span><br><span class="line">		&#x2F;&#x2F;不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</span><br><span class="line">		&#x2F;&#x2F;开发中，推荐使用||</span><br><span class="line">		boolean b3 &#x3D; false;</span><br><span class="line">		b3 &#x3D; true;</span><br><span class="line">		int num3 &#x3D; 10;</span><br><span class="line">		if(b3 | (num3++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;num3 &#x3D; &quot; + num3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		boolean b4 &#x3D; false;</span><br><span class="line">		b4 &#x3D; true;</span><br><span class="line">		int num4 &#x3D; 10;</span><br><span class="line">		if(b4 || (num4++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;num4 &#x3D; &quot; + num4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="五、位运算符"><a href="#五、位运算符" class="headerlink" title="五、位运算符"></a>五、位运算符</h2><p><img src="http://wangzixuan.work/2813" alt=""><br><img src="http://wangzixuan.work/2817" alt=""></p>
<ul>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之五：位运算符 （了解）</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">1. 位运算符操作的都是整型的数据</span><br><span class="line">2. &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2</span><br><span class="line">   &gt;&gt; :在一定范围内，每向右移1位，相当于 &#x2F; 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">面试题：最高效方式的计算2 * 8 ？  2 &lt;&lt; 3  或 8 &lt;&lt; 1</span><br><span class="line">*&#x2F;</span><br><span class="line">class BitTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 21;</span><br><span class="line">		i &#x3D; -21;</span><br><span class="line">		System.out.println(&quot;i &lt;&lt; 2 :&quot; + (i &lt;&lt; 2));</span><br><span class="line">		System.out.println(&quot;i &lt;&lt; 3 :&quot; + (i &lt;&lt; 3));</span><br><span class="line">		System.out.println(&quot;i &lt;&lt; 27 :&quot; + (i &lt;&lt; 27));</span><br><span class="line"></span><br><span class="line">		int m &#x3D; 12;</span><br><span class="line">		int n &#x3D; 5;</span><br><span class="line">		System.out.println(&quot;m &amp; n :&quot; + (m &amp; n));</span><br><span class="line">		System.out.println(&quot;m | n :&quot; + (m | n));</span><br><span class="line">		System.out.println(&quot;m ^ n :&quot; + (m ^ n));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;练习：交换两个变量的值</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		int num2 &#x3D; 20;</span><br><span class="line">		System.out.println(&quot;num1 &#x3D; &quot; + num1 + &quot;,num2 &#x3D; &quot; + num2);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方式一：定义临时变量的方式</span><br><span class="line">		&#x2F;&#x2F;推荐的方式</span><br><span class="line">		int temp &#x3D; num1;</span><br><span class="line">		num1 &#x3D; num2;</span><br><span class="line">		num2 &#x3D; temp;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方式二：好处：不用定义临时变量  </span><br><span class="line">		&#x2F;&#x2F;弊端：① 相加操作可能超出存储范围 ② 有局限性：只能适用于数值类型</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 + num2;</span><br><span class="line">		&#x2F;&#x2F;num2 &#x3D; num1 - num2;</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 - num2;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方式三：使用位运算符</span><br><span class="line">		&#x2F;&#x2F;有局限性：只能适用于数值类型</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 ^ num2;</span><br><span class="line">		&#x2F;&#x2F;num2 &#x3D; num1 ^ num2;</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 ^ num2;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;num1 &#x3D; &quot; + num1 + &quot;,num2 &#x3D; &quot; + num2);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图解<br><img src="http://wangzixuan.work/2815" alt=""><br><img src="http://wangzixuan.work/2848" alt=""><br><img src="http://wangzixuan.work/2850" alt=""><br><img src="http://wangzixuan.work/2852" alt=""><br><img src="http://wangzixuan.work/2854" alt=""><br><img src="http://wangzixuan.work/2856" alt=""></p>
</li>
</ul>
<h2 id="六、三元运算符"><a href="#六、三元运算符" class="headerlink" title="六、三元运算符"></a>六、三元运算符</h2><ul>
<li><p>格式:</p>
<ul>
<li>(条件表达式)? 表达式1 ：表达式2；<ul>
<li>条件表达式为true ，运算后的结果是表达式1；</li>
<li>条件表达式为false ，运算后的结果是表达式2；</li>
</ul>
</li>
<li>表达式1和表达式2为同种类型</li>
<li>三元运算符与if-else的联系与区别：<ol>
<li>三元运算符可简化if-else语句</li>
<li>三元运算符要求必须返回一个结果。</li>
<li>if后的代码块可有多个语句</li>
</ol>
</li>
</ul>
</li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之六：三元运算符</span><br><span class="line">1.结构：(条件表达式)? 表达式1 : 表达式2</span><br><span class="line">2. 说明</span><br><span class="line">① 条件表达式的结果为boolean类型</span><br><span class="line">② 根据条件表达式真或假，决定执行表达式1，还是表达式2.</span><br><span class="line">  如果表达式为true，则执行表达式1。</span><br><span class="line">  如果表达式为false，则执行表达式2。</span><br><span class="line">③ 表达式1 和表达式2要求是一致的。</span><br><span class="line">④ 三元运算符可以嵌套使用</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">凡是可以使用三元运算符的地方，都可以改写为if-else</span><br><span class="line">反之，不成立。</span><br><span class="line"></span><br><span class="line">4. 如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。</span><br><span class="line">*&#x2F;</span><br><span class="line">class SanYuanTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;获取两个整数的较大值</span><br><span class="line">		int m &#x3D; 12;</span><br><span class="line">		int n &#x3D; 5;</span><br><span class="line"></span><br><span class="line">		int max &#x3D; (m &gt; n)? m : n;</span><br><span class="line">		System.out.println(max);</span><br><span class="line"></span><br><span class="line">		double num &#x3D; (m &gt; n)? 2 : 1.0;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;(m &gt; n)? 2 : &quot;n大&quot;;&#x2F;&#x2F;编译错误</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;**************************</span><br><span class="line">		n &#x3D; 12;</span><br><span class="line">		String maxStr &#x3D; (m &gt; n)? &quot;m大&quot; : ((m &#x3D;&#x3D; n)? &quot;m和n相等&quot; : &quot;n大&quot;);</span><br><span class="line">		System.out.println(maxStr);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;*****************************</span><br><span class="line">		&#x2F;&#x2F;获取三个数的最大值</span><br><span class="line">		int n1 &#x3D; 12;</span><br><span class="line">		int n2 &#x3D; 30;</span><br><span class="line">		int n3 &#x3D; -43;</span><br><span class="line">		</span><br><span class="line">		int max1 &#x3D; (n1 &gt; n2)? n1 : n2;</span><br><span class="line">		int max2 &#x3D; (max1 &gt; n3)? max1 : n3;</span><br><span class="line">		System.out.println(&quot;三个数中的最大值为：&quot; + max2);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;不建议</span><br><span class="line">		&#x2F;&#x2F;int max3 &#x3D; (((n1 &gt; n2)? n1 : n2) &gt; n3)? ((n1 &gt; n2)? n1 : n2) : n3;</span><br><span class="line">		System.out.println(&quot;三个数中的最大值为：&quot; + max3);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;该写成if-else:</span><br><span class="line">		if(m &gt; n)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、运算符的优先级"><a href="#七、运算符的优先级" class="headerlink" title="七、运算符的优先级"></a>七、运算符的优先级</h2></li>
<li><p>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。</p>
</li>
<li><p>只有单目运算符、三元运算符、赋值运算符是从右向左运算的。<br><img src="http://wangzixuan.work/2872" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>运算符</tag>
        <tag>算数运算符</tag>
        <tag>赋值运算符</tag>
        <tag>比较运算符</tag>
        <tag>关系运算符</tag>
        <tag>逻辑运算符</tag>
        <tag>位运算符</tag>
        <tag>三目运算符</tag>
        <tag>三元运算符</tag>
        <tag>运算符的优先级</tag>
      </tags>
  </entry>
  <entry>
    <title>08.Java基础知识-程序流程控制</title>
    <url>/2020/07/10/08-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h2><ul>
<li><p>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。</p>
</li>
<li><p>其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：</p>
<ul>
<li>顺序结构</li>
<li>分支结构</li>
<li>循环结构<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4></li>
</ul>
</li>
<li><p>程序从上到下逐行地执行，中间没有任何判断和跳转。<br><img src="http://wangzixuan.work/3002" alt=""></p>
</li>
<li><p>Java中定义成员变量时采用合法的前向引用。如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正确形式：</span><br><span class="line">public class Test&#123;</span><br><span class="line">    int num1 &#x3D; 12;</span><br><span class="line">    int num2 &#x3D; num1 + 2;</span><br><span class="line">&#125;</span><br><span class="line">错误形式：</span><br><span class="line">public class Test&#123;</span><br><span class="line">    int num2 &#x3D; num1 + 2；</span><br><span class="line">    int num1 &#x3D; 12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>根据条件，选择性地执行某段代码。</p>
<ul>
<li><h5 id="if…else语句。"><a href="#if…else语句。" class="headerlink" title="if…else语句。"></a>if…else语句。</h5><ul>
<li>条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量</li>
<li>语句块只有一条执行语句时，一对{}可以省略，但建议保留</li>
<li>if-else语句结构，根据需要可以嵌套使用</li>
<li>当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略</li>
<li>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓</li>
<li>当多个条件是“包含”关系时，“小上大下 / 子上父下”</li>
<li>三种格式：</li>
</ul>
<p>  1.<br>  <img src="http://wangzixuan.work/3004" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if( 条件表达式)&#123;</span><br><span class="line">    执行代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  2.<br>  <img src="http://wangzixuan.work/3006" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if( 条件表达式)&#123;</span><br><span class="line">    执行代码块1;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    执行代码块2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  3.<br>  <img src="http://wangzixuan.work/3008" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if( 条件表达式1)&#123;</span><br><span class="line">    执行 代码块1;</span><br><span class="line">&#125;</span><br><span class="line">else if ( 条件表达式2)&#123;</span><br><span class="line">    执行 代码块2;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">else&#123;</span><br><span class="line">    执行 代码块n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>彩票游戏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">假设你想开发一个玩彩票的游戏，程序随机地产生一个两位数的彩票，提示用户输入一个两位数，然后按照下面的规则判定用户是否能赢。</span><br><span class="line">1)如果用户输入的数匹配彩票的实际顺序，奖金10 000美元。</span><br><span class="line">2)如果用户输入的所有数字匹配彩票的所有数字，但顺序不一致，奖金 3 000美元。</span><br><span class="line">3)如果用户输入的一个数字仅满足顺序情况下匹配彩票的一个数字，奖金1 000美元。</span><br><span class="line">4)如果用户输入的一个数字仅满足非顺序情况下匹配彩票的一个数字，奖金500美元。</span><br><span class="line">5)如果用户输入的数字没有匹配任何一个数字，则彩票作废。</span><br><span class="line">提示：使用Math.random()产生随机数Math.random() 产生[0,1)范围的随机值Math.random() * 90：[0,90) </span><br><span class="line">Math.random() * 90 + 10：[10,100) 即得到  [10,99]</span><br><span class="line"></span><br><span class="line">使用(int)(Math.random() * 90  + 10)产生一个两位数的随机数。</span><br><span class="line">*&#x2F;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class TestCaiPiao&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		&#x2F;&#x2F;1、随机产生一个两位数</span><br><span class="line">		&#x2F;&#x2F;System.out.println(Math.random());&#x2F;&#x2F;产生[0,1)</span><br><span class="line">		int number &#x3D; (int)(Math.random()*90 + 10);&#x2F;&#x2F;得到[10,99]，即[10,100)</span><br><span class="line">		&#x2F;&#x2F;System.out.println(number);</span><br><span class="line">		</span><br><span class="line">		int numberShi &#x3D; number&#x2F;10;</span><br><span class="line">		int numberGe &#x3D; number%10;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2、用户输入一个两位数</span><br><span class="line">		Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">		System.out.print(&quot;请输入一个两位数：&quot;);</span><br><span class="line">		int guess &#x3D; input.nextInt();</span><br><span class="line">		</span><br><span class="line">		int guessShi &#x3D; guess&#x2F;10;</span><br><span class="line">		int guessGe &#x3D; guess%10;</span><br><span class="line">		</span><br><span class="line">		if(number &#x3D;&#x3D; guess)&#123;</span><br><span class="line">			System.out.println(&quot;奖金10 000美元&quot;);</span><br><span class="line">		&#125;else if(numberShi &#x3D;&#x3D; guessGe &amp;&amp; numberGe &#x3D;&#x3D; guessShi)&#123;</span><br><span class="line">			System.out.println(&quot;奖金3 000美元&quot;);</span><br><span class="line">		&#125;else if(numberShi&#x3D;&#x3D;guessShi || numberGe &#x3D;&#x3D; guessGe)&#123;</span><br><span class="line">			System.out.println(&quot;奖金1 000美元&quot;);</span><br><span class="line">		&#125;else if(numberShi&#x3D;&#x3D;guessGe || numberGe &#x3D;&#x3D; guessShi)&#123;</span><br><span class="line">			System.out.println(&quot;奖金500美元&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;没中奖&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;中奖号码是：&quot; + number);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><h5 id="switch-case语句。"><a href="#switch-case语句。" class="headerlink" title="switch-case语句。"></a>switch-case语句。</h5><ul>
<li><p>switch(表达式)中表达式的值必须是下述几种类型之一：byte ，short，char ，int，枚举 (jdk 5.0) ，String (jdk 7.0)；</p>
</li>
<li><p>case子句中的值必须是常量，不能是变量名或不确定的表达式值；</p>
</li>
<li><p>同一个switch语句，所有case子句中的常量值互不相同；</p>
</li>
<li><p>break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有break，程序会顺序执行到switch结尾</p>
</li>
<li><p>default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，执行default</p>
</li>
<li><p>格式:<br>  <img src="http://wangzixuan.work/3010" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch( 表达式)&#123;</span><br><span class="line">    case 常量1:</span><br><span class="line">    语句1;</span><br><span class="line">    &#x2F;&#x2F; break;</span><br><span class="line">    case 常量2:</span><br><span class="line">    语句2;</span><br><span class="line">    &#x2F;&#x2F; break;</span><br><span class="line">    … …</span><br><span class="line">    case 常量N:</span><br><span class="line">    语句N;</span><br><span class="line">    &#x2F;&#x2F; break;</span><br><span class="line">    default:</span><br><span class="line">    语句;</span><br><span class="line">    &#x2F;&#x2F; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求输入的日期是当年的第几天</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class TestDaysOfYear&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;年：&quot;);</span><br><span class="line">		int year &#x3D; input.nextInt();</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;月：&quot;);</span><br><span class="line">		int month &#x3D; input.nextInt();</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;日：&quot;);</span><br><span class="line">		int day &#x3D; input.nextInt();</span><br><span class="line">		</span><br><span class="line">		int days &#x3D; day;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;加前面几个月的满月天数</span><br><span class="line">		switch(month)&#123;</span><br><span class="line">			case 12:</span><br><span class="line">				&#x2F;&#x2F;前面11个月的总天数</span><br><span class="line">				&#x2F;&#x2F;days +&#x3D; 第11月的天数;</span><br><span class="line">				days +&#x3D; 30;</span><br><span class="line">			case 11:</span><br><span class="line">				&#x2F;&#x2F;前面10个月的总天数</span><br><span class="line">				&#x2F;&#x2F;days +&#x3D; 第10月的天数;</span><br><span class="line">				days +&#x3D; 31;</span><br><span class="line">			case 10:</span><br><span class="line">				days +&#x3D; 30;&#x2F;&#x2F;九月</span><br><span class="line">			case 9:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;八月</span><br><span class="line">			case 8:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;七月</span><br><span class="line">			case 7:</span><br><span class="line">				days +&#x3D; 30;&#x2F;&#x2F;六月</span><br><span class="line">			case 6:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;五月</span><br><span class="line">			case 5:</span><br><span class="line">				days +&#x3D; 30;&#x2F;&#x2F;四月</span><br><span class="line">			case 4:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;三月</span><br><span class="line">			case 3:</span><br><span class="line">				days +&#x3D; 28;&#x2F;&#x2F;二月</span><br><span class="line">				&#x2F;*if(闰年)&#123;</span><br><span class="line">					days++;</span><br><span class="line">				&#125;</span><br><span class="line">				*&#x2F;</span><br><span class="line">				if(year % 4 &#x3D;&#x3D;0 &amp;&amp; year % 100 !&#x3D; 0 || year%400&#x3D;&#x3D;0)&#123;</span><br><span class="line">					days++;</span><br><span class="line">				&#125;</span><br><span class="line">			case 2:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;一月</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日是这一年的第&quot; + days + &quot;天&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="switch-和if语句的对比"><a href="#switch-和if语句的对比" class="headerlink" title="switch 和if语句的对比"></a>switch 和if语句的对比</h5><p>if和switch语句很像，具体什么场景下，应用哪个语句呢？</p>
</li>
<li><p>如果判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几种类型。虽然两个语句都可以使用，建议使用swtich语句。因为效率稍高。</p>
</li>
<li><p>其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。也就是说，使用switch-case的，都可以改写为if-else。反之不成立。</p>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4></li>
<li><p>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。</p>
</li>
<li><h5 id="循环结构-1"><a href="#循环结构-1" class="headerlink" title="循环结构"></a>循环结构</h5><ul>
<li>根据循环条件，重复性的执行某段代码。</li>
</ul>
</li>
<li><h5 id="循环语句分类"><a href="#循环语句分类" class="headerlink" title="循环语句分类"></a>循环语句分类</h5><ul>
<li>while</li>
<li>do…while</li>
<li>for</li>
</ul>
</li>
<li><h5 id="循环语句的四个组成部分"><a href="#循环语句的四个组成部分" class="headerlink" title="循环语句的四个组成部分"></a>循环语句的四个组成部分</h5><ul>
<li>初始化部分(init_statement)</li>
<li>循环条件部分(test_exp)</li>
<li>循环体部分(body_statement)</li>
<li>迭代部分(alter_statement)<br><img src="http://wangzixuan.work/3108" alt=""></li>
</ul>
</li>
<li><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><ul>
<li><p>语法格式</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (①初始化部分;②循环条件部分;④迭代部分)｛</span><br><span class="line">    ③ 循环体部分;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></li>
<li><p>执行过程：</p>
<p>  <img src="http://wangzixuan.work/3110" alt=""></p>
</li>
<li><p>说明：</p>
<ul>
<li>②循环条件部分为boolean类型表达式，当值为false时，退出循环</li>
<li>①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</li>
<li>④可以有多个变量更新，用逗号分隔</li>
</ul>
</li>
<li><p>for循环执行演示：<br>  <img src="http://wangzixuan.work/3112" alt=""></p>
</li>
<li><p>输入两个正整数m和n，求其最大公约数和最小公倍数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int m &#x3D; 12, n &#x3D; 28;</span><br><span class="line">&#x2F;&#x2F;获取m和n的较大值</span><br><span class="line">int max &#x3D; (m &gt; n)? m : n;</span><br><span class="line">&#x2F;&#x2F;获取m和n的较小值</span><br><span class="line">int min &#x3D; (m &lt; n)? m : n;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;求m和n的最大公约数</span><br><span class="line">for(int i &#x3D; min;i &gt;&#x3D; 1;i--)&#123;</span><br><span class="line">    if( m % i &#x3D;&#x3D; 0 &amp;&amp; n % i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        System.out.println(&quot;m和n的最大公约数是：&quot; + i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;求m和n的最小公倍数</span><br><span class="line">for(int i &#x3D; max;i &lt;&#x3D; m * n;i++)&#123;</span><br><span class="line">    if( i % m &#x3D;&#x3D; 0 &amp;&amp; i % n &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        System.out.println(&quot;m和n的最小公倍数是：&quot; + i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><ul>
<li><p>语法格式</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">① 初始化部分</span><br><span class="line">while(②循环条件部分)｛</span><br><span class="line">    ③循环体部分;</span><br><span class="line">    ④迭代部分;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行过程：</p>
<p>  <img src="http://wangzixuan.work/3114" alt=""></p>
</li>
<li><p>说明：</p>
<ul>
<li>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</li>
<li>for循环和while循环可以相互转换<br>区别：for循环和while循环的初始化条件部分的作用范围不同。</li>
</ul>
</li>
<li><p>遍历100以内的所有偶数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;遍历100以内的所有偶数</span><br><span class="line">	int i &#x3D; 1;</span><br><span class="line">	while(i &lt;&#x3D; 100)&#123;</span><br><span class="line">		</span><br><span class="line">		if(i % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;出了while循环以后，i仍可以调用。</span><br><span class="line">	System.out.println(i);&#x2F;&#x2F;101</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h5><ul>
<li><p>语法格式</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①初始化部分;</span><br><span class="line">do&#123;</span><br><span class="line">    ③ 循环体部分</span><br><span class="line">    ④ 迭代部分</span><br><span class="line">&#125;while(②循环条件部分);</span><br></pre></td></tr></table></figure></li>
<li><p>执行过程：</p>
<p>  <img src="http://wangzixuan.work/3116" alt=""></p>
</li>
<li><p>说明：</p>
<ul>
<li>do-while 循环至少执行一次循环体 。</li>
<li>开发中，使用for和while更多一些。较少使用do-while</li>
</ul>
</li>
<li><p>遍历100以内的偶数,并计算所有偶数的和及偶数的个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;遍历100以内的偶数,并计算所有偶数的和及偶数的个数</span><br><span class="line">	int num &#x3D; 1;</span><br><span class="line">	int sum &#x3D; 0;&#x2F;&#x2F;记录总和</span><br><span class="line">	int count &#x3D; 0;&#x2F;&#x2F;记录个数</span><br><span class="line">	do&#123;</span><br><span class="line">		</span><br><span class="line">		if(num % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			System.out.println(num);</span><br><span class="line">			sum +&#x3D; num;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	&#125;while(num &lt;&#x3D; 100);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;总和为：&quot; + sum);</span><br><span class="line">	System.out.println(&quot;个数为：&quot; + count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="“无限”循环："><a href="#“无限”循环：" class="headerlink" title="“无限”循环："></a>“无限”循环：</h5><ul>
<li><p>最简单“无限”循环：格式： while(true)、for(;;)  无限循环存在的原因是并不知道循环多少次，需要根据循环体内部某些条件，来控制循环的结束。</p>
</li>
<li><p>结束循环有几种方式？</p>
<ol>
<li>方式一：循环条件部分返回false</li>
<li>方式二：在循环体中，执行break</li>
</ol>
</li>
<li><p>题目：<br>从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。</p>
</li>
<li><p>说明：</p>
<ol>
<li>不在循环条件部分限制次数的结构：for(;;) 或 while(true)</li>
</ol>
</li>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">	</span><br><span class="line">	int positiveNumber &#x3D; 0;&#x2F;&#x2F;记录正数的个数</span><br><span class="line">	int negativeNumber &#x3D; 0;&#x2F;&#x2F;记录负数的个数</span><br><span class="line"></span><br><span class="line">	for(;;)&#123;&#x2F;&#x2F;while(true)&#123;</span><br><span class="line">		</span><br><span class="line">		int number &#x3D; scan.nextInt();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;判断number的正负情况</span><br><span class="line">		if(number &gt; 0)&#123;</span><br><span class="line">			positiveNumber++;</span><br><span class="line">		&#125;else if(number &lt; 0)&#123;</span><br><span class="line">			negativeNumber++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;一旦执行break，跳出循环</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(&quot;输入的正数个数为：&quot; + positiveNumber);</span><br><span class="line">	System.out.println(&quot;输入的负数个数为：&quot; + negativeNumber);</span><br><span class="line">	</span><br><span class="line">	while(true)&#123;</span><br><span class="line">		</span><br><span class="line">		int number &#x3D; scan.nextInt();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;判断number的正负情况</span><br><span class="line">		if(number &gt; 0)&#123;</span><br><span class="line">			positiveNumber++;</span><br><span class="line">		&#125;else if(number &lt; 0)&#123;</span><br><span class="line">			negativeNumber++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;一旦执行break，跳出循环</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;输入的正数个数为：&quot; + positiveNumber);</span><br><span class="line">	System.out.println(&quot;输入的负数个数为：&quot; + negativeNumber);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4></li>
</ul>
</li>
<li><p>将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do…while均可以作为外层循环或内层循环。</p>
</li>
<li><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。</p>
</li>
<li><p>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次。</p>
</li>
<li><p>九九乘法表</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; 9;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		for(int j &#x3D; 1;j &lt;&#x3D; i;j++)&#123;</span><br><span class="line">			System.out.print(i + &quot; * &quot; + j + &quot; &#x3D; &quot; + (i * j) + &quot;  &quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="特殊关键字的使用：break、continue"><a href="#特殊关键字的使用：break、continue" class="headerlink" title="特殊关键字的使用：break、continue"></a>特殊关键字的使用：break、continue</h4><table>
<thead>
<tr>
<th>关键字</th>
<th>使用范围</th>
<th>循环中使用的作用(不同点)</th>
<th>相同点</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>switch-case与循环结构中</td>
<td>结束当前循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
<tr>
<td>continue</td>
<td>循环结构中</td>
<td>结束当次循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
</tbody></table>
<ul>
<li><h5 id="break"><a href="#break" class="headerlink" title="break"></a>break</h5></li>
<li><p>break语句用于终止某个语句块的执行</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    break;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是<br>哪一层语句块</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label1: &#123; </span><br><span class="line">    ……</span><br><span class="line">    label2: &#123; </span><br><span class="line">        ……</span><br><span class="line">        label3: &#123; </span><br><span class="line">            ……</span><br><span class="line">            break label2;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h5></li>
<li><p>continue 语句</p>
<ul>
<li>continue只能使用在循环结构中</li>
<li>continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环</li>
<li>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</li>
</ul>
</li>
<li><p>continue 语句用法举例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">        if (i%10&#x3D;&#x3D;0)</span><br><span class="line">        continue;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="return-特殊的流程控制语句"><a href="#return-特殊的流程控制语句" class="headerlink" title="return 特殊的流程控制语句"></a>return 特殊的流程控制语句</h5></li>
<li><p>return：并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个return语句时，这个方法将被结束。</p>
</li>
<li><p>与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内</p>
</li>
<li><h5 id="特殊流程控制语句说明"><a href="#特殊流程控制语句说明" class="headerlink" title="特殊流程控制语句说明"></a>特殊流程控制语句说明</h5><ul>
<li>break只能用于switch语句和循环语句中。</li>
<li>continue只能用于循环语句中。</li>
<li>二者功能类似，但continue是终止本次循环，break是终止本层循环。</li>
<li>break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。</li>
<li>标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。</li>
<li>很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同于goto的。</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; 10;i++)&#123;</span><br><span class="line">	</span><br><span class="line">		if(i % 4 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			break;&#x2F;&#x2F;123</span><br><span class="line">			&#x2F;&#x2F;continue;&#x2F;&#x2F;123567910</span><br><span class="line">			&#x2F;&#x2F;System.out.println(&quot;今晚迪丽热巴要约我！！！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;\n&quot;);</span><br><span class="line">	&#x2F;&#x2F;******************************</span><br><span class="line">	</span><br><span class="line">	label:for(int i &#x3D; 1;i &lt;&#x3D; 4;i++)&#123;</span><br><span class="line">	</span><br><span class="line">		for(int j &#x3D; 1;j &lt;&#x3D; 10;j++)&#123;</span><br><span class="line">			</span><br><span class="line">			if(j % 4 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">				&#x2F;&#x2F;break;&#x2F;&#x2F;默认跳出包裹此关键字最近的一层循环。</span><br><span class="line">				&#x2F;&#x2F;continue;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;break label;&#x2F;&#x2F;结束指定标识的一层循环结构</span><br><span class="line">				continue label;&#x2F;&#x2F;结束指定标识的一层循环结构当次循环</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.print(j);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>程序流程控制</tag>
        <tag>顺序结构</tag>
        <tag>分支结构</tag>
        <tag>循环结构</tag>
        <tag>if…else</tag>
        <tag>彩票游戏</tag>
        <tag>switch-case</tag>
        <tag>switch 和if语句的对比</tag>
        <tag>while</tag>
        <tag>do…while</tag>
        <tag>for</tag>
        <tag>“无限”循环</tag>
        <tag>嵌套循环</tag>
        <tag>break</tag>
        <tag>continue</tag>
        <tag>return</tag>
      </tags>
  </entry>
  <entry>
    <title>09.Java基础知识-质数与优化</title>
    <url>/2020/07/10/09-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%B4%A8%E6%95%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="输出100以内的所有的质数"><a href="#输出100以内的所有的质数" class="headerlink" title="输出100以内的所有的质数"></a>输出100以内的所有的质数</h2><p>质数（素数）：只能被1和它本身整除的自然数。从2开始，到这个数减1结束为止，都不能被这个数本身整除。</p>
<h4 id="一、简单实现"><a href="#一、简单实现" class="headerlink" title="一、简单实现"></a>一、简单实现</h4><ol>
<li><p>注意boolean isFlag = true;</p>
</li>
<li><p>不要放在外层循环里边 每次声明 浪费内存</p>
</li>
<li><p>声明一次，每次外层循环重置isFlag</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	boolean isFlag &#x3D; true;&#x2F;&#x2F;标识i是否被j除尽，一旦除尽，修改其值</span><br><span class="line"></span><br><span class="line">	for(int i &#x3D; 2;i &lt;&#x3D; 100;i++)&#123;&#x2F;&#x2F;遍历100以内的自然数</span><br><span class="line">	</span><br><span class="line">		&#x2F;&#x2F;boolean isFlag &#x3D; true;放在这每次声明 浪费内存</span><br><span class="line">	</span><br><span class="line">		for(int j &#x3D; 2;j &lt; i;j++)&#123;&#x2F;&#x2F;j:被i去除</span><br><span class="line">			</span><br><span class="line">			if(i % j &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;i被j除尽</span><br><span class="line">				isFlag &#x3D; false;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		if(isFlag &#x3D;&#x3D; true)&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;重置isFlag</span><br><span class="line">		isFlag &#x3D; true;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="100000以内的所有的质数个数"><a href="#100000以内的所有的质数个数" class="headerlink" title="100000以内的所有的质数个数"></a>100000以内的所有的质数个数</h2><h4 id="二、第一次优化"><a href="#二、第一次优化" class="headerlink" title="二、第一次优化"></a>二、第一次优化</h4></li>
<li><p>i替换为根号i（Math.sqrt(i)）</p>
<p> 对本身是质数的自然数是有效的。</p>
<p> 因为 i = 根号i * 根号i（Math.sqrt(i) * Math.sqrt(i)）；</p>
</li>
<li><p>第一次确定不是质数break跳出，只对本身非质数的自然数是有效的。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	boolean isFlag &#x3D; true;&#x2F;&#x2F;标识i是否被j除尽，一旦除尽，修改其值</span><br><span class="line">	int count &#x3D; 0;&#x2F;&#x2F;记录质数的个数</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取当前时间距离1970-01-01 00:00:00 的毫秒数</span><br><span class="line">	long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	for(int i &#x3D; 2;i &lt;&#x3D; 100000;i++)&#123;&#x2F;&#x2F;遍历100000以内的自然数</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;优化1：i替换为根号i（Math.sqrt(i)），对本身是质数的自然数是有效的。因为 i &#x3D; 根号i * 根号i（Math.sqrt(i) * Math.sqrt(i)）；</span><br><span class="line">		&#x2F;&#x2F;for(int j &#x3D; 2;j &lt; i;j++)&#123;</span><br><span class="line">		for(int j &#x3D; 2;j &lt;&#x3D; Math.sqrt(i);j++)&#123;&#x2F;&#x2F;j:被i去除</span><br><span class="line">			</span><br><span class="line">			if(i % j &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;i被j除尽</span><br><span class="line">				isFlag &#x3D; false;</span><br><span class="line">				break;&#x2F;&#x2F;优化2：第一次确定不是质数break跳出，只对本身非质数的自然数是有效的。</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		if(isFlag &#x3D;&#x3D; true)&#123;</span><br><span class="line">			&#x2F;&#x2F;System.out.println(i);</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;重置isFlag</span><br><span class="line">		isFlag &#x3D; true;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取当前时间距离1970-01-01 00:00:00 的毫秒数</span><br><span class="line">	long end &#x3D; System.currentTimeMillis();</span><br><span class="line">	System.out.println(&quot;质数的个数为：&quot; + count);</span><br><span class="line">	System.out.println(&quot;所花费的时间为：&quot; + (end - start));&#x2F;&#x2F;17110 - 优化一：break:1546 - 优化二：13</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="三、第二次优化"><a href="#三、第二次优化" class="headerlink" title="三、第二次优化"></a>三、第二次优化</h4><ol>
<li><p>省去标识i是否被j除尽boolean isFlag = true;</p>
</li>
<li><p>利用continue label;实现执行到count++;的都是质数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int count &#x3D; 0;&#x2F;&#x2F;记录质数的个数</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取当前时间距离1970-01-01 00:00:00 的毫秒数</span><br><span class="line">	long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	label:for(int i &#x3D; 2;i &lt;&#x3D; 100000;i++)&#123;&#x2F;&#x2F;遍历100000以内的自然数</span><br><span class="line">		</span><br><span class="line">		for(int j &#x3D; 2;j &lt;&#x3D; Math.sqrt(i);j++)&#123;&#x2F;&#x2F;j:被i去除</span><br><span class="line">			</span><br><span class="line">			if(i % j &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;i被j除尽</span><br><span class="line">				continue label;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;能执行到此步骤的，都是质数</span><br><span class="line">		count++;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取当前时间距离1970-01-01 00:00:00 的毫秒数</span><br><span class="line">	long end &#x3D; System.currentTimeMillis();</span><br><span class="line">	System.out.println(&quot;质数的个数为：&quot; + count);</span><br><span class="line">	System.out.println(&quot;所花费的时间为：&quot; + (end - start));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>质数</tag>
        <tag>100以内质数</tag>
        <tag>求质数运算优化</tag>
      </tags>
  </entry>
  <entry>
    <title>10.Java基础知识-数组</title>
    <url>/2020/07/11/10-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="一、数组的概述"><a href="#一、数组的概述" class="headerlink" title="一、数组的概述"></a>一、数组的概述</h4><ol>
<li><p>数组的理解：数组(Array)，是多个相同类型数据按一定顺序排列<br>的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p>
</li>
<li><p>数组的常见概念</p>
<ul>
<li>数组名</li>
<li>下标(或索引)</li>
<li>元素</li>
<li>数组的长度</li>
</ul>
</li>
<li><p>数组的特点：</p>
<ul>
<li>数组是有序排列的</li>
<li>数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型</li>
<li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。</li>
<li>数组的长度一旦确定，就不能修改。</li>
<li>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。</li>
</ul>
</li>
<li><p>数组的分类：</p>
<ul>
<li>按照维度：一维数组、二维数组、三维数组、…</li>
<li>按照元素的数据类型：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)<h4 id="二、一维数组的使用"><a href="#二、一维数组的使用" class="headerlink" title="二、一维数组的使用"></a>二、一维数组的使用</h4></li>
</ul>
</li>
<li><p>一维数组的声明</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type var[]</span><br><span class="line">type[] var；</span><br></pre></td></tr></table></figure>
<p> 例如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a1[];</span><br><span class="line">int[] a;</span><br><span class="line">double[] b;</span><br><span class="line">String[] c; &#x2F;&#x2F;引用类型变量数组</span><br></pre></td></tr></table></figure>
<p> Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： int a[5]; //非法</p>
</li>
<li><p>一维数组的声明和初始化</p>
<ul>
<li><p>动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基本数据类型</span><br><span class="line">int[] arr &#x3D; new int[3];&#x2F;&#x2F;声明和初始化</span><br><span class="line">arr[0] &#x3D; 3;&#x2F;&#x2F;赋值</span><br><span class="line">arr[1] &#x3D; 9;&#x2F;&#x2F;赋值</span><br><span class="line">arr[2] &#x3D; 8;&#x2F;&#x2F;赋值</span><br><span class="line">&#x2F;&#x2F;引用数据类型</span><br><span class="line">String names[];&#x2F;&#x2F;声明</span><br><span class="line">names &#x3D; new String[3];&#x2F;&#x2F;初始化</span><br><span class="line">names[0] &#x3D; “钱学森”;&#x2F;&#x2F;赋值</span><br><span class="line">names[1] &#x3D; “邓稼先”;&#x2F;&#x2F;赋值</span><br><span class="line">names[2] &#x3D; “袁隆平”;&#x2F;&#x2F;赋值</span><br></pre></td></tr></table></figure></li>
<li><p>静态初始化：在定义数组的同时就为数组元素分配空间并赋值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基本数据类型</span><br><span class="line">int arr[] &#x3D; new int[]&#123; 3, 9, 8&#125;;&#x2F;&#x2F;1.声明和初始化并赋值</span><br><span class="line">int[] arr &#x3D; &#123;3,9,8&#125;;&#x2F;&#x2F;2.声明和初始化并赋值</span><br><span class="line">&#x2F;&#x2F;引用数据类型</span><br><span class="line">String names[] &#x3D; &#123;“李四光”,“茅以升”,“华罗庚”&#125;&#x2F;&#x2F;声明和初始化并赋值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一维数组的使用：数组元素的引用</p>
<ul>
<li>定义并用运算符new为之分配空间后，才可以引用数组中的每个元素；</li>
<li>数组元素的引用方式：数组名[数组元素下标]<ul>
<li>数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];</li>
<li>数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —&gt;n-1；如int a[]=new<br>int[3]; 可引用的数组元素为a[0]、a[1]、a[2]</li>
</ul>
</li>
<li>每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数)<ul>
<li>数组一旦初始化，其长度是不可变的</li>
</ul>
</li>
</ul>
</li>
<li><p>一维数组的使用：数组元素的默认初始化值<br> <img src="http://wangzixuan.work/3486" alt=""></p>
<ul>
<li>数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。</li>
<li>对于基本数据类型而言，默认初始化值各有不同</li>
<li>对于引用数据类型而言，默认初始化值为null(注意 与0不同！)</li>
</ul>
</li>
<li><p>数组的内存解析</p>
<ul>
<li><p>Java中使用关键字new来创建数组</p>
<ul>
<li><p>如下是创建基本数据类型元素的一维数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">    int[] s;&#x2F;&#x2F;①</span><br><span class="line">    s &#x3D; new int[10];&#x2F;&#x2F;②</span><br><span class="line">    &#x2F;&#x2F;int[] s&#x3D;new int[10];</span><br><span class="line">    &#x2F;&#x2F; 基本 数据类型 数组在显式赋值之前，</span><br><span class="line">    &#x2F;&#x2F;Java 会自动 给他们赋默认值。</span><br><span class="line">    for ( int i&#x3D;0; i&lt;10; i++ ) &#123;</span><br><span class="line">        s[i] &#x3D;2*i+1;&#x2F;&#x2F;③</span><br><span class="line">        System.out.println(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①<br><img src="http://wangzixuan.work/3489" alt=""></p>
<p>②<br><img src="http://wangzixuan.work/3491" alt=""></p>
<p>③<br><img src="http://wangzixuan.work/3493" alt=""></p>
</li>
</ul>
</li>
<li><p>内存的简化结构<br>  <img src="http://wangzixuan.work/3495" alt=""><br>  <img src="http://wangzixuan.work/3497" alt=""><br>  <img src="http://wangzixuan.work/3501" alt=""></p>
</li>
</ul>
</li>
<li><p>代码示例</p>
<ol>
<li><p>题目：从键盘读入学生成绩，找出最高分，并输出学生成绩等级。</p>
<ul>
<li>成绩&gt;=最高分-10 等级为’A’</li>
<li>成绩&gt;=最高分-20 等级为’B’</li>
<li>成绩&gt;=最高分-30 等级为’C’</li>
<li>其余 等级为’D’</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	&#x2F;&#x2F;1.使用Scanner，读取学生个数</span><br><span class="line">	Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">	System.out.println(&quot;请输入学生人数：&quot;);</span><br><span class="line">	int number &#x3D; scanner.nextInt();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;2.创建数组，存储学生成绩：动态初始化</span><br><span class="line">	int[] scores &#x3D; new int[number];</span><br><span class="line">	&#x2F;&#x2F;3.给数组中的元素赋值</span><br><span class="line">	System.out.println(&quot;请输入&quot; + number + &quot;个学生成绩：&quot;);</span><br><span class="line">	int maxScore &#x3D; 0;</span><br><span class="line">	for(int i &#x3D; 0;i &lt; scores.length;i++)&#123;</span><br><span class="line">		scores[i] &#x3D; scanner.nextInt();</span><br><span class="line">		&#x2F;&#x2F;4.获取数组中的元素的最大值:最高分</span><br><span class="line">		if(maxScore &lt; scores[i])&#123;</span><br><span class="line">			maxScore &#x3D; scores[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;5.根据每个学生成绩与最高分的差值，得到每个学生的等级，并输出等级和成绩</span><br><span class="line">	char level;</span><br><span class="line">	for(int i &#x3D; 0;i &lt; scores.length;i++)&#123;</span><br><span class="line">		if(maxScore - scores[i] &lt;&#x3D; 10)&#123;</span><br><span class="line">			level &#x3D; &#39;A&#39;;</span><br><span class="line">		&#125;else if(maxScore - scores[i] &lt;&#x3D; 20)&#123;</span><br><span class="line">			level &#x3D; &#39;B&#39;;</span><br><span class="line">		&#125;else if(maxScore - scores[i] &lt;&#x3D; 30)&#123;</span><br><span class="line">			level &#x3D; &#39;C&#39;;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			level &#x3D; &#39;D&#39;;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;student &quot; + i + </span><br><span class="line">				&quot; score is &quot; + scores[i] + &quot;,grade is &quot; + level);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h4 id="三、多维数组的使用"><a href="#三、多维数组的使用" class="headerlink" title="三、多维数组的使用"></a>三、多维数组的使用</h4><ol>
<li><p>Java 语言里提供了支持多维数组的语法。</p>
<ul>
<li>如果说可以把一维数组当成几何中的线性图形，那么二维数组就相当于是一个表格，像Excel中的表格一样。</li>
<li>对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。其实，从数组底层的运行机制来看，其实没有多维数组。<br><img src="http://wangzixuan.work/3601" alt=""></li>
</ul>
</li>
<li><p>二维数组[][]的声明与初始化</p>
<ul>
<li><p>格式1 （动态初始化）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] arr &#x3D; new int[3][2];</span><br></pre></td></tr></table></figure>
<ul>
<li>定义了名称为arr的二维数组</li>
<li>二维数组中有3个一维数组</li>
<li>每一个一维数组中有2个元素</li>
<li>一维数组的名称分别为arr[0], arr[1], arr[2]</li>
<li>给第一个一维数组1脚标位赋值为78写法是：arr[0][1] = 78;</li>
</ul>
</li>
<li><p>格式2 （动态初始化）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] arr &#x3D; new int[3][];</span><br></pre></td></tr></table></figure>
<ul>
<li>二维数组中有3个一维数组。</li>
<li>每个一维数组都是默认初始化值null (注意：区别于格式1）</li>
<li>可以对这个三个一维数组分别进行初始化</li>
<li>arr[0] = new int[3]; arr[1] = new int[1]; arr[2] = new int[2];</li>
<li>注：int[][]arr = new int[][3]; //非法</li>
</ul>
</li>
<li><p>格式3 （静态初始化</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] arr &#x3D; new int[][]&#123;&#123;3,8,2&#125;,&#123;2,7&#125;,&#123;9,0,1,6&#125;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个名称为arr的二维数组，二维数组中有三个一维数组</li>
<li>每一个一维数组中具体元素也都已初始化</li>
<li>第一个一维数组 arr[0] = {3,8,2};</li>
<li>第二个一维数组 arr[1] = {2,7};</li>
<li>第三个一维数组 arr[2] = {9,0,1,6};</li>
<li>第三个一维数组的长度表示方式：arr[2].length;</li>
<li><strong>注意特殊写法情况</strong>： int[][] y ; int[] y[] ; int y[][] x是一维数组，y是二维数组。</li>
<li>Java中多维数组不必都是规则矩阵形式</li>
</ul>
</li>
</ul>
</li>
<li><p>二维数组元素的默认初始化值</p>
<ul>
<li>针对于初始化方式一：比如：int[][] arr = new int[4][3];<ul>
<li>外层元素的初始化值为：地址值</li>
<li>内层元素的初始化值为：与一维数组初始化情况相同</li>
</ul>
</li>
<li>针对于初始化方式二：比如：int[][] arr = new int[4][];<ul>
<li>外层元素的初始化值为：null</li>
<li>内层元素的初始化值为：不能调用，否则报错。</li>
</ul>
</li>
</ul>
</li>
<li><p>二维数组的内存解析<br> <img src="http://wangzixuan.work/3603" alt=""><br> <img src="http://wangzixuan.work/3605" alt=""><br> <img src="http://wangzixuan.work/3607" alt=""><br> <img src="http://wangzixuan.work/3609" alt=""></p>
</li>
<li><p>代码示例</p>
<ol>
<li><p>题目：<br><img src="http://wangzixuan.work/3631" alt=""></p>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	</span><br><span class="line">	int[][] arr &#x3D; new int[3][];</span><br><span class="line">	arr[0] &#x3D; new int[]&#123;3,5,8&#125;;</span><br><span class="line">	arr[1] &#x3D; new int[2];</span><br><span class="line">	arr[1][0] &#x3D; 12;</span><br><span class="line">	arr[1][1] &#x3D; 9;</span><br><span class="line">	arr[2] &#x3D; new int[]&#123;7,0,6,4&#125;;</span><br><span class="line">	</span><br><span class="line">	int sum &#x3D; 0;&#x2F;&#x2F;记录总和</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">		for(int j &#x3D; 0; j &lt; arr[i].length; j++)&#123;</span><br><span class="line">			sum +&#x3D; arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(&quot;总和为：&quot; + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h4 id="四、数组中涉及到的常见算法-排序算法"><a href="#四、数组中涉及到的常见算法-排序算法" class="headerlink" title="四、数组中涉及到的常见算法-排序算法"></a>四、数组中涉及到的常见算法-排序算法</h4><ol>
<li><p>排序：</p>
<ul>
<li>假设含有n个记录的序列为{R1，R2，…,Rn},其相应的关键字序列为{K1，K2，…,Kn}。将这些记录重新排序为{Ri1,Ri2,…,Rin},使得相应的关键字值满足条Ki1&lt;=Ki2&lt;=…&lt;=Kin,这样的一种操作称为排序。</li>
<li>通常来说，排序的目的是快速查找。</li>
</ul>
</li>
<li><p>衡量排序算法的优劣：</p>
<ol>
<li>时间复杂度：分析关键字的比较次数和记录的移动次数</li>
<li>空间复杂度：分析排序算法中需要多少辅助内存</li>
<li>稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。</li>
</ol>
</li>
<li><p>排序算法分类</p>
<ul>
<li>内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。</li>
<li>外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。</li>
</ul>
</li>
<li><p>十大内部排序（颜色为重要程度 红→黄→黑）</p>
<ol>
<li>交换排序（红）<ul>
<li>冒泡排序（红）</li>
<li>快速排序（红）</li>
</ul>
</li>
<li>选择排序（黑）<ul>
<li>直接选择排序（黑）</li>
<li>堆排序（黄）</li>
</ul>
</li>
<li>归并排序（黄）</li>
<li>插入排序（黑）<ul>
<li>直接插入排序（黑）</li>
<li>折半插入排序（黑）</li>
<li>Shell排序（黑）</li>
</ul>
</li>
<li>桶式排序（黑）</li>
<li>基数排序（黑）</li>
</ol>
</li>
<li><p>算法的5大特征</p>
<ul>
<li><strong>输入（Input）</strong>：有0个或多个输入数据，这些输入必须有清楚的描述和定义</li>
<li><strong>输出（Output）</strong>：至少有1个或多个输出结果，不可以没有输出结果</li>
<li><strong>有穷性（有限性，Finiteness）</strong>：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成</li>
<li><strong>确定性（明确性，Definiteness）</strong>：算法中的每一步都有确定的含义，不会出现二义性</li>
<li><strong>可行性（有效性，Effectiveness）</strong>：算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案</li>
<li>说明：满足确定性的算法也称为：确定性算法。现在人们也关注更广泛的概念，例如考虑各种非确定性的算法，如并行算法、概率算法等。另外，人们也关注并不要求终止的计算描述，这种描述有时被称为过程（procedure）</li>
</ul>
</li>
<li><p>冒泡排序</p>
<ul>
<li><p><strong>介绍</strong>：<br>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
</li>
<li><p><strong>排序思想</strong>：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。</li>
</ol>
</li>
<li><p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	int[] arr &#x3D; new int[]&#123;43,32,76,-98,0,64,33,-21,32,99&#125;;</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 0; i &lt; arr.length - 1;i++)&#123;</span><br><span class="line">		for(int j &#x3D; 0; j &lt; arr.length - i -1;j++)&#123;</span><br><span class="line">			if(arr[j] &gt; arr[j + 1])&#123;</span><br><span class="line">				int temp &#x3D; arr[j + 1];</span><br><span class="line">				arr[j + 1] &#x3D; arr[j];</span><br><span class="line">				arr[j] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>快速排序</p>
<ul>
<li><p><strong>介绍</strong>：<br>快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p>
<p>  快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))。</p>
</li>
<li><p><strong>排序思想</strong>：</p>
<ol>
<li>从数列中挑出一个元素，称为”基准”（pivot）。</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
<li>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li>
</ol>
</li>
<li><p><strong>图示</strong><br><img src="http://wangzixuan.work/3718" alt=""><br><img src="http://wangzixuan.work/3720" alt=""><br><img src="http://wangzixuan.work/3723" alt=""></p>
</li>
<li><p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>排序算法性能对比<br> <img src="http://wangzixuan.work/3725" alt=""></p>
</li>
</ol>
<ul>
<li>各种内部排序方法性能比较<ol>
<li>从平均时间而言：快速排序最佳。但在最坏情况下时间性能不如堆排序和归并排序。</li>
<li>从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。</li>
<li>从稳定性看：直接插入排序、冒泡排序和归并排序是稳定的；而直接选择排序、快速排序、Shell排序和堆排序是不稳定排序</li>
<li>从待排序的记录数n的大小看，n较小时，宜采用简单排序；而n较大时宜采用改进排序。</li>
</ol>
</li>
</ul>
<ol start="9">
<li>排序算法的选择<ol>
<li>若n较小(如n≤50)，可采用 直接插入或 直接选择排序。<ul>
<li>当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直<br>接插入，应选直接选择排序为宜。</li>
</ul>
</li>
<li>若文件初始状态基本有序(指正序)，则应选用 直接插入、冒泡或随机的 快速排序为宜；</li>
<li>若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。<h4 id="五、Arrays工具类的使用"><a href="#五、Arrays工具类的使用" class="headerlink" title="五、Arrays工具类的使用"></a>五、Arrays工具类的使用</h4></li>
</ol>
</li>
</ol>
<ul>
<li><p>java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。<br><img src="http://wangzixuan.work/3636" alt=""></p>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;1.boolean equals(int[] a,int[] b):判断两个数组是否相等。</span><br><span class="line">	int[] arr1 &#x3D; new int[]&#123;1,2,3,4&#125;;</span><br><span class="line">	int[] arr2 &#x3D; new int[]&#123;1,3,2,4&#125;;</span><br><span class="line">	boolean isEquals &#x3D; Arrays.equals(arr1, arr2);</span><br><span class="line">	System.out.println(isEquals);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;2.String toString(int[] a):输出数组信息。</span><br><span class="line">	System.out.println(Arrays.toString(arr1));</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	&#x2F;&#x2F;3.void fill(int[] a,int val):将指定值填充到数组之中。</span><br><span class="line">	Arrays.fill(arr1,10);</span><br><span class="line">	System.out.println(Arrays.toString(arr1));</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;4.void sort(int[] a):对数组进行排序。</span><br><span class="line">	Arrays.sort(arr2);</span><br><span class="line">	System.out.println(Arrays.toString(arr2));</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;5.int binarySearch(int[] a,int key)</span><br><span class="line">	int[] arr3 &#x3D; new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;</span><br><span class="line">	int index &#x3D; Arrays.binarySearch(arr3, 210);</span><br><span class="line">	if(index &gt;&#x3D; 0)&#123;</span><br><span class="line">		System.out.println(index);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		System.out.println(&quot;未找到&quot;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="六、数组中使用的常见异常"><a href="#六、数组中使用的常见异常" class="headerlink" title="六、数组中使用的常见异常"></a>六、数组中使用的常见异常</h4><ol>
<li><p>数组脚标越界异常(ArrayIndexOutOfBoundsException)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] arr &#x3D; new int[2];</span><br><span class="line">System.out.println(arr[2]);</span><br><span class="line">System.out.println(arr[-1]);</span><br></pre></td></tr></table></figure>
<ul>
<li>访问到了数组中的不存在的脚标时发生。</li>
</ul>
</li>
<li><p>空指针异常(NullPointerException)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] arr &#x3D; null;</span><br><span class="line">System.out.println(arr[0]);</span><br></pre></td></tr></table></figure>
<ul>
<li>arr引用没有指向实体，却在操作实体中的元素时。</li>
</ul>
</li>
<li><p>代码示例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;1. 数组角标越界的异常：ArrayIndexOutOfBoundsExcetion</span><br><span class="line">	int[] arr &#x3D; new int[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;		for(int i &#x3D; 0;i &lt;&#x3D; arr.length;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;			System.out.println(arr[i]);</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;		System.out.println(arr[-2]);</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;hello&quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;2.2. 空指针异常：NullPointerException</span><br><span class="line">	&#x2F;&#x2F;情况一：</span><br><span class="line">&#x2F;&#x2F;		int[] arr1 &#x3D; new int[]&#123;1,2,3&#125;;</span><br><span class="line">&#x2F;&#x2F;		arr1 &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(arr1[0]);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;情况二：</span><br><span class="line">&#x2F;&#x2F;		int[][] arr2 &#x3D; new int[4][];</span><br><span class="line">&#x2F;&#x2F;		System.out.println(arr2[0][0]);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;情况三：</span><br><span class="line">	String[] arr3 &#x3D; new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;;</span><br><span class="line">	arr3[0] &#x3D; null;</span><br><span class="line">	System.out.println(arr3[0].toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>数组</tag>
        <tag>一维数组</tag>
        <tag>二维数组</tag>
        <tag>排序算法</tag>
        <tag>冒泡排序</tag>
        <tag>快速排序</tag>
        <tag>排序算法性能对比</tag>
        <tag>Arrays工具类</tag>
        <tag>数组异常</tag>
        <tag>数组越界异常</tag>
        <tag>空指针异常</tag>
      </tags>
  </entry>
  <entry>
    <title>12.Java基础知识-面向对象编程（中）-继承性</title>
    <url>/2020/07/31/12-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89-%E7%BB%A7%E6%89%BF%E6%80%A7/</url>
    <content><![CDATA[<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><ul>
<li>如果多个类中存在相同的属性和行为，我们可以将这些类（子类、派生类）中的相同的属性和行为抽取到一个类（父类、基类、超类）中，这样子类中就不需要定义这些方法和属性，只要继承父类即可。</li>
<li>不要仅为了获取其他类的某个功能而去继承</li>
<li>继承的关键字“extends”</li>
<li>子类不是父类的子集，而是对父类的拓展（功能比父类丰富）</li>
<li>子类继承父类，就继承了父类所有的属性和方法</li>
<li>在子类中，可以使用父类中定义的属性和方法，也可以有自己新的属性和方法<h4 id="2-类继承语法规则"><a href="#2-类继承语法规则" class="headerlink" title="2. 类继承语法规则"></a>2. 类继承语法规则</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Subclass extends SuperClass&#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-作用"><a href="#3-作用" class="headerlink" title="3. 作用"></a>3. 作用</h4><ul>
<li>减少代码冗余，提高代码复用</li>
<li>更有利于类的拓展</li>
<li>让类与类产生联系，提供多态的前提<h4 id="4-继承的规则"><a href="#4-继承的规则" class="headerlink" title="4. 继承的规则"></a>4. 继承的规则</h4></li>
<li>子类不能直接访问父类中私有（private）的成员变量和方法<br><img src="http://wangzixuan.work/4602" alt=""></li>
<li>Java只支持单继承和多层继承，不允许多重继承<ul>
<li>一个类只能有一个父类</li>
<li>一个父类可以派生多个子类<br><img src="http://wangzixuan.work/4604" alt=""><br><img src="http://wangzixuan.work/4606" alt=""></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>继承性</tag>
      </tags>
  </entry>
  <entry>
    <title>11.Java基础知识-面向对象编程（上）</title>
    <url>/2020/07/23/11-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="面向对象编程（上）"><a href="#面向对象编程（上）" class="headerlink" title="面向对象编程（上）"></a>面向对象编程（上）</h2><p><img src="http://wangzixuan.work/3788" alt=""></p>
<h4 id="一、面向过程与面向对象"><a href="#一、面向过程与面向对象" class="headerlink" title="一、面向过程与面向对象"></a>一、面向过程与面向对象</h4><ol>
<li><p>何谓“面向对象”的编程思想？<br> 首先解释一下“思想”。</p>
<p> 先问你个问题：你想做个怎样的人？</p>
<p> 可能你会回答：我想做个好人，孝敬父母，尊重长辈，关爱亲朋……</p>
<p> 你看，这就是思想。这是你做人的思想，或者说，是你做人的原则。</p>
<p> 做人有做人的原则，编程也有编程的原则。这些编程的原则呢，就是编程思想。</p>
</li>
<li><p>面向过程(POP) 与 与 象 面向对象(OOP)</p>
<ul>
<li><p>面向对象：Object Oriented Programming</p>
</li>
<li><p>面向过程：Procedure Oriented Programming</p>
</li>
<li><p>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</p>
</li>
<li><p>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。</p>
</li>
<li><p>人把大象装冰箱</p>
<p><img src="http://wangzixuan.work/3848" alt=""></p>
</li>
</ul>
</li>
<li><p>面向对象的三大特征</p>
<ul>
<li>封装 (Encapsulation)</li>
<li>继承 (Inheritance)</li>
<li>多态 (Polymorphism)</li>
</ul>
</li>
<li><p>面向对象的思想概述</p>
<ul>
<li>程序员从面向过程的执行者转化成了面向对象的指挥者</li>
<li>面向对象分析方法分析问题的思路和步骤：<ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体。</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。</li>
<li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。<h4 id="二、Java基本元素：类和对象"><a href="#二、Java基本元素：类和对象" class="headerlink" title="二、Java基本元素：类和对象"></a>二、Java基本元素：类和对象</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象的思想概述</p>
<ul>
<li>类(Class)和对象(Object)是面向对象的核心概念。<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>
</ul>
</li>
<li>“万事万物皆对象”<br><img src="http://wangzixuan.work/3872" alt=""></li>
<li>可以理解为： 类  =  抽象概念的人；对象  =  实实在在的某个人</li>
<li>面向对象程序设计的重点是类的设计</li>
<li>类的设计，其实就是类的成员的设计</li>
</ul>
</li>
<li><p>Java 类及类的成员</p>
<ul>
<li>属性：对应类中的成员变量</li>
<li>行为：对应类中的成员方法</li>
<li>Field =  属性 =  成员变量</li>
<li>Method = (成员) 方法 =  函数</li>
</ul>
</li>
<li><p>类的语法格式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">修饰符 class  类名 &#123;</span><br><span class="line">    属性声明;</span><br><span class="line">    方法声明;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">public class Person&#123;</span><br><span class="line"></span><br><span class="line">    private int age ; &#x2F;&#x2F;声明私有变量age</span><br><span class="line">    </span><br><span class="line">    public void showAge(int i)&#123;&#x2F;&#x2F;声明方法showAge( )</span><br><span class="line">        age &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建Java自定义类</p>
<ul>
<li>定义类（考虑修饰符、类名）</li>
<li>编写类的属性（考虑修饰符、属性类型、属性名、初始化值）</li>
<li>编写类的方法（考虑修饰符、返回值类型、方法名、形参等）<h4 id="三、对象的创建和使用"><a href="#三、对象的创建和使用" class="headerlink" title="三、对象的创建和使用"></a>三、对象的创建和使用</h4><img src="http://wangzixuan.work/3907" alt=""></li>
</ul>
</li>
</ol>
<ul>
<li>创建对象语法：  类名 对象名 = new  类名();</li>
<li>使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）</li>
<li>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。<ul>
<li>如：new Person().shout();</li>
</ul>
</li>
<li>使用情况<ul>
<li>如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。</li>
<li>我们经常将匿名对象作为实参传递给一个方法调用。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    public int legs;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(“Eating.”);</span><br><span class="line">    &#125;</span><br><span class="line">    public viod move()&#123;</span><br><span class="line">        System.out.println(“Move.”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Zoo&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        &#x2F;&#x2F; 创建对象</span><br><span class="line">        Animal xb&#x3D;new Animal();</span><br><span class="line">        xb.legs&#x3D;4;&#x2F;&#x2F; 访问属性</span><br><span class="line">        System.out.println(xb.legs);</span><br><span class="line">        xb.eat();&#x2F;&#x2F; 访问方法</span><br><span class="line">        xb.move();&#x2F;&#x2F; 访问方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://wangzixuan.work/3910" alt=""></p>
<ul>
<li>说明：如果创建了一个类的多个对象，对于类中定义的属性，每个对象都拥有各自的一套副本，且互不干扰。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Zoo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Animal xb &#x3D; new Animal();</span><br><span class="line">        Animal xh &#x3D; new Animal();</span><br><span class="line">        xb.legs &#x3D; 4;</span><br><span class="line">        xh.legs &#x3D; 0;</span><br><span class="line">        System.out.println(xb.legs); &#x2F;&#x2F; 4</span><br><span class="line">        System.out.println(xh.legs); &#x2F;&#x2F; 0</span><br><span class="line">        xb.legs &#x3D; 2;</span><br><span class="line">        System.out.println(xb.legs); &#x2F;&#x2F; 2</span><br><span class="line">        System.out.println(xh.legs); &#x2F;&#x2F; 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>提示<ul>
<li>类的访问机制：<ul>
<li>在一个类中的访问机制：类中的方法可以直接访问类中的成员变量（例外：static方法访问非static，编译不通过。）</li>
<li>在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员。</li>
</ul>
</li>
</ul>
</li>
<li>对象的产生<br>  <img src="http://wangzixuan.work/3962" alt=""></li>
<li>对象的使用<br>  <img src="http://wangzixuan.work/3964" alt=""></li>
<li>对象的生命周期<br>  <img src="http://wangzixuan.work/3966" alt=""></li>
<li>对象的创建和使用：内存解析<br>  <img src="http://wangzixuan.work/3972" alt=""><br>  <img src="http://wangzixuan.work/3978" alt=""><br>  <img src="http://wangzixuan.work/3974" alt=""><br>  <img src="http://wangzixuan.work/3976" alt=""><h4 id="四、类的成员之一：属性"><a href="#四、类的成员之一：属性" class="headerlink" title="四、类的成员之一：属性"></a>四、类的成员之一：属性</h4></li>
</ul>
<ol>
<li><p>语法格式：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符  数据类型  属性名 &#x3D;  初始化值;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明1:  修饰符</p>
<ul>
<li>常用的权限修饰符有：private、缺省、protected、public</li>
<li>其他修饰符：static、final (暂不考虑)</li>
</ul>
</li>
<li><p>说明2 ：数据类型</p>
<ul>
<li>任何基本数据类型(如int、Boolean)或任何引用数据类型。</li>
</ul>
</li>
<li><p>说明3 ：属性名</p>
<ul>
<li>属于标识符，符合命名规则和规范即可。</li>
</ul>
</li>
<li><p>举例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">private int age; &#x2F;&#x2F; 声明private变量 age</span><br><span class="line">public String name &#x3D; “Lila”; &#x2F;&#x2F;声明public变量 name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>变量的分类：成员变量与局部变量</p>
</li>
</ol>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量。<br><img src="http://wangzixuan.work/4015" alt=""></li>
<li>注意：二者在初始化值方面的异同:<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，均需显式初始化。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>成员变量（属性）和局部变量的区别？<br> <img src="http://wangzixuan.work/4017" alt=""></p>
</li>
<li><p>成员变量vs局部变量的内存位置<br> <img src="http://wangzixuan.work/4019" alt=""></p>
</li>
<li><p>对象属性的默认初始化赋值</p>
<ul>
<li>当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外的变量类型都是引用类型，如上面的Person及前面讲过的数组。<br><img src="http://wangzixuan.work/4021" alt=""><h4 id="五、类的成员之二：方法"><a href="#五、类的成员之二：方法" class="headerlink" title="五、类的成员之二：方法"></a>五、类的成员之二：方法</h4></li>
</ul>
</li>
<li><p>什么是方法(method 、函数):</p>
<ul>
<li>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。</li>
<li>将功能封装为方法的目的是，可以实现代码重用，简化代码</li>
<li>Java里的方法不能独立存在，所有的方法必须定义在类里。</li>
</ul>
</li>
<li><p>方法的声明格式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 形参1, 参数类型 形参2, ….）｛</span><br><span class="line">    方法体程序代码;</span><br><span class="line">    return  返回值;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<ul>
<li>修饰符：public, 缺省,private, protected等</li>
<li>返回值类型：<ul>
<li>没有返回值：void。</li>
<li>有返回值，声明出返回值的类型。与方法体中“return 返回值”</li>
</ul>
</li>
<li>方法名 ：</li>
<li>属于标识符，命名时遵循标识符命名规则和规范，“见名知意”</li>
<li>形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开</li>
<li>返回值：方法在执行完毕后返还给调用它的程序的数据。</li>
</ul>
</li>
<li><p>举例 ：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    public int getAge() &#123; &#x2F;&#x2F;声明方法getAge()</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int i) &#123; &#x2F;&#x2F;声明方法setAge</span><br><span class="line">        age &#x3D; i; &#x2F;&#x2F;将参数i的值赋给类的成员变量age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的分类：<br> <img src="http://wangzixuan.work/4074" alt=""></p>
</li>
<li><p>方法的调用</p>
<ul>
<li>方法通过方法名被调用，且只有被调用才会执行。</li>
<li>方法调用的过程分析<br><img src="http://wangzixuan.work/4076" alt=""></li>
</ul>
</li>
<li><p>注 意：</p>
</li>
</ol>
<ul>
<li>方法被调用一次，就会执行一次</li>
<li>没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可以不必使用return语句。如果使用，仅用来结束方法。</li>
<li>定义方法时，方法的结果应该返回给调用者，交由调用者处理。</li>
<li>方法中只能调用方法或属性，不可以在方法内部定义方法。<h4 id="六、再谈方法"><a href="#六、再谈方法" class="headerlink" title="六、再谈方法"></a>六、再谈方法</h4></li>
</ul>
<ol>
<li><p>方法的重载(overload)</p>
<ul>
<li><p>重载的概念:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p>
</li>
<li><p>重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</p>
</li>
<li><p>重载示例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;返回两个整数的和</span><br><span class="line">int add(int x,int y)&#123;return x+y;&#125;</span><br><span class="line">&#x2F;&#x2F;返回三个整数的和</span><br><span class="line">int add(int x,int y,int z)&#123;return x+y+z;&#125;</span><br><span class="line">&#x2F;&#x2F;返回两个小数的和</span><br><span class="line">double add(double x,double y)&#123;return x+y;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用重载方法，可以为编程带来方便。例如，System.out.println()方法就是典型的重载方法，其内部的声明形式如下 ：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void println(byte x)</span><br><span class="line">public void println(short x)</span><br><span class="line">public void println(int x)</span><br><span class="line">public void println(long x)</span><br><span class="line">public void println(float x)</span><br><span class="line">public void println(double x)</span><br><span class="line">public void println(char x)</span><br><span class="line">public void println(double x)</span><br><span class="line">public void println()</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可变形参的方法</p>
<h6 id="JavaSE-5-0-中提供了Varargs-variable-number-of-arguments-机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。"><a href="#JavaSE-5-0-中提供了Varargs-variable-number-of-arguments-机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。" class="headerlink" title="JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。"></a>JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。</h6><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</span><br><span class="line">public static void test(int a ,String[] books);</span><br><span class="line">&#x2F;&#x2F;JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量</span><br><span class="line">public static void test(int a ,String…books);</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>说明：</p>
<ol>
<li>声明格式：方法名(参数的类型名 …参数名)</li>
<li>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</li>
<li>可变个数形参的方法与同名的方法之间，彼此构成重载</li>
<li>可变参数方法的使用与方法参数部分使用数组是一致的</li>
<li>方法的参数部分有可变形参，需要放在形参声明的最后</li>
<li>在一个方法的形参位置，最多只能声明一个可变个数形参</li>
</ol>
</li>
<li><p>实例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test(String[] msg)&#123;</span><br><span class="line">System.out.println(“含字符串数组参数的test方法 &quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void test1(String book)&#123;</span><br><span class="line">System.out.println(“****与可变形参方法构成重载的test1方法****&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void test1(String ... books)&#123;</span><br><span class="line">System.out.println(&quot;****形参长度可变的test1方法****&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">TestOverload to &#x3D; new TestOverload();</span><br><span class="line">&#x2F;&#x2F;下面两次调用将执行第二个test方法</span><br><span class="line">to.test1();</span><br><span class="line">to.test1(&quot;aa&quot; , &quot;bb&quot;);</span><br><span class="line">&#x2F;&#x2F;下面将执行第一个test方法</span><br><span class="line">to.test(new String[]&#123;&quot;aa&quot;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方法参数的值传递机制</p>
<ul>
<li><p>方法，必须由其所在类或对象调用才有意义。若方法含有参数：</p>
<ul>
<li>形参：方法声明时的参数</li>
<li>实参：方法调用时实际传给形参的参数值</li>
</ul>
</li>
<li><p>Java的实参值如何传入方法呢？</p>
<ul>
<li>Java里方法的参数传递方式只有一种：值传递。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</li>
<li>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</li>
</ul>
</li>
</ul>
</li>
<li><p>基本数据类型的参数传递<br><img src="http://wangzixuan.work/4142" alt=""></p>
</li>
<li><p>引用数据类型的参数传递<br><img src="http://wangzixuan.work/4144" alt=""><br><img src="http://wangzixuan.work/4146" alt=""><br><img src="http://wangzixuan.work/4148" alt=""><br><img src="http://wangzixuan.work/4150" alt=""></p>
</li>
<li><p>例题1：交换两个数的数值</p>
<ul>
<li><p>错误实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransferTest1 &#123;</span><br><span class="line">    public void swap(int a, int b) &#123;</span><br><span class="line">        int tmp &#x3D; a;</span><br><span class="line">        a &#x3D; b;</span><br><span class="line">        b &#x3D; tmp;</span><br><span class="line">        System.out.println(&quot;swap方法里，a的值是&quot; + a + &quot;；b的值是&quot; + b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TransferTest1 test &#x3D; new TransferTest1();</span><br><span class="line">        int a &#x3D; 5;</span><br><span class="line">        int b &#x3D; 10;</span><br><span class="line">        test.swap(a, b);</span><br><span class="line">        System.out.println(&quot;交换结束后，变量a的值是&quot; + a + &quot;；变量b的值是&quot; + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>参数类型为：基本数据类型<br><img src="http://wangzixuan.work/4183" alt=""></p>
</li>
<li><p>正确实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DataSwap &#123;</span><br><span class="line">    public int a;</span><br><span class="line">    public int b;</span><br><span class="line">&#125;</span><br><span class="line">public class TransferTest2 &#123;</span><br><span class="line">    public static void swap(DataSwap ds) &#123;</span><br><span class="line">        int temp &#x3D; ds.a;</span><br><span class="line">        ds.a &#x3D; ds.b;</span><br><span class="line">        ds.b &#x3D; temp;</span><br><span class="line">        System.out.println(&quot;swap方法里，a Field的值是&quot; + ds.a + &quot;;b Field的值是&quot; + ds.b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataSwap ds &#x3D; new DataSwap();</span><br><span class="line">        ds.a &#x3D; 5;</span><br><span class="line">        ds.b &#x3D; 10;</span><br><span class="line">        swap(ds);</span><br><span class="line">        System.out.println(&quot;交换结束后，a Field的值是&quot; + ds.a + &quot;;b Field的值是&quot; + ds.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>参数类型为：引用数据类型<br><img src="http://wangzixuan.work/4185" alt=""></p>
</li>
</ul>
</li>
<li><p>例题二：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransferTest3 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        TransferTest3 test &#x3D; new TransferTest3();</span><br><span class="line">        test.first();</span><br><span class="line">    &#125;</span><br><span class="line">    public void first() &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">        Value v &#x3D; new Value();</span><br><span class="line">        v.i &#x3D; 25;</span><br><span class="line">        second(v, i);</span><br><span class="line">        System.out.println(v.i);</span><br><span class="line">    &#125;</span><br><span class="line">    public void second(Value v, int i) &#123;</span><br><span class="line">        i &#x3D; 0;</span><br><span class="line">        v.i &#x3D; 20;</span><br><span class="line">        Value val &#x3D; new Value();</span><br><span class="line">        v &#x3D; val;</span><br><span class="line">        System.out.println(v.i + &quot; &quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Value &#123;</span><br><span class="line">    int i &#x3D; 15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li>方法的参数传递图示<br><img src="http://wangzixuan.work/4187" alt=""></li>
</ul>
</li>
<li><p>面试题<br><img src="http://wangzixuan.work/4189" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       int a &#x3D; 10;</span><br><span class="line">       int b &#x3D; 20;</span><br><span class="line">        </span><br><span class="line">       method(a, b);</span><br><span class="line">        </span><br><span class="line">       System.out.println(&quot;a&#x3D;&quot;+a);</span><br><span class="line">       System.out.println(&quot;b&#x3D;&quot;+b);</span><br><span class="line">       tes();</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;方法1-终止JVM</span><br><span class="line">   public static void method(int a,int b) &#123;</span><br><span class="line">       System.out.print(&quot;a&#x3D;100 b&#x3D;200&quot;);</span><br><span class="line">       System.exit(0);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;方法2-另一种是改变打印输出流</span><br><span class="line">   public static void method(final int a,final int b) &#123;</span><br><span class="line">       PrintStream stream &#x3D; new PrintStream(System.out)&#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void print(String s) &#123;</span><br><span class="line">               super.print(s.replace(a+&quot;&quot;, a*10+&quot;&quot;).replace(b+&quot;&quot;, b*10+&quot;&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       System.setOut(stream);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>  <img src="http://wangzixuan.work/4191" alt=""></p>
</li>
</ul>
</li>
<li><p>递归(recursion) 方法</p>
<ul>
<li><p>递归方法：一个方法体内调用它自身。</p>
</li>
<li><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</p>
</li>
<li><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;计算1-100之间所有自然数的和</span><br><span class="line">public int sum(int num)&#123;</span><br><span class="line">    if(num &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num + sum(num - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>拓展<br><img src="http://wangzixuan.work/4211" alt=""><br>双重递归是以指数级增长的<br><img src="http://wangzixuan.work/4213" alt=""></p>
<h4 id="七、OOP特征一：封装与隐藏"><a href="#七、OOP特征一：封装与隐藏" class="headerlink" title="七、OOP特征一：封装与隐藏"></a>七、OOP特征一：封装与隐藏</h4></li>
</ul>
</li>
<li><p>为什么需要封装？封装的作用和含义？</p>
<ul>
<li>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？</li>
<li>我要开车，…</li>
</ul>
</li>
<li><p>我们程序设计追求“高内聚，低耦合”。</p>
<ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>低耦合 ：仅对外暴露少量的方法用于使用。</li>
</ul>
</li>
<li><p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p>
</li>
<li><p>问题引入</p>
<ul>
<li><p>使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或 安全性</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public int legs;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">       System.out.println(&quot;Eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        System.out.println(&quot;Moving.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Zoo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Animal xb &#x3D; new Animal();</span><br><span class="line">        xb.legs &#x3D; 4;</span><br><span class="line">        System.out.println(xb.legs);</span><br><span class="line">        xb.eat();</span><br><span class="line">        xb.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题：xb.legs = -1000;</p>
</li>
<li><p>应该将legs 属性保护起来，防止乱用。</p>
</li>
<li><p>保护的方式：信息隐藏</p>
</li>
</ul>
</li>
<li><p>信息的封装和隐藏</p>
<ul>
<li><p>Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：</p>
</li>
<li><p>隐藏一个类中不需要对外提供的实现细节；</p>
</li>
<li><p>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；</p>
</li>
<li><p>便于修改，增强代码的可维护性；</p>
</li>
<li><p>举例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private int legs;&#x2F;&#x2F; 将属性legs定义为private，只能被Animal类内部访问</span><br><span class="line">    public void setLegs(int i) &#123; &#x2F;&#x2F; 在这里定义方法 eat() 和 move()</span><br><span class="line">        if (i !&#x3D; 0 &amp;&amp; i !&#x3D; 2 &amp;&amp; i !&#x3D; 4) &#123;</span><br><span class="line">        System.out.println(&quot;Wrong number of legs!&quot;);</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line">        legs &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getLegs() &#123;</span><br><span class="line">        return legs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Zoo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Animal xb &#x3D; new Animal();</span><br><span class="line">        xb.setLegs(4); &#x2F;&#x2F; xb.setLegs(-1000);</span><br><span class="line">        &#x2F;&#x2F;xb.legs &#x3D; -1000; &#x2F;&#x2F; 非法</span><br><span class="line">        System.out.println(xb.getLegs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>四种访问权限修饰符</p>
<ul>
<li>Java权限修饰符public、protected、(缺省)、private置于 类的成员定义前，用来限定对象对该类成员的访问权限。<br><img src="http://wangzixuan.work/4261" alt=""></li>
<li>对于class的权限修饰只可以用public和default(缺省)。<ul>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。<br><img src="http://wangzixuan.work/4263" alt=""><h4 id="八、类的成员之三：构造器"><a href="#八、类的成员之三：构造器" class="headerlink" title="八、类的成员之三：构造器"></a>八、类的成员之三：构造器</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>构造器的特征</p>
<ul>
<li>它具有与类相同的名称</li>
<li>它不声明返回值类型。（与声明为void不同）</li>
<li>不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值</li>
</ul>
</li>
<li><p>构造器的作用：</p>
<ul>
<li>如：Order o = new Order(); Person p = new Person(“Peter”,15);</li>
<li>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。</li>
</ul>
</li>
<li><p>格式</p>
<ul>
<li><p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 类名 (参数列表) &#123;</span><br><span class="line">    初始化语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>举例：创建Animal 类的实例：Animal a = new Animal();调用构造器，将legs初始化为4。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    private int legs;</span><br><span class="line">    &#x2F;&#x2F; 构造器</span><br><span class="line">    public Animal() &#123;</span><br><span class="line">        legs &#x3D; 4;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLegs(int i) &#123;</span><br><span class="line">        legs &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getLegs() &#123;</span><br><span class="line">        return legs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>根据参数不同，构造器可以分为如下两类：<ul>
<li>隐式无参构造器（系统默认提供）</li>
<li>显式定义一个或多个</li>
</ul>
</li>
<li>注 意：<ul>
<li>Java 语言中，每个类都至少有一个构造器</li>
<li>默认构造器的修饰符与所属类的修饰符一致</li>
<li>一旦显式定义了构造器，则系统不再提供默认构造</li>
<li>一个类可以创建多个重载的构造器</li>
<li>父类的构造器不可被子类继承</li>
</ul>
</li>
</ul>
</li>
<li><p>构造器重载</p>
<ul>
<li><p>构造器一般用来创建对象的同时初始化对象。如</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Person(String n , int a)&#123; </span><br><span class="line">        name&#x3D;n;</span><br><span class="line">        age&#x3D;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    public Person(String name, int age, Date d) &#123;this(name,age);…&#125;</span><br><span class="line">    public Person(String name, int age) &#123;…&#125;</span><br><span class="line">    public Person(String name, Date d) &#123;…&#125;</span><br><span class="line">    public Person()&#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器重载，参数列表必须不同</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Date birthDate;</span><br><span class="line">    public Person(String n, int a, Date d) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">        age &#x3D; a;</span><br><span class="line">        birthDate &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String n, int a) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">        age &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String n, Date d) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">        birthDate &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String n) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">        age &#x3D; 30;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>总结：属性赋值过程</p>
<ul>
<li>截止到目前，我们讲到了很多位置都可以对类的属性赋值。现总结这几个位置，并指明赋值的先后顺序。</li>
<li>赋值的位置：<ul>
<li>①默认初始化</li>
<li>②显式初始化</li>
<li>③构造器中初始化</li>
<li>④通过“对象.属性“或“对象.方法”的方式赋值</li>
</ul>
</li>
<li>赋值的先后顺序：<ul>
<li>① - ② - ③ - ④</li>
</ul>
</li>
</ul>
</li>
<li><p>拓展知识：JavaBean</p>
<ul>
<li><p>JavaBean是一种Java语言写成的可重用组件。</p>
</li>
<li><p>所谓javaBean，是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
</li>
<li><p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</p>
</li>
<li><p>JavaBean示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JavaBean &#123;</span><br><span class="line">    private String name; &#x2F;&#x2F; 属性一般定义为private</span><br><span class="line">    private int age;</span><br><span class="line">    public JavaBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int a) &#123;</span><br><span class="line">        age &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String n) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>拓展知识：UML类图<br> <img src="http://wangzixuan.work/4373" alt=""></p>
<h4 id="九、关键字：this"><a href="#九、关键字：this" class="headerlink" title="九、关键字：this"></a>九、关键字：this</h4></li>
<li><p>this 是什么？</p>
<ul>
<li>在Java中，this关键字比较难理解，它的作用和其词义很接近。<ul>
<li>它在方法内部使用，即这个方法所属对象的引用；</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
</ul>
</li>
<li>this 可以调用类的属性、方法和构造器</li>
<li>什么时候使用this关键字呢？<ul>
<li>当在方法内需要用到调用该方法的对象时，就用this。</li>
<li>具体的：我们可以用this来区分属性和局部变量。</li>
<li>比如：this.name = name;</li>
</ul>
</li>
</ul>
</li>
<li><p>使用规则</p>
<ul>
<li>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性。不过，通常我们都习惯省略this。</li>
<li>当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量</li>
<li>使用this访问属性和方法时，如果在本类中未找到，会从父类中查找</li>
<li>this可以作为一个类中构造器相互调用的特殊格式</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！</li>
<li>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器</li>
<li>如果一个类中声明了n个构造器，则最多有n-1个构造器中使用了”this(形参列表)”</li>
<li>“this(形参列表)”必须声明在类的构造器的首行！</li>
<li>在类的一个构造器中，最多只能声明一个”this(形参列表)”</li>
</ul>
</li>
<li><p>使用this，调用属性、方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123; &#x2F;&#x2F; 定义Person类</span><br><span class="line">    private String name ;</span><br><span class="line">    private int age ;</span><br><span class="line">    public Person(String name,int age)&#123;</span><br><span class="line">        this.name &#x3D; name ;</span><br><span class="line">        this.age &#x3D; age ; </span><br><span class="line">    &#125;</span><br><span class="line">    public void getInfo()&#123;</span><br><span class="line">        System.out.println(&quot;姓名：&quot; + name) ;</span><br><span class="line">        this.speak();</span><br><span class="line">    &#125;</span><br><span class="line">    public void speak()&#123;</span><br><span class="line">        System.out.println(“年龄：” + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>当前正在操作本方法的对象称为当前对象。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123; &#x2F;&#x2F; 定义Person类</span><br><span class="line">    String name;</span><br><span class="line">    Person(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;&#125;</span><br><span class="line">        public void getInfo()&#123;</span><br><span class="line">        System.out.println(&quot;Person类 --&gt; &quot; + this.name) ;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean compare(Person p)&#123;</span><br><span class="line">        return this.name&#x3D;&#x3D;p.name;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">public class PersonTest&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Person per1 &#x3D; new Person(&quot;张三&quot;) ;</span><br><span class="line">        Person per2 &#x3D; new Person(&quot;李四&quot;) ;</span><br><span class="line">        per1.getInfo() ; &#x2F;&#x2F; 当前调用getInfo()方法的对象是per1</span><br><span class="line">        per2.getInfo() ; &#x2F;&#x2F; 当前调用getInfo()方法的对象是per2</span><br><span class="line">        boolean b &#x3D; per1.compare(per2);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用this调用本类的构造器</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123; &#x2F;&#x2F; 定义Person类</span><br><span class="line">    private String name ;</span><br><span class="line">    private int age ;</span><br><span class="line">    public Person()&#123; &#x2F;&#x2F; 无参构造器</span><br><span class="line">    System.out.println(&quot;新对象实例化&quot;) ;</span><br><span class="line">&#125;</span><br><span class="line">public Person(String name)&#123;</span><br><span class="line">        this(); &#x2F;&#x2F; 调用本类中的无参构造器</span><br><span class="line">        this.name &#x3D; name ;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name,int age)&#123;</span><br><span class="line">        this(name) ; &#x2F;&#x2F; 调用有一个参数的构造器</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;姓名：&quot; + name + &quot;，年龄：&quot; + age ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="十、关键字：package、import"><a href="#十、关键字：package、import" class="headerlink" title="十、关键字：package、import"></a>十、关键字：package、import</h4><ol>
<li><p>关键字—package</p>
<ul>
<li>包的作用：<ul>
<li>包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式</li>
<li>包可以包含类和子包，划分项目层次，便于管理</li>
<li>解决类命名冲突的问题</li>
<li>控制访问权限</li>
</ul>
</li>
</ul>
</li>
<li><p>MVC设计模式</p>
<ul>
<li>MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。<br><img src="http://wangzixuan.work/4499" alt=""></li>
<li>模型层 model 主要处理数据<ul>
<li>数据对象封装 model.bean/domain</li>
<li>数据库操作类 model.dao</li>
<li>数据库 model.db</li>
</ul>
</li>
<li>视图层 view  显示数据<ul>
<li>相关工具类 view.utils</li>
<li>自定义view view.ui</li>
</ul>
</li>
<li>控制层 controller  处理业务逻辑<ul>
<li>应用界面相关 controller.activity</li>
<li>存放fragment controller.fragment</li>
<li>显示列表的适配器 controller.adapter</li>
<li>服务相关的 controller.service</li>
<li>抽取的基类 controller.base</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK 中主要的包介绍</p>
<ul>
<li>java.lang—-包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能</li>
<li>java.net—-包含执行与网络相关的操作的类和接口。</li>
<li>java.io —-包含能提供多种输入/输出功能的类</li>
<li>java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</li>
<li>java.text—-包含了一些java格式化相关的类</li>
<li>java.sql—-包含了java进行JDBC数据库编程的相关类/接口</li>
<li>java.awt—-包含了构成抽象窗口工具集（abstract windowtoolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。(C/S)</li>
</ul>
</li>
<li><p>关键字—import</p>
<ul>
<li><p>为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类(.*)。import语句告诉编译器到哪里去寻找类。</p>
</li>
<li><p>语法格式:     <code>import 包名. 类名</code>;</p>
</li>
<li><p>应用举例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pack1.pack2.Test; &#x2F;&#x2F;import pack1.pack2.*; 表示引入pack1.pack2包中的所有结构</span><br><span class="line">public class PackTest&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Test t &#x3D; new Test(); &#x2F;&#x2F;Test类在在pack1.pack2包 包 中定义</span><br><span class="line">        t.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li>在源文件中使用import显式的导入指定包下的类或接口</li>
<li>声明在包的声明和类的声明之间</li>
<li>如果需要导入多个类或接口，那么就并列显式多个import语句即可</li>
<li>举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</li>
<li>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</li>
<li>如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。</li>
<li>如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。</li>
<li>import static组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>面向对象</tag>
        <tag>面向过程</tag>
        <tag>类和对象</tag>
        <tag>类的成员变量</tag>
        <tag>类的方法</tag>
        <tag>方法重载</tag>
        <tag>类的封装</tag>
        <tag>构造器</tag>
        <tag>关键字this</tag>
        <tag>关键字import</tag>
        <tag>关键字package</tag>
      </tags>
  </entry>
  <entry>
    <title>13.Java基础知识-面向对象编程（中）-方法重写</title>
    <url>/2020/07/31/13-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<h2 id="方法重写-override-overwrite"><a href="#方法重写-override-overwrite" class="headerlink" title="方法重写(override/overwrite)"></a>方法重写(override/overwrite)</h2><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>在子类中可以根据需要对从父类继承的方法进行重写（重置、覆盖）。在执行程序时，子类的方法将覆盖父类的方法。</p>
<h4 id="2-要求"><a href="#2-要求" class="headerlink" title="2. 要求"></a>2. 要求</h4><ul>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限<ul>
<li>子类不能重写父类中声明为private权限的方法</li>
</ul>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常<h4 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h4>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>方法重写</tag>
      </tags>
  </entry>
  <entry>
    <title>14.Java基础知识-四种访问权限修饰符</title>
    <url>/2020/07/31/14-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><h4 id="1-修饰成员变量"><a href="#1-修饰成员变量" class="headerlink" title="1. 修饰成员变量"></a>1. 修饰成员变量</h4><p>Java权限修饰符public、protected、 (缺省)、 private置于 类的成员定义前，用来限定对象对该类成员的访问权限。<br><img src="http://wangzixuan.work/4656" alt="">   </p>
<h4 id="2-修饰类"><a href="#2-修饰类" class="headerlink" title="2. 修饰类"></a>2. 修饰类</h4><p>对于class的权限修饰只可以用public和default(缺省)。</p>
<ul>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>权限修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>15.Java基础知识-面向对象编程（中）-super</title>
    <url>/2020/07/31/15-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89-super/</url>
    <content><![CDATA[<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>在Java类中使用super来调用父类中的指定操作</p>
<h4 id="1-super调用父类结构"><a href="#1-super调用父类结构" class="headerlink" title="1. super调用父类结构"></a>1. super调用父类结构</h4><ul>
<li>super可以访问父类的属性</li>
<li>super可以访问父类的方法</li>
<li>super可以在子类构造器中调用父类构造器<h4 id="2-注意"><a href="#2-注意" class="headerlink" title="2. 注意"></a>2. 注意</h4></li>
<li>子父类中出现同名的成员时，super代表调用的时父类的成员</li>
<li>super的追溯不仅限于直接父类</li>
<li>super代表父类的内存空间的标识，this代表当前类对象的引用<br><img src="http://wangzixuan.work/4727" alt=""><h4 id="3-调用父类构造器"><a href="#3-调用父类构造器" class="headerlink" title="3. 调用父类构造器"></a>3. 调用父类构造器</h4></li>
<li>子类中所有的构造器默认都会访问父类中的空参构造器</li>
<li>当父类中没有空参构造器时，子类的构造器必须通过this（参数列表）或者super（参数列表）调用父类或者父类中相应的构造器。this与super只能二选一，且只能放在构造器的首行</li>
<li>如果子类构造器中既未显式的调用父类或本类的构造器，且父类中没有空参构造器，则编译出错</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>super</tag>
      </tags>
  </entry>
  <entry>
    <title>16.Java基础知识-面向对象编程（中）-子类对象实例化过程</title>
    <url>/2020/07/31/16-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h2><p>子类对象实例化时，会在堆内开辟的新空间里加载自己的属性以及所有父类（直接父类、间接父类）的所有属性。</p>
<h4 id="1-子类对象实例化的流程"><a href="#1-子类对象实例化的流程" class="headerlink" title="1. 子类对象实例化的流程"></a>1. 子类对象实例化的流程</h4><p><img src="http://wangzixuan.work/4747" alt=""></p>
<h4 id="2-加载所有父类属性"><a href="#2-加载所有父类属性" class="headerlink" title="2. 加载所有父类属性"></a>2. 加载所有父类属性</h4><p>通过this(…)或super()或super(…)直接或者间接的调用父类构造器在堆内开辟的新空间里加载及所有父类（直接父类、间接父类）的所有属性<br><img src="http://wangzixuan.work/4751" alt=""></p>
<h4 id="3-所有属性都在子类对象实例化时在对堆内开辟的新空间中"><a href="#3-所有属性都在子类对象实例化时在对堆内开辟的新空间中" class="headerlink" title="3. 所有属性都在子类对象实例化时在对堆内开辟的新空间中"></a>3. 所有属性都在子类对象实例化时在对堆内开辟的新空间中</h4><p><img src="http://wangzixuan.work/4749" alt=""></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>子类对象实例化</tag>
      </tags>
  </entry>
  <entry>
    <title>17.Java基础知识-面向对象编程（中）-多态性</title>
    <url>/2020/07/31/17-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89-%E5%A4%9A%E6%80%81%E6%80%A7/</url>
    <content><![CDATA[<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><h4 id="1-什么是多态性"><a href="#1-什么是多态性" class="headerlink" title="1. 什么是多态性"></a>1. 什么是多态性</h4><p>对象的多态性：父类对象指向子类引用（或子类的对象赋给父类的引用）（可以直接应用在抽象类和接口上）</p>
<h4 id="2-多态的使用："><a href="#2-多态的使用：" class="headerlink" title="2. 多态的使用："></a>2. 多态的使用：</h4><ul>
<li>父类对象指向子类引用</li>
<li>多态作用<ul>
<li>提高了代码的通用性，常称作接口重用</li>
</ul>
</li>
<li>使用前提：① 类的继承关系② 方法的重写</li>
<li>对象的多态性<ul>
<li>只适用于方法（编译，看左边；运行，看右边。）</li>
<li>不适用于属性（编译和运行都看左边）</li>
</ul>
</li>
<li>成员方法：<ul>
<li>编译时：要查看引用变量所声明的类中是否有所调用的方法。</li>
<li>运行时：调用实际new的对象所属的类中的重写方法。</li>
</ul>
</li>
<li>成员变量：<ul>
<li>不具备多态性，只看引用变量所声明的类。</li>
</ul>
</li>
</ul>
<h4 id="3-虚拟方法调用-Virtual-Method-Invocation"><a href="#3-虚拟方法调用-Virtual-Method-Invocation" class="headerlink" title="3. 虚拟方法调用(Virtual Method Invocation)"></a>3. 虚拟方法调用(Virtual Method Invocation)</h4><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p>
<p>总结：编译，看左边；运行，看右边。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;正常的方法调用</span><br><span class="line">Person e &#x3D; new Person();</span><br><span class="line">e.getInfo();</span><br><span class="line">Student e &#x3D; new Student();</span><br><span class="line">e.getInfo();</span><br><span class="line">&#x2F;&#x2F;虚拟方法调用( 多态情况下)</span><br><span class="line">Person e &#x3D; new Student();</span><br><span class="line">e.getInfo(); &#x2F;&#x2F; 调用Student 类的getInfo() 方法</span><br></pre></td></tr></table></figure>

<ul>
<li>虚拟方法调用( 多态情况下)<br>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</li>
<li>编译时类型和运行时类型<br>编译时e 为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo() 方法。——动态绑定<h4 id="4-Java引用变量的两个类型"><a href="#4-Java引用变量的两个类型" class="headerlink" title="4. Java引用变量的两个类型"></a>4. Java引用变量的两个类型</h4>编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。</li>
<li>若编译时类型和运行时类型不一致，就出现了对象的多态性 (Polymorphism)</li>
<li>多态情况下<ul>
<li>“看左边”：看的是父类的引用（父类中不具备子类特有的方法）</li>
<li>“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）<h4 id="5-对象的多态"><a href="#5-对象的多态" class="headerlink" title="5. 对象的多态"></a>5. 对象的多态</h4>在Java中,子类的对象可以替代父类的对象使用</li>
</ul>
</li>
<li>一个变量只能有一种确定的数据类型</li>
<li>一个引用类型变量可能指向(引用)多种不同类型的对象</li>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p &#x3D; new Student();</span><br><span class="line">Object o &#x3D; new Person();&#x2F;&#x2F;Object类型的变量o，指向Person类型的对象</span><br><span class="line">o &#x3D; new Student(); &#x2F;&#x2F;Object类型的变量o，指向Student类型的对象</span><br></pre></td></tr></table></figure>
<ul>
<li>这里子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向型上转型(upcasting)。<h4 id="6-多态不适用于属性"><a href="#6-多态不适用于属性" class="headerlink" title="6. 多态不适用于属性"></a>6. 多态不适用于属性</h4>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student m &#x3D; new Student();</span><br><span class="line">m.school &#x3D; “pku”;  &#x2F;&#x2F; 合法,Student 类有school 成员变量</span><br><span class="line">Person e &#x3D; new Student();</span><br><span class="line">e.school &#x3D; “pku”; &#x2F;&#x2F; 非法,Person 类没有school</span><br></pre></td></tr></table></figure>
<p>属性是在编译时确定的，编译时e为Person类型，没有school 成员变量，因而编译错误。</p>
<h4 id="7-面试题"><a href="#7-面试题" class="headerlink" title="7. 面试题"></a>7. 面试题</h4><ul>
<li>谈谈你对多态的理解？<ol>
<li>实现代码的通用性</li>
<li>object类中定义的public boolean equals(Object obj){}</li>
<li>JDBC:使用java程序操作(获取数据库连接、CRUD)数据 库(MySQL、Oracle、DB2、SQL Server)</li>
<li>抽象类、接口的使用肯定体现了多态性。(抽象类、接口不能实例化)</li>
</ol>
</li>
<li>多态时编译时行为还是运行时行为？<ul>
<li>运行时行为</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>多态性</tag>
      </tags>
  </entry>
  <entry>
    <title>18.Java基础知识-面向对象编程（中）-instanceof</title>
    <url>/2020/07/31/18-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89-instanceof/</url>
    <content><![CDATA[<h2 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof  操作符"></a>instanceof  操作符</h2><h4 id="1-使用"><a href="#1-使用" class="headerlink" title="1. 使用"></a>1. 使用</h4><p>x instanceof A </p>
<ul>
<li>检验x是否为类A的对象</li>
<li>返回值为boolean</li>
<li>判断对象x是否属于类A的子类，如果是，返回true；如果不是，返回false。<h4 id="2-要求"><a href="#2-要求" class="headerlink" title="2. 要求"></a>2. 要求</h4></li>
<li>x所属的类与类A必须是子类和父类的关系，否则编译错误。</li>
<li>使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。<h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person extends Object &#123;…&#125;</span><br><span class="line">public class Student extends Person &#123;…&#125;</span><br><span class="line">public class Graduate extends Person &#123;…&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-------------------------------------------------</span><br><span class="line"></span><br><span class="line">public void method1(Person e) &#123;</span><br><span class="line">&#x2F;&#x2F;在多态性的作用下，调用此方法时传入的参数可以时Person和子类Student和子类Graduate</span><br><span class="line">if (e instanceof Person)</span><br><span class="line">&#x2F;&#x2F;  处理Person 类及其子类对象</span><br><span class="line">if (e instanceof Student)</span><br><span class="line">&#x2F;&#x2F; 处理Student 类及其子类对象</span><br><span class="line">if (e instanceof Graduate)</span><br><span class="line">&#x2F;&#x2F; 处理Graduate 类及其子类对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title>19.Java基础知识-面向对象编程（中）-对象类型转换</title>
    <url>/2020/07/31/19-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="对象类型转换-Casting"><a href="#对象类型转换-Casting" class="headerlink" title="对象类型转换 (Casting )"></a>对象类型转换 (Casting )</h2><p><img src="http://wangzixuan.work/4916" alt=""></p>
<h4 id="1-基本数据类型的Casting"><a href="#1-基本数据类型的Casting" class="headerlink" title="1. 基本数据类型的Casting"></a>1. 基本数据类型的Casting</h4><ul>
<li>自动类型转换：小的数据类型可以自动转换成大的数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long g &#x3D; 20;</span><br><span class="line">double d &#x3D; 12.0f;</span><br></pre></td></tr></table></figure>

<ul>
<li>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float f &#x3D; (float)12.0; </span><br><span class="line">int a &#x3D; (int)1200L；</span><br></pre></td></tr></table></figure>

<h4 id="2-对Java对象的强制类型转换称为造型"><a href="#2-对Java对象的强制类型转换称为造型" class="headerlink" title="2. 对Java对象的强制类型转换称为造型"></a>2. 对Java对象的强制类型转换称为造型</h4><ul>
<li>向上转型<ul>
<li>多态：从子类到父类的类型转换</li>
<li>可以自动进行</li>
</ul>
</li>
<li>向下转型<ul>
<li>为什么向下转型？<ul>
<li>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致  编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</li>
</ul>
</li>
<li>从父类到子类的类型转换必须通过造型(强制类型转换) 实现<ul>
<li>强制类型转换符（）</li>
</ul>
</li>
</ul>
</li>
<li>无继承关系的引用类型间的转换是非法的</li>
<li>在造型前可以使用instanceof操作符测试一个对象的类型<ul>
<li>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。如果 a instanceof A返回true,则 a instanceof B也返回true.</li>
</ul>
</li>
</ul>
<h4 id="3-转换举例"><a href="#3-转换举例" class="headerlink" title="3. 转换举例"></a>3. 转换举例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ConversionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double d &#x3D; 13.4;</span><br><span class="line">        long l &#x3D; (long) d;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        int in &#x3D; 5;</span><br><span class="line">        &#x2F;&#x2F; boolean b &#x3D; (boolean)in;</span><br><span class="line">        Object obj &#x3D; &quot;Hello&quot;;</span><br><span class="line">        String objStr &#x3D; (String) obj;</span><br><span class="line">        System.out.println(objStr);</span><br><span class="line">        Object objPri &#x3D; new Integer(5);</span><br><span class="line">        &#x2F;&#x2F; 所以下面代码运行时引发ClassCastException异常</span><br><span class="line">        String str &#x3D; (String) objPri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    &#x2F;&#x2F;向上转型，多态性，传进来的e可以时Person类型及其子类</span><br><span class="line">    public void method(Person e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设Person类中没有getschool() 方法</span><br><span class="line">        &#x2F;&#x2F; System.out.pritnln(e.getschool()); &#x2F;&#x2F;非法,编译时错误</span><br><span class="line">        if (e instanceof Student) &#123;</span><br><span class="line">            &#x2F;&#x2F;向下转型，强制转换</span><br><span class="line">            Student me &#x3D; (Student) e; &#x2F;&#x2F; 将e强制转换为Student类型</span><br><span class="line">            System.out.pritnln(me.getschool());</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args)&#123;</span><br><span class="line">        Test t &#x3D; new Test();</span><br><span class="line">        Student m &#x3D; new Student();</span><br><span class="line">        t.method(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>对象类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>21.Java基础知识-Object类-equals与==</title>
    <url>/2020/07/31/21-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Object%E7%B1%BB-equals%E4%B8%8E/</url>
    <content><![CDATA[<h2 id="操作符与equals-方法"><a href="#操作符与equals-方法" class="headerlink" title="== 操作符与equals 方法"></a>== 操作符与equals 方法</h2><h4 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1. == 操作符"></a>1. == 操作符</h4><ul>
<li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</li>
<li>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</li>
<li>== 符号使用时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错</li>
</ul>
<h4 id="2-equals-方法"><a href="#2-equals-方法" class="headerlink" title="2. equals() 方法"></a>2. equals() 方法</h4><ul>
<li><p>equals() ：所有类都继承了Object，了也就获得了equals() 方法 。 还可以重写 。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Object类中equals()的定义</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特例 ：当用equals() 方法进行比较时 ，对类File 、String 、Date 及包装类（Wrapper Class）来说，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同</p>
<ul>
<li>原因：在这些类中重写了Object 类的equals() 方法</li>
</ul>
</li>
<li><p>当自定义equals()时，可以重写。通常用于比较两个对象的“ 内容 ”是否都相等</p>
</li>
<li><p>重写equals() 方法的原则</p>
<ul>
<li>对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”</li>
<li>自反性：x.equals(x)必须返回是“true”</li>
<li>传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”</li>
<li>一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”</li>
<li>任何情况下，x.equals(null)，永远返回是“false”</li>
<li>x.equals(和x不同类型的对象)永远返回是“false”</li>
</ul>
</li>
<li><p>手动重写举例（全部代码见页面底部）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重写的原则：比较两个对象的实体内容(即：name和age)是否相同</span><br><span class="line">&#x2F;&#x2F;手动实现equals()的重写</span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">	</span><br><span class="line">	System.out.println(&quot;Customer equals()....&quot;);</span><br><span class="line">	if (this &#x3D;&#x3D; obj) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	if(obj instanceof Customer)&#123;</span><br><span class="line">		Customer cust &#x3D; (Customer)obj;</span><br><span class="line">		&#x2F;&#x2F;比较两个对象的每个属性是否都相同</span><br><span class="line">		if(this.age &#x3D;&#x3D; cust.age &amp;&amp; this.name.equals(cust.name))&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;或</span><br><span class="line">		return this.age &#x3D;&#x3D; cust.age &amp;&amp; this.name.equals(cust.name);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		return false;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="3-面试题：-和equals的区别"><a href="#3-面试题：-和equals的区别" class="headerlink" title="3. 面试题：== 和equals的区别"></a>3. 面试题：== 和equals的区别</h4><ul>
<li>==  既可以比较基本类型也可以比较引用类型<ul>
<li>对于基本类型就是比较值</li>
<li>对于引用类型就是比较内存地址</li>
</ul>
</li>
<li>equals 的话，它是属于java.lang.Object类里面的方法<ul>
<li>如果该方法没有被重写过默认也是==</li>
<li>我们可以到看到String等类的equals方法是被重写过的</li>
<li>而且String 类在日常开发中了用的比较多，久而久之，形成了equals</li>
</ul>
</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等</li>
</ul>
<h4 id="4-代码举例"><a href="#4-代码举例" class="headerlink" title="4 代码举例"></a>4 代码举例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Customer &#123;</span><br><span class="line">	</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAge(int age) &#123;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	public Customer() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	public Customer(String name, int age) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;自动生成的equals()</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		if (this &#x3D;&#x3D; obj)</span><br><span class="line">			return true;</span><br><span class="line">		if (obj &#x3D;&#x3D; null)</span><br><span class="line">			return false;</span><br><span class="line">		if (getClass() !&#x3D; obj.getClass())</span><br><span class="line">			return false;</span><br><span class="line">		Customer other &#x3D; (Customer) obj;</span><br><span class="line">		if (age !&#x3D; other.age)</span><br><span class="line">			return false;</span><br><span class="line">		if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">			if (other.name !&#x3D; null)</span><br><span class="line">				return false;</span><br><span class="line">		&#125; else if (!name.equals(other.name))</span><br><span class="line">			return false;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;重写的原则：比较两个对象的实体内容(即：name和age)是否相同</span><br><span class="line">	&#x2F;&#x2F;手动实现equals()的重写</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;Customer equals()....&quot;);</span><br><span class="line">		if (this &#x3D;&#x3D; obj) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		if(obj instanceof Customer)&#123;</span><br><span class="line">			Customer cust &#x3D; (Customer)obj;</span><br><span class="line">			&#x2F;&#x2F;比较两个对象的每个属性是否都相同</span><br><span class="line">			if(this.age &#x3D;&#x3D; cust.age &amp;&amp; this.name.equals(cust.name))&#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;或</span><br><span class="line">			return this.age &#x3D;&#x3D; cust.age &amp;&amp; this.name.equals(cust.name);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return false;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>继承性</tag>
      </tags>
  </entry>
  <entry>
    <title>20.Java基础知识-Object类</title>
    <url>/2020/07/31/20-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Object%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Object-类的使用"><a href="#Object-类的使用" class="headerlink" title="Object  类的使用"></a>Object  类的使用</h2><h4 id="1-Object类是什么？"><a href="#1-Object类是什么？" class="headerlink" title="1. Object类是什么？"></a>1. Object类是什么？</h4><p>Object类是所有Java类的根父类</p>
<h4 id="2-默认父类"><a href="#2-默认父类" class="headerlink" title="2. 默认父类"></a>2. 默认父类</h4><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">public class Person extends Object &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-作为参数"><a href="#3-作为参数" class="headerlink" title="3. 作为参数"></a>3. 作为参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method(Object obj)&#123;…&#125;</span><br></pre></td></tr></table></figure>

<p>Object类型作为方法的参数，方法可以接收任何类作为其参数使用</p>
<h4 id="4-Object-类中的主要结构"><a href="#4-Object-类中的主要结构" class="headerlink" title="4. Object 类中的主要结构"></a>4. Object 类中的主要结构</h4><ul>
<li>属性：无</li>
<li>构造器：Object类只声明了一个空参的构造器</li>
<li>方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()<br>wait() 、 notify()、notifyAll()<br><img src="http://wangzixuan.work/4949" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Object类</tag>
      </tags>
  </entry>
  <entry>
    <title>22.Java基础知识-Object类-toString()</title>
    <url>/2020/07/31/22-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Object%E7%B1%BB-toString/</url>
    <content><![CDATA[<h2 id="Object类中toString"><a href="#Object类中toString" class="headerlink" title="Object类中toString()"></a>Object类中toString()</h2><h4 id="1-toString"><a href="#1-toString" class="headerlink" title="1. toString()"></a>1. toString()</h4><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p>
<h4 id="2-Object类中toString-的定义"><a href="#2-Object类中toString-的定义" class="headerlink" title="2. Object类中toString()的定义"></a>2. Object类中toString()的定义</h4><ul>
<li>toString() 方法在Object 类中定义 </li>
<li>返回值是String 类型</li>
<li>返回类名和它的引用地址。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-toString-的调用"><a href="#3-toString-的调用" class="headerlink" title="3. toString()的调用"></a>3. toString()的调用</h4><ul>
<li><p>在行 进行String 与其它类型数据的连接操作时 ，用 自动调用toString()</p>
</li>
<li><p>如果对象为空，直接打印对象（由于print方法里边判断了对象是否为空）输出null，toString()则报空指针异常</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date now&#x3D;new Date();</span><br><span class="line">System.out.println(“now&#x3D;”+now);  相当于</span><br><span class="line">System.out.println(“now&#x3D;”+now.toString());</span><br><span class="line"></span><br><span class="line">String s &#x3D; &quot;abc&quot;;</span><br><span class="line">s &#x3D; null;</span><br><span class="line">System.out.println(s);&#x2F;&#x2F;null</span><br><span class="line">System.out.println(&quot;*********&quot;);</span><br><span class="line">System.out.println(s.toString());&#x2F;&#x2F;出现NullPointerException</span><br></pre></td></tr></table></figure>

<ul>
<li>基本类型数据转换为String类型时，调用了对应包装类的toString()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a&#x3D;10;</span><br><span class="line">System.out.println(“a&#x3D;”+a);</span><br></pre></td></tr></table></figure>


<h4 id="4-包装类toString-的重写"><a href="#4-包装类toString-的重写" class="headerlink" title="4. 包装类toString()的重写"></a>4. 包装类toString()的重写</h4><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1&#x3D;“hello”;</span><br><span class="line">System.out.println(s1);</span><br></pre></td></tr></table></figure>

<h4 id="5-自定义类toString-的重写"><a href="#5-自定义类toString-的重写" class="headerlink" title="5. 自定义类toString()的重写"></a>5. 自定义类toString()的重写</h4><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p>
<h4 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6. 面试题"></a>6. 面试题</h4><ul>
<li>问题：为什么打印char型数组的结果不是类型+地址，而是字符串</li>
<li>原因：char对应的包装类Character重写了toString()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char[] arr &#x3D; new char[] &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125;;</span><br><span class="line">System.out.println(arr);&#x2F;&#x2F;abc</span><br><span class="line"></span><br><span class="line">int[] arr1 &#x3D; new int[] &#123; 1, 2, 3 &#125;;</span><br><span class="line">System.out.println(arr1);&#x2F;&#x2F;[I@3d4eac69</span><br><span class="line"></span><br><span class="line">double[] arr2 &#x3D; new double[] &#123; 1.1, 2.2, 3.3 &#125;;</span><br><span class="line">System.out.println(arr2);&#x2F;&#x2F;[D@42a57993</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>toString（）</tag>
      </tags>
  </entry>
  <entry>
    <title>23.Java基础知识-包装类</title>
    <url>/2020/07/31/23-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h4 id="1-包装类是什么？"><a href="#1-包装类是什么？" class="headerlink" title="1. 包装类是什么？"></a>1. 包装类是什么？</h4><ul>
<li><p>针对八种基本数据类型定义相应的引用类型—包装类（封装类）</p>
<h4 id="2-包装类的作用"><a href="#2-包装类的作用" class="headerlink" title="2. 包装类的作用"></a>2. 包装类的作用</h4></li>
<li><p>java提供了8种基本数据类型对应的包装类</p>
</li>
<li><p>使得基本数据类型的变量具有类的特征</p>
</li>
<li><p>有了类的特点，就可以调用类中的方法</p>
</li>
<li><p>Java才是真正的面向对象</p>
<h4 id="3-基本数据类型与包装类的对应"><a href="#3-基本数据类型与包装类的对应" class="headerlink" title="3. 基本数据类型与包装类的对应"></a>3. 基本数据类型与包装类的对应</h4><p><img src="http://wangzixuan.work/5105" alt=""></p>
<h4 id="4-包装类的使用"><a href="#4-包装类的使用" class="headerlink" title="4. 包装类的使用"></a>4. 包装类的使用</h4></li>
<li><p>装箱：基本数据类型包装成包装类的实例</p>
<ul>
<li><p>通过包装类的构造器实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; 500; </span><br><span class="line">Integer t &#x3D; new Integer(i);</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以通过字符串参数构造包装类对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;字符串只保函数值</span><br><span class="line">Float f &#x3D; new Float(“4.56”);</span><br><span class="line">Long l &#x3D; new Long(“asdf”); &#x2F;&#x2F;报异常NumberFormatException</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>拆箱：获得包装类对象中包装的基本类型变量</p>
<ul>
<li><p>调用包装类的.xxxValue()方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean b &#x3D; bObj.booleanValue();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自动装箱：基本数据类型 ---&gt;包装类</span><br><span class="line">int num2 &#x3D; 10;</span><br><span class="line">Integer in1 &#x3D; num2;&#x2F;&#x2F;自动装箱</span><br><span class="line"></span><br><span class="line">boolean b1 &#x3D; true;</span><br><span class="line">Boolean b2 &#x3D; b1;&#x2F;&#x2F;自动装箱</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自动拆箱：包装类---&gt;基本数据类型</span><br><span class="line">System.out.println(in1.toString());</span><br><span class="line"></span><br><span class="line">int num3 &#x3D; in1;&#x2F;&#x2F;自动拆箱</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-基本类型、包装类与String-类间的转换"><a href="#5-基本类型、包装类与String-类间的转换" class="headerlink" title="5. 基本类型、包装类与String 类间的转换"></a>5. 基本类型、包装类与String 类间的转换</h4><ul>
<li><p>字符串转换成基本数据类型</p>
<ul>
<li><p>通过包装类的构造器实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; new Integer(“12”);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过包装类的parseXxx(String s)静态方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Float f &#x3D; Float.parseFloat(“12.1”);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>基本数据类型转换成字符串</p>
<ul>
<li><p>调用字符串重载的valueOf()方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String fstr &#x3D; String.valueOf(2.34f);</span><br></pre></td></tr></table></figure>
</li>
<li><p>更直接的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String intStr &#x3D; 5 + “”</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><img src="http://wangzixuan.work/5148" alt=""></p>
<ul>
<li>简易版<ul>
<li>基本数据类型&lt;—&gt;包装类:JDK5.0新特性:自动装箱与自动拆箱</li>
<li>基本数据类型、包装类—&gt;String:调用String重载的value0f(Xxx xxx)</li>
<li>String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)</li>
<li>注意:转换时，可能会报NumberFormatException</li>
</ul>
</li>
</ul>
<h4 id="6-包装类用法举例"><a href="#6-包装类用法举例" class="headerlink" title="6. 包装类用法举例"></a>6. 包装类用法举例</h4><ul>
<li><p>装箱：包装类使得一个基本数据类型的数据变成了类。</p>
<ul>
<li><p>有了类的特点，可以调用类中的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i &#x3D; 500;</span><br><span class="line">Integer t &#x3D; new Integer(i);</span><br><span class="line"></span><br><span class="line">String s &#x3D; t.toString(); &#x2F;&#x2F; s &#x3D; “500“,t是类，有toString方法</span><br><span class="line">String s1 &#x3D; Integer.toString(314); &#x2F;&#x2F; s1&#x3D; “314“ 将数字转换成字符串。</span><br><span class="line"></span><br><span class="line">String s2&#x3D;“4.56”;</span><br><span class="line">double ds&#x3D;Double.parseDouble(s2); &#x2F;&#x2F;将字符串转换成数字</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>拆箱：将数字包装类中内容变为基本数据类型。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int j &#x3D; t.intValue(); &#x2F;&#x2F; j &#x3D; 500，intValue取出包装类中的数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>包装类在实际开发中用的最多的在于字符串变为基本数据类型。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str1 &#x3D; &quot;30&quot; ;</span><br><span class="line">String str2 &#x3D; &quot;30.3&quot; ;</span><br><span class="line">int x &#x3D; Integer.parseInt(str1) ; &#x2F;&#x2F; 将字符串变为int型</span><br><span class="line">float f &#x3D; Float.parseFloat(str2) ; &#x2F;&#x2F; 将字符串变为int型</span><br></pre></td></tr></table></figure>

<h4 id="6-面试题"><a href="#6-面试题" class="headerlink" title="6. 面试题"></a>6. 面试题</h4><ul>
<li><p>如下两个题目输出结果相同吗？各是什么</p>
</li>
<li><p>原因：三目运算符：两边的类型相同，所以int类型的1被自动提升为double类型的1.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object o1 &#x3D; true ? new Integer(1) : new Double(2.0);</span><br><span class="line">System.out.println(o1);&#x2F;&#x2F;1.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object o2;</span><br><span class="line">if (true)</span><br><span class="line">o2 &#x3D; new Integer(1);</span><br><span class="line">else</span><br><span class="line">o2 &#x3D; new Double(2.0);</span><br><span class="line">System.out.println(o2);&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>
</li>
<li><p>写出下面三个输出的值</p>
</li>
<li><p>①原因：</p>
<ul>
<li>i和j都是new出来的，所以比较的是地址值</li>
</ul>
</li>
<li><p>②原因：</p>
<ul>
<li>Integer内部定义了IntegerCache结构</li>
<li>IntegerCache中定义了Integer[],保存了从-128-127范围的整数</li>
<li>如果我们使用自动装箱的方式，给Integer赋值的范围在-128-127范围内时，可以直接使用数组中的元素，不用再去new了</li>
<li>目的：提高效率</li>
<li>没有超出范围、没有new，所以比较的时数值</li>
</ul>
</li>
<li><p>③原因：</p>
<ul>
<li>128超出了IntegerCache中定义的Integer[]保存的从-128-127的范围</li>
<li>超出范围x与y都是new出来的，所以比较的地址值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void method1() &#123;</span><br><span class="line">    Integer i &#x3D; new Integer(1);</span><br><span class="line">    Integer j &#x3D; new Integer(1);</span><br><span class="line">    System.out.println(i &#x3D;&#x3D; j);&#x2F;&#x2F;false</span><br><span class="line">    </span><br><span class="line">    Integer m &#x3D; 1;</span><br><span class="line">    Integer n &#x3D; 1;</span><br><span class="line">    System.out.println(m &#x3D;&#x3D; n);&#x2F;&#x2F;true</span><br><span class="line">    </span><br><span class="line">    Integer x &#x3D; 128;&#x2F;&#x2F;相当于new了一个Integer对象</span><br><span class="line">    Integer y &#x3D; 128;&#x2F;&#x2F;相当于new了一个Integer对象</span><br><span class="line">    System.out.println(x &#x3D;&#x3D; y);&#x2F;&#x2F;false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>包装类</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub&amp;Git基础</title>
    <url>/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-概述与目的"><a href="#1-概述与目的" class="headerlink" title="1.概述与目的"></a>1.概述与目的</h2><ol>
<li><h5 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h5>Git是一个免费、开源的版本控制软件</li>
<li><h5 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h5>版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。（记录文件的所有历史变化、随时可恢复到任何一个历史状态、多人协作开发或修改错误恢复）</li>
<li><h5 id="什么是Github"><a href="#什么是Github" class="headerlink" title="什么是Github"></a>什么是Github</h5>Github是全球最大的社交编程及代码托管网站（<a href="https://github.com/）。" target="_blank" rel="noopener">https://github.com/）。</a><br>Github可以托管各种git库，并提供一个web界面（用户名.github.io/仓库名）</li>
<li><h5 id="Github和Git是什么关系"><a href="#Github和Git是什么关系" class="headerlink" title="Github和Git是什么关系"></a>Github和Git是什么关系</h5>Git是版本控制软件<br>Github是项目代码托管的平台，借助Git来管理项目代码</li>
<li><h5 id="为什么学习github"><a href="#为什么学习github" class="headerlink" title="为什么学习github"></a>为什么学习github</h5>学习优秀的开源项目<br>关注行业前辈了解最新的行业动态<br>借助github托管项目代码</li>
<li><h5 id="简单介绍Git"><a href="#简单介绍Git" class="headerlink" title="简单介绍Git"></a>简单介绍Git</h5>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢?比如说自己在电脑上改了文件A,其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/1.png" class="">
借助Github托管项目代码。<h2 id="2-GitHub基本概念"><a href="#2-GitHub基本概念" class="headerlink" title="2.GitHub基本概念"></a>2.GitHub基本概念</h2></li>
<li><h5 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h5>仓库用来存放项目代码，每个项目对应一个仓库(Repository)，多个开源项目则有多个仓库（Repositories）。</li>
<li><h5 id="复制克隆项目（fork）"><a href="#复制克隆项目（fork）" class="headerlink" title="复制克隆项目（fork）"></a>复制克隆项目（fork）</h5>完全复制别人的项目到自己的GitHub,丝毫不会影响原有项目的代码与结构。fork的项目是独立存在的！</li>
<li><h5 id="发起请求-Pull-Request"><a href="#发起请求-Pull-Request" class="headerlink" title="发起请求(Pull Request)"></a>发起请求(Pull Request)</h5>发起请求，这个其实是基于Fork的。如果你fork了别人的项目并且在其基础上做了改进，后来觉得改进的很不错，应该要把这些改进让更多的人收益，于是就想把自己的改进合并到原有项目里，这个时候你就可以发起一个PullRequest(简称PR)，原有项目创建人就可以收到这个请求，这个时候你会仔细查看他的代码，并且测试觉得ok了，就会接受他的PR,这个时候他做的改进原有项目就会拥有了。</li>
<li><h5 id="事务卡片-Issue"><a href="#事务卡片-Issue" class="headerlink" title="事务卡片(Issue)"></a>事务卡片(Issue)</h5>发现代码BUG，但是目前没有成型代码，需要讨论时用。</li>
</ol>
<p>举个例子，就是你开源了一个项目，别人发现你的项目中有bug,或者哪些地方做的不够好，他就可以给你提个Issue,即问题，提的问题多了，也就是Issues，然后你.看到了这些问题就可以去逐个修复，修复ok了就可以一个个的Close掉。</p>
<h2 id="3-GitHub上创建仓库"><a href="#3-GitHub上创建仓库" class="headerlink" title="3.GitHub上创建仓库"></a>3.GitHub上创建仓库</h2><p>一个git库（仓库）对应一个开源项目</p>
<p>通过git管理git库</p>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/3.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/4.png" class="">
<h2 id="4-GitHub上管理仓库"><a href="#4-GitHub上管理仓库" class="headerlink" title="4.GitHub上管理仓库"></a>4.GitHub上管理仓库</h2><ol>
<li><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/5.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/6.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/7.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/8.png" class=""></li>
<li><h5 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h5><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/9.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/10.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/11.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/12.png" class=""></li>
<li><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5>可在commits按钮查看删除信息<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/9.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/13.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/14.png" class="">
<h2 id="5-在本地使用Git"><a href="#5-在本地使用Git" class="headerlink" title="5.在本地使用Git"></a>5.在本地使用Git</h2><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/15.png" class="">
工作流程：</li>
<li>从远程仓库中克隆 Git 资源作为本地仓库。</li>
<li>从本地仓库中checkout代码然后进行代码修改</li>
<li>在提交前先将代码提交到暂存区。</li>
<li>提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。</li>
<li>在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。</li>
</ol>
<p>下图展示了 Git 的工作流程：</p>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/2.png" class="">
<h5 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Programmingmakesmebald&quot; #名称</span><br><span class="line">git config --global user.email &quot;1731082812@qq.com&quot;   #邮箱</span><br></pre></td></tr></table></figure>
<h5 id="SSH设置"><a href="#SSH设置" class="headerlink" title="SSH设置"></a>SSH设置</h5><p>现在本地生成ssh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 1701082812@qq.com</span><br></pre></td></tr></table></figure>
<p> 一直回车</p>
<p>GitHub上配置：<br>①github②settings③SSH and …④New SSH⑤ title任意⑥key中输入 刚才在本地生成的ssh（<br>将本地刚才生成的id_rsa.pub内容复制到远程的Key中）</p>
<p>测试连通性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果本地和远程成功通信，则可以在 /.ssh目录中 发现known_hosts文件如果失败：多尝试几次、检查回车符</p>
<h5 id="本地仓库初始化代码"><a href="#本地仓库初始化代码" class="headerlink" title="本地仓库初始化代码"></a>本地仓库初始化代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h5 id="在远程建立git项目"><a href="#在远程建立git项目" class="headerlink" title="在远程建立git项目"></a>在远程建立git项目</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①new②建立项目③ 生成  https:&#x2F;&#x2F;github.com&#x2F;Programmingmakesmebald&#x2F;First-GitHub.git</span><br></pre></td></tr></table></figure>

<h5 id="本地项目-远程项目关联"><a href="#本地项目-远程项目关联" class="headerlink" title="本地项目-远程项目关联"></a>本地项目-远程项目关联</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:yanqun&#x2F;mygitremote.git</span><br></pre></td></tr></table></figure>

<h5 id="工作区域（上传文件到Github）"><a href="#工作区域（上传文件到Github）" class="headerlink" title="工作区域（上传文件到Github）"></a>工作区域（上传文件到Github）</h5><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看工作区状态：git status</span><br><span class="line">添加到暂存区  ：git add 文件名.后缀名</span><br><span class="line">提交到本地仓库：git commit -m “提交描述”</span><br><span class="line">上传到远程仓库：git push</span><br></pre></td></tr></table></figure>
<p>第一次发布项目（本地-远程）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .    &#x2F;&#x2F;文件-暂存区.&quot;代表当前目录所有文件</span><br><span class="line">git commit -m “提交描述” &#x2F;&#x2F;暂存区在本地分支（默认master）</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>第一次下载项目（远程-本地）</p>
<p>下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Programmingmakesmebald&#x2F;First-GitHub.git</span><br></pre></td></tr></table></figure>
<p>提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “提交到分支描述”</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>更新（远程-本地）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/16.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/17.png" class="">
<h2 id="6-问题"><a href="#6-问题" class="headerlink" title="6.问题"></a>6.问题</h2><ol>
<li><h5 id="上传时要输入账号密码（私有项目，没有权限）"><a href="#上传时要输入账号密码（私有项目，没有权限）" class="headerlink" title="上传时要输入账号密码（私有项目，没有权限）"></a>上传时要输入账号密码（私有项目，没有权限）</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①在 .git文件 里面找到config 打开</span><br></pre></td></tr></table></figure>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/18.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/19.png" class="">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">②将 [remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;仓库名.git</span><br><span class="line">改为</span><br><span class="line">[remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;用户名:密码@github.com&#x2F;用户名&#x2F;仓库名.git</span><br><span class="line">列</span><br><span class="line">[remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;Rodma1:chenyun123@github.com&#x2F;Rodma1&#x2F;test.git</span><br><span class="line">保存就解决了</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="上传错误-（git-push）"><a href="#上传错误-（git-push）" class="headerlink" title="上传错误 （git push）"></a>上传错误 （git push）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：git pull --rebase origin master</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Git GitHub</category>
      </categories>
      <tags>
        <tag>Git GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客及使用</title>
    <url>/2020/07/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h3><h5 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;blogname&quot;</span><br></pre></td></tr></table></figure>
<h5 id="2-清除"><a href="#2-清除" class="headerlink" title="2. 清除"></a>2. 清除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<h5 id="3-生成"><a href="#3-生成" class="headerlink" title="3. 生成"></a>3. 生成</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h5 id="4-部署"><a href="#4-部署" class="headerlink" title="4. 部署"></a>4. 部署</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><h5 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1. 安装node.js"></a>1. 安装node.js</h5><h5 id="2-安装淘宝的cnpm-管理器"><a href="#2-安装淘宝的cnpm-管理器" class="headerlink" title="2. 安装淘宝的cnpm 管理器"></a>2. 安装淘宝的cnpm 管理器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h5 id="3-安装hexo框架"><a href="#3-安装hexo框架" class="headerlink" title="3. 安装hexo框架"></a>3. 安装hexo框架</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h5 id="4-生成博客-初始化博客"><a href="#4-生成博客-初始化博客" class="headerlink" title="4. 生成博客 初始化博客"></a>4. 生成博客 初始化博客</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h5 id="5-启动本地博客服务"><a href="#5-启动本地博客服务" class="headerlink" title="5. 启动本地博客服务"></a>5. 启动本地博客服务</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h5 id="6-本地访问地址"><a href="#6-本地访问地址" class="headerlink" title="6. 本地访问地址"></a>6. 本地访问地址</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h5 id="1-新建文章-1"><a href="#1-新建文章-1" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;文章名&quot; &#x2F;&#x2F;new</span><br></pre></td></tr></table></figure>
<h5 id="2-新建页面"><a href="#2-新建页面" class="headerlink" title="2. 新建页面"></a>2. 新建页面</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-本地运行-预览"><a href="#3-本地运行-预览" class="headerlink" title="3. 本地运行(预览)"></a>3. 本地运行(预览)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s &#x2F;&#x2F;sever</span><br></pre></td></tr></table></figure>
<h5 id="4-清除缓存"><a href="#4-清除缓存" class="headerlink" title="4. 清除缓存"></a>4. 清除缓存</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo c &#x2F;&#x2F;clean</span><br></pre></td></tr></table></figure>
<h5 id="5-生成"><a href="#5-生成" class="headerlink" title="5. 生成"></a>5. 生成</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &#x2F;&#x2F;generate</span><br></pre></td></tr></table></figure>

<h5 id="6-部署到github"><a href="#6-部署到github" class="headerlink" title="6. 部署到github"></a>6. 部署到github</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d &#x2F;&#x2F;deploy</span><br></pre></td></tr></table></figure>

<h5 id="7-推送到分支"><a href="#7-推送到分支" class="headerlink" title="7. 推送到分支"></a>7. 推送到分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<h3 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h3><h5 id="1-配置-config-yml"><a href="#1-配置-config-yml" class="headerlink" title="1. 配置_config.yml"></a>1. 配置_config.yml</h5><p><img src="http://wangzixuan.work/1687" alt=""></p>
<h5 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2.更换主题"></a>2.更换主题</h5><p><img src="http://wangzixuan.work/1717" alt=""></p>
<h5 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h5><p>解决代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="http://wangzixuan.work/1700" alt=""><br><img src="http://wangzixuan.work/1702" alt=""></p>
<h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><h5 id="hexo主题网站"><a href="#hexo主题网站" class="headerlink" title="hexo主题网站"></a><a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题网站</a></h5><h6 id="进入主题文件"><a href="#进入主题文件" class="headerlink" title="进入主题文件"></a>进入主题文件</h6><p><img src="http://wangzixuan.work/1713" alt=""></p>
<h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Fechin&#x2F;hexo-theme-diaspora.git</span><br></pre></td></tr></table></figure>
<p><img src="http://wangzixuan.work/1726" alt=""></p>
]]></content>
      <categories>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM文件上传</title>
    <url>/2020/07/01/SSM%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="SSM–文件上传"><a href="#SSM–文件上传" class="headerlink" title="SSM–文件上传"></a>SSM–文件上传</h1><h3 id="1-配置（applicationContext-Controller-xml）"><a href="#1-配置（applicationContext-Controller-xml）" class="headerlink" title="1.配置（applicationContext-Controller.xml）"></a>1.配置（applicationContext-Controller.xml）</h3><p>在SpringMVC中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传的配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 上传单个文件的最大值，单位Byte，-1表示无限制 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"104857600"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-编写控制器（Controller）"><a href="#2-编写控制器（Controller）" class="headerlink" title="2.编写控制器（Controller）"></a>2.编写控制器（Controller）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testUpload"</span>)</span><br><span class="line">    <span class="function">String <span class="title">testUpload</span><span class="params">(@RequestParam(<span class="string">"miaoshu"</span>)</span> String desc,@<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"文件描述信息:%s"</span>,desc));</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        InputStream input = file.getInputStream();</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        OutputStream out=<span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1atupian\\"</span>+fileName);</span><br><span class="line">        <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = input.read(bs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.print(String.format(<span class="string">"上传成功!"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-前台上传框（jsp）"><a href="#3-前台上传框（jsp）" class="headerlink" title="3.前台上传框（jsp）"></a>3.前台上传框（jsp）</h3><p>form表单中需要注意的是上传的方式必须为Post  method=”post”</p>
<p>必须加上enctype=”multipart/form-data”属性   enctype=”multipart/form-data”</p>
<p>get的方式地址栏改变将显示文件的内容，若文件过大时地址栏的大小不能够放下该文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文件上传：</span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"controller/testUpload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">                请选择文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line">                文件的描述：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"miaoshu"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>SSM文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>25.Java基础知识-static关键字</title>
    <url>/2020/11/05/25-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="关键字-static"><a href="#关键字-static" class="headerlink" title="关键字:static"></a>关键字:static</h2><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Chinese&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private static String country &#x3D; &quot;中国&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编写一个中国人的类，所有的中国人都有国家名称这个属性，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量空间。所以我们称这个变量为静态变量（类变量），用static修饰。</p>
<h4 id="类属性、类方法的设计思想"><a href="#类属性、类方法的设计思想" class="headerlink" title="类属性、类方法的设计思想"></a>类属性、类方法的设计思想</h4><ul>
<li>类属性作为该类各个对象之间共享的变量。在设计类时，分析哪些属性<strong>不因对象的不同而改变</strong>，将这些属性设置为类属性。</li>
<li>如果方法与调用者无关，则这样的方法通常被声明为类方法，<strong>不需要创建对象就可以通过“类.方法”调用类方法</strong></li>
</ul>
<h4 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h4><ul>
<li>在Java中，可以用static修饰属性、方法、代码块、内部类<h4 id="4-被static修饰的成员具备的特点"><a href="#4-被static修饰的成员具备的特点" class="headerlink" title="4.被static修饰的成员具备的特点"></a>4.被static修饰的成员具备的特点</h4></li>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰类的成员，被所有的对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ul>
<h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><ul>
<li>类变量（类属性）由该类的所有实例共享<br><img src="http://wangzixuan.work/5407" alt=""></li>
<li>应用举例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public static int total &#x3D; 0;</span><br><span class="line">    public Person() &#123;</span><br><span class="line">        total++;</span><br><span class="line">        id &#x3D; total;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Person Tom&#x3D;new Person();</span><br><span class="line">        Tom.id&#x3D;0;</span><br><span class="line">        total&#x3D;100; &#x2F;&#x2F;  不用创建对象就可以访问静态成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StaticDemo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Person.total &#x3D; 100; &#x2F;&#x2F;  不用创建对象就可以访问静态成员</span><br><span class="line">        &#x2F;&#x2F; 访问方式：类名. 类属性 ， 类名. 类方法</span><br><span class="line">        System.out.println(Person.total);</span><br><span class="line">        Person c &#x3D; new Person();</span><br><span class="line">        System.out.println(c.total); &#x2F;&#x2F; 输出101</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><ul>
<li>没有对象的实例时，可以用 类名. 方法名()的形式访问由static修饰的类方法。</li>
<li>在static 方法内部只能访问类的static 修饰的属性或方法， 不能访问类的非static的结构</li>
<li>因为不需要实例就可以访问static 方法，因此static 方法内部不能有this ，也不能有 super。</li>
<li>static修饰的方法不能被重写 </li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>static关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>26.Java基础知识-单例模式</title>
    <url>/2020/11/05/26-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对<br>某个类 只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。<br>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构<br>造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生<br>类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无<br>法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，<br>静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象<br>的变量也必须定义成静态的。</p>
<h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4><p>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的<br>产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可<br>以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方<br>式来解决。</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><h6 id="好处：线程安全。"><a href="#好处：线程安全。" class="headerlink" title="好处：线程安全。"></a>好处：线程安全。</h6><h6 id="坏处：对象加载时间过长。"><a href="#坏处：对象加载时间过长。" class="headerlink" title="坏处：对象加载时间过长。"></a>坏处：对象加载时间过长。</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.私有化构造器</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2.内部提供一个当前类的实例</span><br><span class="line">    &#x2F;&#x2F; 4.此实例也必须静态化</span><br><span class="line">    private static Singleton single &#x3D; new Singleton();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3.提供公共的静态的方法，返回当前类的对象</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><h6 id="好处：延迟对象的创建。"><a href="#好处：延迟对象的创建。" class="headerlink" title="好处：延迟对象的创建。"></a>好处：延迟对象的创建。</h6><h6 id="坏处：线程不安全。"><a href="#坏处：线程不安全。" class="headerlink" title="坏处：线程不安全。"></a>坏处：线程不安全。</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.私有化构造器</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2.内部提供一个当前类的实例</span><br><span class="line">    &#x2F;&#x2F; 4.此实例也必须静态化</span><br><span class="line">    private static Singleton single;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3.提供公共的静态的方法，返回当前类的对象</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(single &#x3D;&#x3D; null) &#123;</span><br><span class="line">            single &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程安全懒汉式"><a href="#线程安全懒汉式" class="headerlink" title="线程安全懒汉式"></a>线程安全懒汉式</h4><h6 id="好处：延迟对象的创建。-1"><a href="#好处：延迟对象的创建。-1" class="headerlink" title="好处：延迟对象的创建。"></a>好处：延迟对象的创建。</h6><h6 id="坏处：线程安全。"><a href="#坏处：线程安全。" class="headerlink" title="坏处：线程安全。"></a>坏处：线程安全。</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.私有化构造器</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2.内部提供一个当前类的实例</span><br><span class="line">    &#x2F;&#x2F; 4.此实例也必须静态化</span><br><span class="line">    private static Singleton single;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3.提供公共的静态的方法，返回当前类的对象</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(single &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(single &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    single &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">更详细的单例模式</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>27.Java基础知识-代码块</title>
    <url>/2020/11/05/27-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
    <content><![CDATA[<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h4 id="代码块的作用"><a href="#代码块的作用" class="headerlink" title="代码块的作用"></a>代码块的作用</h4><p>用来初始化类、对象</p>
<h4 id="代码块的分类"><a href="#代码块的分类" class="headerlink" title="代码块的分类"></a>代码块的分类</h4><h5 id="静态代码块static"><a href="#静态代码块static" class="headerlink" title="静态代码块static"></a>静态代码块static</h5><p>一个类中代码块若有修饰符，则只能被static修饰</p>
<ul>
<li>作用：初始化类的信息</li>
<li>内部可以有输出语句</li>
<li>不可以对非静态的属性初始化，即不可以调用非静态的属性和方法</li>
<li>若有多个静态代码块，按照从上到下的顺序执行</li>
<li>静态代码块的执行要先于非静态代码块</li>
<li>随着类的加载而执行，而且只执行一次</li>
</ul>
<h5 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h5><p>没有使用static修饰</p>
<ul>
<li>作用：在创建对象时，初始化对象的属性</li>
<li>内部可以有输出语句</li>
<li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li>
<li>若有多个非静态代码块，按照声明的顺序执行</li>
<li>随着对象的创建而执行，没创建一个对象，就执行一次非静态代码块</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><h4 id="程序中成员变量赋值的执行顺序"><a href="#程序中成员变量赋值的执行顺序" class="headerlink" title="程序中成员变量赋值的执行顺序"></a>程序中成员变量赋值的执行顺序</h4><ol>
<li>声明成员变量的默认初始化</li>
<li>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</li>
<li>构造器再对成员进行初始化操作</li>
<li>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</li>
</ol>
<h6 id="由父及子，静态先行"><a href="#由父及子，静态先行" class="headerlink" title="由父及子，静态先行"></a>由父及子，静态先行</h6>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>代码块</tag>
      </tags>
  </entry>
  <entry>
    <title>28.Java基础知识-final</title>
    <url>/2020/11/05/28-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-final/</url>
    <content><![CDATA[<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>Java中final可以用来修饰的结构：类、方法、变量,表示“最终的”。</p>
<h4 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h4><h6 id="此类不能被继承"><a href="#此类不能被继承" class="headerlink" title="此类不能被继承"></a>此类不能被继承</h6><p>比如：String类、System类、StringBuffer类</p>
<h4 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h4><h6 id="此方法不可以被重写"><a href="#此方法不可以被重写" class="headerlink" title="此方法不可以被重写"></a>此方法不可以被重写</h6><p>比如：Object类中getClass();</p>
<h4 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h4><h6 id="此时的”变量”就称为是一个常量"><a href="#此时的”变量”就称为是一个常量" class="headerlink" title="此时的”变量”就称为是一个常量"></a>此时的”变量”就称为是一个常量</h6><h5 id="final修饰属性"><a href="#final修饰属性" class="headerlink" title="final修饰属性"></a>final修饰属性</h5><p>可以赋值的位置：</p>
<ul>
<li>显式初始化</li>
<li>代码块中初始化</li>
<li>构造器中初始化</li>
</ul>
<h5 id="final修饰局部变量"><a href="#final修饰局部变量" class="headerlink" title="final修饰局部变量"></a>final修饰局部变量</h5><ul>
<li>final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li>
<li>final修饰方法内部变量，可以在声明时赋值，若声明时没有赋值，以后只能赋值一次。</li>
</ul>
<h4 id="static-final-用来修饰属性：全局常量"><a href="#static-final-用来修饰属性：全局常量" class="headerlink" title="static final 用来修饰属性：全局常量"></a>static final 用来修饰属性：全局常量</h4><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Something &#123;</span><br><span class="line">    public int addOne(final int x) &#123;</span><br><span class="line">        return ++x;</span><br><span class="line">        &#x2F;&#x2F; return x + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return ++x; 报错，<br>++x即为x = x + 1; ，形参x声明为final的只能赋值一次。</p>
<p>return x + 1;不会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Something &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Other o &#x3D; new Other();</span><br><span class="line">        new Something().addOne(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public void addOne(final Other o) &#123;</span><br><span class="line">        &#x2F;&#x2F; o &#x3D; new Other();</span><br><span class="line">        o.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other &#123;</span><br><span class="line">    public int i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法addOne的other类型的形参被声明为final，other类型为引用类型，故传来的为地址值，所以如果new Other() 赋给o就会报错，但是修改o的属性不会改变o的值，不报错。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title>29.Java基础知识-抽象类与抽象方法</title>
    <url>/2020/11/05/29-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<h6 id="abstract：抽象的"><a href="#abstract：抽象的" class="headerlink" title="abstract：抽象的"></a>abstract：抽象的</h6><h6 id="abstract可以修饰的结构：类、方法"><a href="#abstract可以修饰的结构：类、方法" class="headerlink" title="abstract可以修饰的结构：类、方法"></a>abstract可以修饰的结构：类、方法</h6><h6 id="abstract不可以修饰变量、代码块、构造器、私有方法、静态方法、final的方法、final的类"><a href="#abstract不可以修饰变量、代码块、构造器、私有方法、静态方法、final的方法、final的类" class="headerlink" title="abstract不可以修饰变量、代码块、构造器、私有方法、静态方法、final的方法、final的类"></a>abstract不可以修饰变量、代码块、构造器、私有方法、静态方法、final的方法、final的类</h6><h4 id="abstract修饰类：抽象类"><a href="#abstract修饰类：抽象类" class="headerlink" title="abstract修饰类：抽象类"></a>abstract修饰类：抽象类</h4><ul>
<li>此类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化时调用（设计：子类对象实例化的全过程）</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</li>
</ul>
<h4 id="abstract修饰方法：抽象方法"><a href="#abstract修饰方法：抽象方法" class="headerlink" title="abstract修饰方法：抽象方法"></a>abstract修饰方法：抽象方法</h4><ul>
<li>抽象方法只有方法的声明，没有方法体</li>
<li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。</li>
<li>若子类重写了父类所有的抽象方法后，子类方可实例化</li>
<li>若子类没有重写父类中的所有抽象方法，则子类也是一个抽象类，需要使用abstract修饰</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>抽象类与抽象方法</tag>
      </tags>
  </entry>
  <entry>
    <title>30.Java基础知识-接口（interface）</title>
    <url>/2020/11/05/30-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89/</url>
    <content><![CDATA[<h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2><p>接口(interface)是抽象方法和常量值定义的集合。</p>
<h4 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h4><ul>
<li>使用interface来定义</li>
<li>Java中接口和类是并列的两个结构</li>
<li>接口通过让类去实现(implements)的方式来使用<ul>
<li>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</li>
<li>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</li>
</ul>
</li>
<li>一个类可以实现多个接口，接口也可以继承其它接口。</li>
<li>与继承关系类似，接口与实现类之间存在多态性</li>
</ul>
<h4 id="定义接口中的成员"><a href="#定义接口中的成员" class="headerlink" title="定义接口中的成员"></a>定义接口中的成员</h4><ul>
<li>JDK7及以前，只能定义全局常量和抽象方法<ul>
<li>全局常量：public static final的，但是可以省略</li>
<li>抽象方法：public abstract的</li>
</ul>
</li>
<li>JDK8：还可以定义静态方法、默认方法<ul>
<li>静态方法：使用static关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中<br>找到像Collection/Collections或者Path/Paths这样成对的接口和类。</li>
<li>默认方法：默认方法使用default关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认方法。</li>
</ul>
</li>
</ul>
<h4 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h4><ul>
<li>接口中没有构造器<ul>
<li>意味着接口不可以实例化</li>
</ul>
</li>
<li>接口采用多继承机制<ul>
<li>弥补了Java单继承性的局限性</li>
<li>格式：class AA extends BB implements CC,DD,EE</li>
</ul>
</li>
</ul>
<h4 id="接口与抽象类的对比"><a href="#接口与抽象类的对比" class="headerlink" title="接口与抽象类的对比"></a>接口与抽象类的对比</h4><p><img src="http://wangzixuan.work/6730" alt="image"></p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">    &#x2F;&#x2F;接口中只能定义全局常量</span><br><span class="line">    &#x2F;&#x2F;public static final被省略</span><br><span class="line">	int x &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">	int x &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B implements A &#123;</span><br><span class="line">	public void pX() &#123;</span><br><span class="line">		&#x2F;&#x2F;编译不通过。因为x是不明确的</span><br><span class="line">		&#x2F;&#x2F; System.out.println(x);</span><br><span class="line">		System.out.println(super.x);&#x2F;&#x2F;1</span><br><span class="line">		System.out.println(A.x);&#x2F;&#x2F;0</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new C().pX();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pX()方法中不能出现System.out.println(x);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Playable &#123;</span><br><span class="line">	void play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Bounceable &#123;</span><br><span class="line">	void play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Rollable extends Playable,Bounceable </span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;接口中只能定义全局常量</span><br><span class="line">    &#x2F;&#x2F;public static final被省略</span><br><span class="line">	Ball ball &#x3D; new Ball(&quot;PingPang&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Ball implements Rollable &#123;</span><br><span class="line">	</span><br><span class="line">	private String name;</span><br><span class="line">		public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	public Ball(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void play() &#123;</span><br><span class="line">	    &#x2F;&#x2F;ball为public static final 的不能再赋值</span><br><span class="line">	    &#x2F;&#x2F;此处报错</span><br><span class="line">		ball &#x3D; new Ball(&quot;Football&quot;);</span><br><span class="line">		System.out.println(ball.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ball为public static final 的不能再赋值</p>
<h4 id="接口中的默认方法"><a href="#接口中的默认方法" class="headerlink" title="接口中的默认方法"></a>接口中的默认方法</h4><ul>
<li>若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现： <strong>接口冲突</strong>。<ul>
<li>解决办法：实现类必须覆盖接口中同名同参数的方法，来解决冲突。</li>
</ul>
</li>
<li>若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：<strong>类优先原则</strong>。接口中具有相同名称和参数的默认方法会被忽略。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>接口（interface）</tag>
      </tags>
  </entry>
  <entry>
    <title>31.Java基础知识-内部类</title>
    <url>/2020/11/05/31-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>33.Java基础知识-多线程</title>
    <url>/2020/11/05/33-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>当我以为我的代码很安全时，等等。。。<br><img src="http://wangzixuan.work/6888" alt="image"></p>
<h6 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h6><p>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</p>
<h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><p>是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。———生命周期</p>
<ul>
<li>程序是静态的，进程是动态的</li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
<h6 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h6><p>进程可进一步细化为线程，是一个程序内部的一条执行路径。</p>
<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li>
<li>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间→它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</li>
</ul>
<h6 id="并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。"><a href="#并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。" class="headerlink" title="并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。"></a>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</h6><h6 id="并发：一个CPU-采用时间片-同时执行多个任务。比如：秒杀、多个人做同一件事。"><a href="#并发：一个CPU-采用时间片-同时执行多个任务。比如：秒杀、多个人做同一件事。" class="headerlink" title="并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。"></a>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</h6><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><h6 id="Thread"><a href="#Thread" class="headerlink" title="Thread()"></a>Thread()</h6><p>创建新的Thread对象</p>
<h6 id="Thread-String-threadname"><a href="#Thread-String-threadname" class="headerlink" title="Thread(String threadname)"></a>Thread(String threadname)</h6><p>创建线程并指定线程实例名</p>
<h6 id="Thread-Runnable-target"><a href="#Thread-Runnable-target" class="headerlink" title="Thread(Runnable target)"></a>Thread(Runnable target)</h6><p>指定创建线程的目标对象，它实现了Runnable接中的run方法</p>
<h6 id="Thread-Runnable-target-String-name"><a href="#Thread-Runnable-target-String-name" class="headerlink" title="Thread(Runnable target, String name)"></a>Thread(Runnable target, String name)</h6><p>创建新的Thread对象</p>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><h6 id="1-start-启动当前线程；调用当前线程的run"><a href="#1-start-启动当前线程；调用当前线程的run" class="headerlink" title="1. start():启动当前线程；调用当前线程的run()"></a>1. start():启动当前线程；调用当前线程的run()</h6><h6 id="2-run-通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中"><a href="#2-run-通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中" class="headerlink" title="2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中"></a>2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</h6><h6 id="3-currentThread-静态方法，返回执行当前代码的线程"><a href="#3-currentThread-静态方法，返回执行当前代码的线程" class="headerlink" title="3. currentThread():静态方法，返回执行当前代码的线程"></a>3. currentThread():静态方法，返回执行当前代码的线程</h6><h6 id="4-getName-获取当前线程的名字"><a href="#4-getName-获取当前线程的名字" class="headerlink" title="4. getName():获取当前线程的名字"></a>4. getName():获取当前线程的名字</h6><h6 id="5-setName-设置当前线程的名字"><a href="#5-setName-设置当前线程的名字" class="headerlink" title="5. setName():设置当前线程的名字"></a>5. setName():设置当前线程的名字</h6><h6 id="6-yield-释放当前cpu的执行权"><a href="#6-yield-释放当前cpu的执行权" class="headerlink" title="6. yield():释放当前cpu的执行权"></a>6. yield():释放当前cpu的执行权</h6><h6 id="7-join-在线程a中调用线程b的join-此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。"><a href="#7-join-在线程a中调用线程b的join-此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。" class="headerlink" title="7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。"></a>7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</h6><h6 id="8-stop-已过时。当执行此方法时，强制结束当前线程。"><a href="#8-stop-已过时。当执行此方法时，强制结束当前线程。" class="headerlink" title="8. stop():已过时。当执行此方法时，强制结束当前线程。"></a>8. stop():已过时。当执行此方法时，强制结束当前线程。</h6><h6 id="9-sleep-long-millitime-让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。"><a href="#9-sleep-long-millitime-让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。" class="headerlink" title="9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。"></a>9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</h6><h6 id="10-isAlive-判断当前线程是否存活"><a href="#10-isAlive-判断当前线程是否存活" class="headerlink" title="10. isAlive():判断当前线程是否存活"></a>10. isAlive():判断当前线程是否存活</h6><h5 id="Java-的线程的调度"><a href="#Java-的线程的调度" class="headerlink" title="Java 的线程的调度"></a>Java 的线程的调度</h5><ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<h5 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h5><h6 id="线程的优先等级"><a href="#线程的优先等级" class="headerlink" title="线程的优先等级"></a>线程的优先等级</h6><ul>
<li><p>MAX_PRIORITY：10</p>
</li>
<li><p>MIN _PRIORITY：1</p>
</li>
<li><p>NORM_PRIORITY：5  –&gt; 默认优先级</p>
</li>
</ul>
<h6 id="如何获取和设置当前线程的优先级："><a href="#如何获取和设置当前线程的优先级：" class="headerlink" title="如何获取和设置当前线程的优先级："></a>如何获取和设置当前线程的优先级：</h6><ul>
<li><p>getPriority():获取线程的优先级</p>
</li>
<li><p>setPriority(int p):设置线程的优先级</p>
</li>
</ul>
<h6 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h6><ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
</ul>
<h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><ul>
<li>JDK1.5之前创建新执行线程的种方法：<ul>
<li>继承Thread类的方式</li>
<li>实现Runnable接口的方式</li>
</ul>
</li>
<li>JDK1.5之后创建新执行线程的两种方法：<ul>
<li>实现Callable</li>
<li>使用线程池</li>
</ul>
</li>
</ul>
<h4 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h4><ol>
<li>直接调用run()方法，那么就只是普通方法，没有启动多线程模式。</li>
<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li>
<li>想要启动多线程，必须调用start()方法。</li>
<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以下的异常“IllegalThreadStateException”。</li>
</ol>
<h5 id="方式一：-继承Thread类"><a href="#方式一：-继承Thread类" class="headerlink" title="方式一： 继承Thread类"></a>方式一： 继承Thread类</h5><ul>
<li>定义子类继承Thread类。</li>
<li>子类中重写Thread类中的run方法。</li>
<li>创建Thread子类对象，即创建了线程对象。</li>
<li>调用线程对象start方法：启动线程，调用run方法。</li>
</ul>
<h5 id="方式二：实现Runnable"><a href="#方式二：实现Runnable" class="headerlink" title="方式二：实现Runnable"></a>方式二：实现Runnable</h5><ul>
<li>定义子类，实现Runnable接口。</li>
<li>子类中重写Runnable接口中的run方法。</li>
<li>通过Thread类含参构造器创建线程对象。</li>
<li>将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。</li>
<li>调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</li>
</ul>
<h5 id="继承与实现的联系"><a href="#继承与实现的联系" class="headerlink" title="继承与实现的联系"></a>继承与实现的联系</h5><p>Thread类实现了Runnable接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Thread implements Runnable</span><br></pre></td></tr></table></figure>


<h5 id="继承与实现的对比"><a href="#继承与实现的对比" class="headerlink" title="继承与实现的对比"></a>继承与实现的对比</h5><h6 id="相同："><a href="#相同：" class="headerlink" title="相同："></a>相同：</h6><p>两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p>
<h6 id="开发中："><a href="#开发中：" class="headerlink" title="开发中："></a>开发中：</h6><p>优先选择–&gt;实现Runnable接口的方式</p>
<h6 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h6><ol>
<li>实现的方式没有类的单继承性的局限性</li>
<li>实现的方式更适合来处理多个线程有共享数据的情况。</li>
</ol>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p><img src="http://wangzixuan.work/6986" alt="image"></p>
<ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建<br>状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已<br>具备了运行的条件，只是没分配到CPU资源</li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线<br>程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中<br>止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<h4 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h4><h5 id="同步锁机制"><a href="#同步锁机制" class="headerlink" title="同步锁机制"></a>同步锁机制</h5><p>对于多用户访问的共同资源，在第一个用户访问时，锁定资源，使其他用户在资源解锁之前无法访问，在第一个用户使用完，解锁资源后，其下一个用户可以锁定应使用该资源。</p>
<h5 id="锁的使用顺序"><a href="#锁的使用顺序" class="headerlink" title="锁的使用顺序"></a>锁的使用顺序</h5><p>Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt; 同步方法<br>（在方法体之外）</p>
<h5 id="如何确定需要加同步锁的代码？"><a href="#如何确定需要加同步锁的代码？" class="headerlink" title="如何确定需要加同步锁的代码？"></a>如何确定需要加同步锁的代码？</h5><ol>
<li>如何找问题 ， 即代码是否存在线程安全 ？ （ 非常重要 ）</li>
</ol>
<ul>
<li>明确哪些代码是多线程运行的代码</li>
<li>明确多个线程是否有共享数据</li>
<li>明确多线程运行代码中是否有多条语句操作共享数据</li>
</ul>
<ol start="2">
<li>如何解决呢 ？ （ 非常重要 ）</li>
</ol>
<ul>
<li>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其<br>他线程不可以参与执行。</li>
<li>即所有操作共享数据的这些语句都要放在同步范围中</li>
</ul>
<ol start="3">
<li>切记 </li>
</ol>
<ul>
<li>范围太小：没锁住所有有安全问题的代码</li>
<li>范围太大：没发挥多线程的功能。</li>
</ul>
<h5 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h5><h6 id="synchronize的锁"><a href="#synchronize的锁" class="headerlink" title="synchronize的锁"></a>synchronize的锁</h6><ul>
<li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。</li>
<li>必须确保使用同一个资源的<strong>多个线程共用一把锁</strong>，这个非常重要，否则就无法保证共享资源的安全</li>
<li>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）</li>
</ul>
<h6 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h6><p>同步代码块：自己指定，很多时候也是指定为this或类名.class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized ( 对象)&#123;</span><br><span class="line">    &#x2F;&#x2F;  需要被同步的代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h6><p>同步方法的锁：静态方法（类名.class）、非静态方法（this）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void show (String name)&#123;</span><br><span class="line">    ….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h5><ul>
<li>当前线程的同步方法、同步代码块执行结束。</li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li>
</ul>
<h5 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a>不会释放锁的操作</h5><ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。</li>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
<h5 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock(锁)"></a>Lock(锁)</h5><ul>
<li>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li>ReentrantLock类实现了Lock，它拥有与synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    private final ReentrantLock lock &#x3D; new ReenTrantLock();</span><br><span class="line">    public void m()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            &#x2F;&#x2F; 保证线程安全的代码;</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h5><table>
<thead>
<tr>
<th>synchronized</th>
<th>lock</th>
</tr>
</thead>
<tbody><tr>
<td>隐式锁</td>
<td>显示锁</td>
</tr>
<tr>
<td>出了作用域自动释放</td>
<td>手动开锁和关锁</td>
</tr>
<tr>
<td>代码块锁和方法锁</td>
<td>代码块锁</td>
</tr>
<tr>
<td>无</td>
<td>JVM将花费较少的时间来调度线程，性能更好</td>
</tr>
</tbody></table>
<h4 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h4><ul>
<li>wait() 与 与 notify() 和 和 notifyAll()<ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待</li>
<li>notifyAll()：唤醒正在排队等待资源的所有线程结束等待.</li>
</ul>
</li>
<li>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常。</li>
<li>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明。</li>
</ul>
<h5 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()  方法"></a>wait()  方法</h5><ul>
<li>在当前线程中调用方法： 对象名.wait()</li>
<li>使当前线程进入等待（某对象）状态，直到另一线程对该对象发出 notify(或notifyAll) 为止。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
<li>调用此方法后，当前线程将释放对象监控权，然后进入等待</li>
<li>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</li>
</ul>
<h5 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h5><ul>
<li>在当前线程中调用方法： 对象名.notify()</li>
<li>功能：唤醒等待该对象监控权的一个/所有线程。</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
</ul>
<h4 id="经典例题：生产者-消费者问题"><a href="#经典例题：生产者-消费者问题" class="headerlink" title="经典例题：生产者/ 消费者问题"></a>经典例题：生产者/ 消费者问题</h4><ul>
<li>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处<br>取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图<br>生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通<br>知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如<br>果店中有产品了再通知消费者来取走产品。</li>
<li>这里可能出现两个问题：</li>
<li>生产者比消费者快时，消费者会漏掉一些数据没有取到。</li>
<li>消费者比生产者快时，消费者会取相同的数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PC &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Clerk clerk &#x3D; new Clerk();</span><br><span class="line"></span><br><span class="line">        Productor productor &#x3D; new Productor(clerk);</span><br><span class="line">        Customer c &#x3D; new Customer(clerk);</span><br><span class="line">        Thread customer &#x3D; new Thread(c);</span><br><span class="line"></span><br><span class="line">        productor.start();</span><br><span class="line">        customer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clerk&#123;</span><br><span class="line"></span><br><span class="line">    public int number;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;生产</span><br><span class="line">    public synchronized void Productr()&#123;</span><br><span class="line">        if(number &gt;&#x3D; 20)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(&quot;生产的第&quot; + number + &quot;个产品&quot;);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;消费</span><br><span class="line">    public synchronized void Customer()&#123;</span><br><span class="line">        if (number &lt;&#x3D; 0)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;消费的第&quot; + number + &quot;个产品&quot;);</span><br><span class="line">            number--;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Productor extends Thread&#123;</span><br><span class="line">    private Clerk clerk;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            clerk.Productr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Productor(Clerk clerk)&#123;</span><br><span class="line">        this.clerk &#x3D; clerk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Customer implements Runnable&#123;</span><br><span class="line">    private  Clerk clerk;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            clerk.Customer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Customer(Clerk clerk)&#123;</span><br><span class="line">        this.clerk &#x3D; clerk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>24.Java基础知识-JUnit单元测试</title>
    <url>/2020/11/05/24-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="Java中的JUnit单元测试"><a href="#Java中的JUnit单元测试" class="headerlink" title="Java中的JUnit单元测试"></a>Java中的JUnit单元测试</h2><h4 id="1-步骤："><a href="#1-步骤：" class="headerlink" title="1. 步骤："></a>1. 步骤：</h4><ol>
<li><p>选中当前工程 </p>
<ul>
<li>右键选择：build path </li>
<li>add libraries </li>
<li>JUnit 4 </li>
<li>下一步</li>
</ul>
</li>
<li><p>创建Java类，进行单元测试。此时的Java类要求：</p>
<ul>
<li>此类是public的</li>
<li>此类提供公共的无参的构造器</li>
</ul>
</li>
<li><p>此类中声明单元测试方法。</p>
<ul>
<li>方法的权限是public</li>
<li>没有返回值</li>
<li>没有形参</li>
</ul>
</li>
<li><p>此单元测试需要</p>
<ul>
<li>声明注解：@Test,</li>
<li>导包：import org.junit.Test;</li>
</ul>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p>
</li>
<li><p>写完代码以后</p>
<ul>
<li>左键双击单元测试方法名</li>
<li>右键：run as - JUnit Test</li>
</ul>
</li>
</ol>
<h4 id="2-说明："><a href="#2-说明：" class="headerlink" title="2. 说明："></a>2. 说明：</h4><ol>
<li>如果执行结果没有任何异常：绿条</li>
<li>如果执行结果出现异常：红条</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>JUnit单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>32.Java基础知识-异常处理</title>
    <url>/2020/11/05/32-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h4 id="异常概述与异常体系结构"><a href="#异常概述与异常体系结构" class="headerlink" title="异常概述与异常体系结构"></a>异常概述与异常体系结构</h4><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>在Java语言中，将程序执行中发生的不正常情况称为“异常”。<br>(开发过程中的语法错误和逻辑错误不是异常)</p>
<h5 id="Java程序执行中异常的分类"><a href="#Java程序执行中异常的分类" class="headerlink" title="Java程序执行中异常的分类"></a>Java程序执行中异常的分类</h5><p>Error ：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。</p>
<p>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。</p>
<h5 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h5><p><img src="http://wangzixuan.work/6812" alt="image"></p>
<h6 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h6><ul>
<li>是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序<br>员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子<br>类都是运行时异常。</li>
<li>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对<br>程序的可读性和运行效率产生影响。<h6 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h6></li>
<li>是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一<br>般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</li>
<li>对于这类异常，如果程序不处理，可能会带来意想不到的结果。</li>
</ul>
<h4 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h4><p><img src="http://wangzixuan.work/6808" alt="image"></p>
<h4 id="异常处理一：try-catch-finally捕获"><a href="#异常处理一：try-catch-finally捕获" class="headerlink" title="异常处理一：try-catch-finally捕获"></a>异常处理一：try-catch-finally捕获</h4><p>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的if-else分支会导致程序的代码加长、臃肿，可读性差。因此采用异常处理机制。</p>
<h5 id="异常的抛出机制"><a href="#异常的抛出机制" class="headerlink" title="异常的抛出机制"></a>异常的抛出机制</h5><ul>
<li>如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。</li>
<li>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。</li>
<li>程序员通常只能处理Exception，而对Error无能为力。</li>
</ul>
<h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">...... &#x2F;&#x2F;可能产生异常的代码</span><br><span class="line">&#125;</span><br><span class="line">catch( ExceptionName1 e )&#123;</span><br><span class="line">...... &#x2F;&#x2F;当产生ExceptionName1型异常时的处置措施</span><br><span class="line">&#125;</span><br><span class="line">catch( ExceptionName2 e )&#123;</span><br><span class="line">...... &#x2F;&#x2F;当产生ExceptionName2型异常时的处置措施</span><br><span class="line">&#125;</span><br><span class="line">[ finally&#123;</span><br><span class="line">...... &#x2F;&#x2F;无论是否发生异常， 都无条件执行的语句</span><br><span class="line">&#125; ]</span><br></pre></td></tr></table></figure>

<h6 id="try"><a href="#try" class="headerlink" title="try"></a>try</h6><p>捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。</p>
<h6 id="catch-Exceptiontype-e"><a href="#catch-Exceptiontype-e" class="headerlink" title="catch (Exceptiontype e)"></a>catch (Exceptiontype e)</h6><p>在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
<ul>
<li>如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。</li>
<li>getMessage() 获取异常信息，返回字符串</li>
<li>printStackTrace()获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</li>
</ul>
<h6 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h6><ul>
<li>捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。</li>
<li>不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。</li>
</ul>
<h6 id="finally语句和catch语句是任选的"><a href="#finally语句和catch语句是任选的" class="headerlink" title="finally语句和catch语句是任选的"></a>finally语句和catch语句是任选的</h6><h4 id="异常处理二：throws抛异常"><a href="#异常处理二：throws抛异常" class="headerlink" title="异常处理二：throws抛异常"></a>异常处理二：throws抛异常</h4><ul>
<li>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，<br>而由该方法的调用者负责处理。</li>
<li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类 。</li>
</ul>
<h5 id="throws-异常"><a href="#throws-异常" class="headerlink" title="throws + 异常"></a>throws + 异常</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void readFile(String file) throws FileNotFoundException &#123;</span><br><span class="line">    ……</span><br><span class="line">    &#x2F;&#x2F;  读文件的操作可能产生FileNotFoundException 类型的异常</span><br><span class="line">    FileInputStream fis &#x3D; new FileInputStream(file);</span><br><span class="line">    ..……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重写方法声明抛出异常的原则"><a href="#重写方法声明抛出异常的原则" class="headerlink" title="重写方法声明抛出异常的原则"></a>重写方法声明抛出异常的原则</h5><p>重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">    public void methodA() throws IOException &#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">public class B1 extends A &#123;</span><br><span class="line">    public void methodA() throws FileNotFoundException &#123;</span><br><span class="line">    ……</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">public class B2 extends A &#123;</span><br><span class="line">    public void methodA() throws Exception &#123; &#x2F;&#x2F; 报错</span><br><span class="line">    ……</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h4><ul>
<li>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运<br>行环境)。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IOException e &#x3D; new IOException();</span><br><span class="line">throw e;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将<br>会产生语法错误：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw new String(&quot;want to throw&quot;);</span><br></pre></td></tr></table></figure>


<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><ul>
<li>一般地，用户自定义异常类都是RuntimeException的子类。</li>
<li>自定义异常类通常需要编写几个重载的构造器。</li>
<li>自定义异常需要提供serialVersionUID</li>
<li>自定义的异常通过throw抛出。</li>
<li>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</li>
</ul>
<h6 id="自定义异常类必须继承现有的异常类"><a href="#自定义异常类必须继承现有的异常类" class="headerlink" title="自定义异常类必须继承现有的异常类"></a>自定义异常类必须继承现有的异常类</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyExpTest &#123;</span><br><span class="line">    public void regist(int num) throws MyException &#123;</span><br><span class="line">        if (num &lt; 0)</span><br><span class="line">            throw new MyException(&quot;人数为负值，不合理&quot;, 3);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;登记人数&quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line">    public void manager() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            regist(100);</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            System.out.print(&quot;登记失败，出错种类&quot; + e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;本次登记操作结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        MyExpTest t &#x3D; new MyExpTest();</span><br><span class="line">        t.manager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="上有排污，下游治理"><a href="#上有排污，下游治理" class="headerlink" title="上有排污，下游治理"></a>上有排污，下游治理</h5><p><img src="http://wangzixuan.work/6873" alt="image"></p>
<h5 id="宋老师一首小悟"><a href="#宋老师一首小悟" class="headerlink" title="宋老师一首小悟"></a>宋老师一首小悟</h5><ul>
<li>世界上最遥远的 距离在 ，是我在if 里你在else 里，似乎一直相伴又永远分离；</li>
<li>世界上最痴心的 等待当 ，是我当case 你是switch ，或许永远都选不上自己；</li>
<li>世界上最真情的相依在 ，是你在try 我在catch。无论你发神马脾气，我都默默的承受，静静处理。到那时，再来期待我们的finally。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
</search>
