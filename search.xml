<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01.Java语言概述</title>
    <url>/2020/07/03/01-Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、Java基础知识图解"><a href="#一、Java基础知识图解" class="headerlink" title="一、Java基础知识图解"></a>一、Java基础知识图解</h2><p><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/75CCFC6508AF4C9ABEAB575A1F23E569/1753" alt=""></p>
<h2 id="二、Windows操作cmd"><a href="#二、Windows操作cmd" class="headerlink" title="二、Windows操作cmd"></a>二、Windows操作cmd</h2><h4 id="1-常用DOS命令"><a href="#1-常用DOS命令" class="headerlink" title="1. 常用DOS命令"></a>1. 常用DOS命令</h4><ul>
<li>dir：列出当前目录下的文件及文件夹</li>
<li>md：创建目录</li>
<li>rd：删除目录</li>
<li>d：进入D盘</li>
<li>cd：进入到指定目录</li>
<li>cd..：返回上级目录</li>
<li>cd\：退回到根目录</li>
<li>echo&gt;xxx.xxx：创建xxx.xxx文件</li>
<li>echo xxx &gt;xxx.xxx：创建xxx.xxx文件并写入xxx</li>
<li>echo &gt;xxx.xxx xxx：创建xxx.xxx文件并写入xxx</li>
<li>del：删除文件</li>
<li>exit：退出dos命令行即退出cmd<h4 id="2-常用快捷键"><a href="#2-常用快捷键" class="headerlink" title="2. 常用快捷键"></a>2. 常用快捷键</h4></li>
<li>← →：移动光标</li>
<li>↑ ↓：调阅历史操作命令</li>
<li>Delete Backspace：删除字符<h2 id="三、Java语言"><a href="#三、Java语言" class="headerlink" title="三、Java语言"></a>三、Java语言</h2><h4 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a>1. 来源</h4>Java语言是SUN(Stanford University Network,斯坦福大学网络公司) 1995年推出的一门高级编程语言。<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4>Java语言是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序(applet)。applet使用现代的图形用户界面与Web用户进行交互。applet内嵌在HTML代码中。<h4 id="3-现状"><a href="#3-现状" class="headerlink" title="3. 现状"></a>3. 现状</h4>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。<h4 id="4-简史"><a href="#4-简史" class="headerlink" title="4. 简史"></a>4. 简史</h4></li>
<li>1991年Green项目，开发语言最初命名为Oak (橡树)</li>
<li>1994年，开发组意识到Oak非常适合于互联网</li>
<li>1996年，发布JDK 1.0，约8.3万 个网页应用Java技术来制作</li>
<li>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最</li>
<li>1998年，发布JDK 1.2，同年发布企业平台J2EE</li>
<li>1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技 术诞生</li>
<li>2004年，发布里程碑式版本: JDK 1.5，为突出此版本的重要性，更名为JDK 5.0</li>
<li>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE, J2ME -&gt; JavaME</li>
<li>2009年，Oracle公司收购SUN，交易价格74亿美元</li>
<li>2011年，发布JDK 7.0</li>
<li>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本</li>
<li>2017年，发布JDK 9.0，最大限度实现模块化</li>
<li>2018年3月，发布JDK 10.0，版本号也称为18.3</li>
<li>2018年9月，发布JDK 11.0，版本号也称为18.9<h4 id="5-Java语言的诞生"><a href="#5-Java语言的诞生" class="headerlink" title="5. Java语言的诞生"></a>5. Java语言的诞生</h4></li>
<li>java之父James Gosl ing团队在开发”Green”项目时，发现c缺少垃圾回收系统，还有可移植的安全性、分布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。</li>
<li>Java确实是从c语言和C++语言继承了许多成份，甚至可以将Java看成是类c语言发展和衍生的产物。比如Java语言的变量声明，操作符形式，参数传递，流程控制等方面和C语言、C++语言完全相同。但同时，Java是一个纯粹的面向对象的程序设计语言，它继承了C++语言面向对象技术的核心。Java舍弃了c语言中容易引起错误的指针(以引用取代)、运算符重载(operator overloading)、多重继承<br>(以接口取代)等特性，增加了垃圾回收器功能用于回收不再被引用的对象所占据的内存空间。JDK1.5又引入了泛型编程(GenericProgramming)、类型安全的枚举、不定长参数和自动装/拆箱<h4 id="6-Java的主要特性"><a href="#6-Java的主要特性" class="headerlink" title="6. Java的主要特性"></a>6. Java的主要特性</h4></li>
<li><h5 id="Java语言是易学的"><a href="#Java语言是易学的" class="headerlink" title="Java语言是易学的"></a>Java语言是易学的</h5>  Java语言的语法与c语言和C++语言很接近，使得大多数程序员很容易学习和使用Java。</li>
<li><h5 id="Java语言是强制面向对象的"><a href="#Java语言是强制面向对象的" class="headerlink" title="Java语言是强制面向对象的"></a>Java语言是强制面向对象的</h5>  Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制<br>(关键字为implements)。</li>
<li><h5 id="Java语言是分布式的"><a href="#Java语言是分布式的" class="headerlink" title="Java语言是分布式的"></a>Java语言是分布式的</h5>  Java语 言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口(java net) ，它提供了用于网络应用编程的类<br>库，包括URL、URLConnection、 Socket、 ServerSocket等。 Java 的RMI (远程<br>方法激活)机制也是开发分布式应用的重要手段。</li>
<li><h5 id="Java语言是健壮的"><a href="#Java语言是健壮的" class="headerlink" title="Java语言是健壮的"></a>Java语言是健壮的</h5>  Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。</li>
<li><h5 id="Java语言是安全的"><a href="#Java语言是安全的" class="headerlink" title="Java语言是安全的"></a>Java语言是安全的</h5>  Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如:安全防范机制(类ClassLoader)，如分配不同的名字空间以防替代本地的同名类、字节代码检查。</li>
<li><h5 id="Java语言是体系结构中立的"><a href="#Java语言是体系结构中立的" class="headerlink" title="Java语言是体系结构中立的"></a>Java语言是体系结构中立的</h5>  Java程序(后缀为java的文件)在Java平台上被<br>编译为体系结构中立的字节码格式(后缀为class的文件)，然后可以在实现这个</li>
<li><h5 id="Java平台的任何系统中运行"><a href="#Java平台的任何系统中运行" class="headerlink" title="Java平台的任何系统中运行"></a>Java平台的任何系统中运行</h5>  Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统的解释器中运行。</li>
<li><h5 id="Java是性能略高的"><a href="#Java是性能略高的" class="headerlink" title="Java是性能略高的"></a>Java是性能略高的</h5>  与那些解释型的高级脚本语言相比，Java的性能还是较优的。</li>
<li><h5 id="Java语言是原生支持多线程的"><a href="#Java语言是原生支持多线程的" class="headerlink" title="Java语言是原生支持多线程的"></a>Java语言是原生支持多线程的</h5>  在Java语言中，线程是一-种特殊的对象，它必须<br>由Thread类或其子(孙)类来创建。</li>
</ul>
<h4 id="7-Java技术平台"><a href="#7-Java技术平台" class="headerlink" title="7. Java技术平台"></a>7. Java技术平台</h4><ul>
<li><h5 id="Java-SE-Java-Standard-Edition-标准版"><a href="#Java-SE-Java-Standard-Edition-标准版" class="headerlink" title="Java SE(Java Standard Edition)标准版"></a>Java SE(Java Standard Edition)标准版</h5>  支持面向桌面级应用(如Windows’下的应用程序)的Java平台，提供了完整的Java核心API，此版本以前称为J2SE</li>
<li><h5 id="Java-EE-Java-Enterprise-Edition-企业版"><a href="#Java-EE-Java-Enterprise-Edition-企业版" class="headerlink" title="Java EE(Java Enterprise Edition)企业版"></a>Java EE(Java Enterprise Edition)企业版</h5>  是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等 ,主要针对于Web应用程序开发。版本以前称为J2EE<h4 id="8-Java应用领域"><a href="#8-Java应用领域" class="headerlink" title="8.Java应用领域"></a>8.Java应用领域</h4>从Java的应用领域来分，Java语言的应用方向主要表现在以下几个方面:</li>
<li><h5 id="企业级应用"><a href="#企业级应用" class="headerlink" title="企业级应用"></a>企业级应用</h5>  主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</li>
<li><h5 id="Android平台应用"><a href="#Android平台应用" class="headerlink" title="Android平台应用"></a>Android平台应用</h5>  Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实。</li>
<li><h5 id="大数据平台开发"><a href="#大数据平台开发" class="headerlink" title="大数据平台开发"></a>大数据平台开发</h5>  各类框架有Hadoop, spark, storm,flink等，就这类技术生态圈来讲，还有各种中间件如flume, kafka, sqoop等等 ，这些框架以及工具大多数是用Java编写而成，但提供诸如Java, sscala,Python,R等各种语言API供编程。</li>
<li><h5 id="移动领域应用"><a href="#移动领域应用" class="headerlink" title="移动领域应用"></a>移动领域应用</h5>  主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。<h2 id="四、Java语言运行机制及运行过程"><a href="#四、Java语言运行机制及运行过程" class="headerlink" title="四、Java语言运行机制及运行过程"></a>四、Java语言运行机制及运行过程</h2></li>
</ul>
<ol>
<li><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ol>
<li><h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多肽</li>
</ul>
</li>
<li><h5 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h5><ul>
<li>吸收了C/C++语言的优点，但是去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供一个相对安全的内存管理和访问机制</li>
</ul>
</li>
<li><h5 id="跨平台性"><a href="#跨平台性" class="headerlink" title="跨平台性"></a>跨平台性</h5><ul>
<li>跨平台性：通过Java语言编程的应用程序在不同平台上都可以运行。“Write once，Run Anywhere”</li>
<li>原理:只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/66425C3F4D6C4416AA35914AF5BDF473/2003" alt=""></li>
</ul>
</li>
</ol>
</li>
<li><h4 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h4></li>
</ol>
<ul>
<li>Java虚拟机（Java Virtual Machine）</li>
<li>垃圾收集机制（Garbage Collection）</li>
</ul>
<ol start="3">
<li><h4 id="核心机制——Java虚拟机"><a href="#核心机制——Java虚拟机" class="headerlink" title="核心机制——Java虚拟机"></a>核心机制——Java虚拟机</h4></li>
</ol>
<ul>
<li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/30FFBBDE8BCE487E84A1E54933064199/2047" alt=""></li>
<li>对于不同的平台，有不同的虚拟机。</li>
<li>只有某平台提供了对应的java虚拟机，java程序才可在此平台运行</li>
<li>Java虛拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/21C50C05C06B404E8E09614FC5433A48/2049" alt=""></li>
</ul>
<ol start="4">
<li><h4 id="核心机制——垃圾回收"><a href="#核心机制——垃圾回收" class="headerlink" title="核心机制——垃圾回收"></a>核心机制——垃圾回收</h4></li>
</ol>
<ul>
<li><p>不再使用的内存空间应回收一垃圾回收。</p>
<ul>
<li>在C/C++等语言中，由程序员负责回收无用内存。</li>
<li>Java语言消除了程序员回收无用内存空间的责任:它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。</li>
</ul>
</li>
<li><p>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</p>
</li>
<li><p>Java程序还会出现内存泄漏和内存溢出问题吗?会!</p>
<h2 id="五、Java语言的环境搭建"><a href="#五、Java语言的环境搭建" class="headerlink" title="五、Java语言的环境搭建"></a>五、Java语言的环境搭建</h2></li>
<li><h4 id="JDK-Java-Development-Kit-Java开发工具包"><a href="#JDK-Java-Development-Kit-Java开发工具包" class="headerlink" title="JDK(Java Development Kit Java开发工具包)"></a>JDK(Java Development Kit Java开发工具包)</h4><p>  JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。</p>
<h5 id="其中的开发工具"><a href="#其中的开发工具" class="headerlink" title="其中的开发工具:"></a>其中的开发工具:</h5><ul>
<li>译工具(javac.exe)</li>
<li>打包工具(jar.exe)等</li>
</ul>
</li>
<li><h4 id="JRE-Java-Runtime-Environment-Java运-行环境"><a href="#JRE-Java-Runtime-Environment-Java运-行环境" class="headerlink" title="JRE(Java Runtime Environment Java运 行环境)"></a>JRE(Java Runtime Environment Java运 行环境)</h4><p>  包括Java虛拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
</li>
<li><h4 id="JDK、JRE、JVM的关系"><a href="#JDK、JRE、JVM的关系" class="headerlink" title="JDK、JRE、JVM的关系"></a>JDK、JRE、JVM的关系</h4><p>  <img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/BFAF4FD048524CA3807B138AF3C45CC4/2085" alt=""><br>  <img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/B08C7243C65E43B4B016B553FAA3B5EC/2087" alt=""></p>
</li>
<li><h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><p>  <img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/63C95BA1A3F84F2D8ADBAE374CB8DBEE/2095" alt=""><br>  <img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/0288F0463E9A413980DEDF37C6567413/2097" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>01.数据结构</title>
    <url>/2020/07/04/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构包括：线性结构和非线性结构。</p>
<ul>
<li><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</li>
<li>线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。</li>
<li>顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。</li>
<li>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</li>
<li>线性结构常见的有：数组、队列、链表和栈。</li>
</ol>
</li>
<li><h4 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h4><ol>
<li>二维数组</li>
<li>多维数组</li>
<li>广义表</li>
<li>树结构</li>
<li>图结构</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>线性结构</tag>
        <tag>非线性结构</tag>
        <tag>顺序存储结构</tag>
        <tag>链式存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title>02.Java基础知识-文档及规范</title>
    <url>/2020/07/03/02-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%96%87%E6%A1%A3%E5%8F%8A%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="一、Java-API文档"><a href="#一、Java-API文档" class="headerlink" title="一、Java API文档"></a>一、Java API文档</h2><ul>
<li>API (Application Programming Interface,应用程序编程接口)是Java提供的基本编程接口。</li>
<li>Java语言提供了大量的基础类，因此Oracle也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。</li>
<li>下载API: <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/CD556D9628C440739B5E5D98166F9619/2119" alt=""><h2 id="二、良好的编程风格"><a href="#二、良好的编程风格" class="headerlink" title="二、良好的编程风格"></a>二、良好的编程风格</h2></li>
<li><h4 id="正确的注释和注释风格"><a href="#正确的注释和注释风格" class="headerlink" title="正确的注释和注释风格"></a>正确的注释和注释风格</h4><ul>
<li>使用文档注释来注释整个类或整个方法。</li>
<li>如果注释方法中的某一一个步骤，使用单行或多行注释。</li>
</ul>
</li>
<li><h4 id="正确的缩进和空白"><a href="#正确的缩进和空白" class="headerlink" title="正确的缩进和空白"></a>正确的缩进和空白</h4><ul>
<li>使用一次tab操作，实现缩进</li>
<li>运算符两边习惯性各加一一个空格。比如: 2+4* 5。</li>
</ul>
</li>
<li><h4 id="块的风格"><a href="#块的风格" class="headerlink" title="块的风格"></a>块的风格</h4><ul>
<li>JavaAPI源代码选择了行尾风格<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/0607887735F14AA78238C53A2BFF9774/2135" alt=""><h2 id="三、注释"><a href="#三、注释" class="headerlink" title="三、注释"></a>三、注释</h2></li>
</ul>
</li>
<li>用于注解说明解释程序的文字就是注释。</li>
<li>Java中的注释类型:<ul>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释(java特有)</li>
</ul>
</li>
<li>提高了代码的阅读性;调试程序的重要方法。</li>
<li>注释是一个程序员必须要具有的良好编程习惯。</li>
<li>将自己的思想通过注释先整理出来，再用代码去体现</li>
<li><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式: &#x2F;&#x2F;注释文字</span><br></pre></td></tr></table></figure></li>
<li><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式: &#x2F;*注释文字*&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h4><ul>
<li>对于单行和多行注释，被注释的文字，不会被JVM (java虚拟机)解释执行。</li>
<li>多行注释里面不允许有多行注释嵌套。</li>
</ul>
</li>
<li><h4 id="文档注释-Java特有"><a href="#文档注释-Java特有" class="headerlink" title="文档注释(Java特有)"></a>文档注释(Java特有)</h4>  格式:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">@author指定java程序的作者</span><br><span class="line">@version指定源文件的版本</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="javadoc解析"><a href="#javadoc解析" class="headerlink" title="javadoc解析"></a>javadoc解析</h4><ul>
<li>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/9CFC978F5A23402484BAE69041A09C43/2176" alt=""><h2 id="四、注释示例"><a href="#四、注释示例" class="headerlink" title="四、注释示例"></a>四、注释示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">1. java规范的三种注释方式：</span><br><span class="line">单行注释</span><br><span class="line">多行注释</span><br><span class="line">文档注释(java特有)</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">单行注释和多行注释的作用：</span><br><span class="line">① 对所写的程序进行解释说明，增强可读性。方便自己，方便别人</span><br><span class="line">② 调试所写的代码</span><br><span class="line"></span><br><span class="line">3. 特点：单行注释和多行注释，注释了的内容不参与编译。</span><br><span class="line">         换句话说，编译以后生成的.class结尾的字节码文件中不包含注释掉的信息</span><br><span class="line"></span><br><span class="line">4. 文档注释的使用：</span><br><span class="line">    注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</span><br><span class="line"></span><br><span class="line">5. 多行注释不可以嵌套使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">文档注释</span><br><span class="line">@author shkstart</span><br><span class="line">@version v1.0</span><br><span class="line">这是我的第一个java程序！非常的开森！</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">public class HelloJava&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	多行注释：</span><br><span class="line">	如下的main方法是程序的入口！</span><br><span class="line">	main的格式是固定的！</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	如下的方式是main()，作用：程序的入口。</span><br><span class="line">	*&#x2F;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		&#x2F;&#x2F;单行注释：如下的语句表示输出到控制台</span><br><span class="line">		&#x2F;&#x2F;System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>02.数据结构-稀疏sparsearray数组</title>
    <url>/2020/07/04/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8Fsparsearray%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="稀疏sparsearray数组"><a href="#稀疏sparsearray数组" class="headerlink" title="稀疏sparsearray数组"></a>稀疏sparsearray数组</h2><ol>
<li><h4 id="先看一个实际的需求"><a href="#先看一个实际的需求" class="headerlink" title="先看一个实际的需求"></a>先看一个实际的需求</h4><ul>
<li>编写的五子棋程序中，有存盘退出和续上盘的功能。<br><img src="https://note.youdao.com/yws/public/resource/03d703e92a974f5336caf854bb9b1235/xmlnote/3F48A45D21D64CCE9BD81A06201A6EA4/2296" alt=""></li>
<li>分析问题: 因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据→稀疏数组。</li>
</ul>
</li>
<li><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p> 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<h5 id="稀疏数组的处理方法是"><a href="#稀疏数组的处理方法是" class="headerlink" title="稀疏数组的处理方法是:"></a>稀疏数组的处理方法是:</h5><ol>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模<h5 id="稀疏数组举例说明"><a href="#稀疏数组举例说明" class="headerlink" title="稀疏数组举例说明"></a>稀疏数组举例说明</h5><img src="https://note.youdao.com/yws/public/resource/03d703e92a974f5336caf854bb9b1235/xmlnote/B47D7A9A53B4448A93AD74AE279D5166/2307" alt=""><br><img src="https://note.youdao.com/yws/public/resource/03d703e92a974f5336caf854bb9b1235/xmlnote/6A7B70B908D6409DB8CD98116CC73D04/2309" alt=""></li>
</ol>
</li>
<li><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ul>
<li><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</p>
</li>
<li><p>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</p>
</li>
<li><p>整体思路分析<br><img src="https://note.youdao.com/yws/public/resource/03d703e92a974f5336caf854bb9b1235/xmlnote/186FB0433BE047EDBF03D879F2EBA82C/2326" alt=""></p>
</li>
<li><p>二维数组 转 稀疏数组的思路</p>
<ol>
<li>遍历  原始的二维数组，得到有效数据的个数 sum</li>
<li>根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]</li>
<li>将二维数组的有效数据数据存入到 稀疏数组</li>
</ol>
</li>
<li><p>稀疏数组转原始的二维数组的思路</p>
<ol>
<li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</li>
<li>在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.sparsearray;</span><br><span class="line"></span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; 创建11*11的二维数组</span><br><span class="line">		int[][] chessArr1&#x3D;new int[11][11];</span><br><span class="line">		&#x2F;&#x2F; 0代表没有棋子，1代表黑子，2代表蓝子</span><br><span class="line">		chessArr1[1][2]&#x3D;1;</span><br><span class="line">		chessArr1[2][3]&#x3D;2;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出原始二维数组chessArr1</span><br><span class="line">		System.out.println(&quot;输出原始的二维数组chessArr1&quot;);</span><br><span class="line">		for (int[] row : chessArr1)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 将二维数组 转 稀疏数组</span><br><span class="line">		&#x2F;&#x2F; 遍历chessArr1  非0数据的个数计为sum</span><br><span class="line">		int sum&#x3D;0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; chessArr1.length; i++)&#123;</span><br><span class="line">			for(int j &#x3D; 0;j &lt; chessArr1.length; j++)&#123;</span><br><span class="line">				if(chessArr1[i][j] !&#x3D; 0)&#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 输出sum</span><br><span class="line">		System.out.println(&quot;sum&#x3D;&quot;+sum);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建稀疏数组</span><br><span class="line">		int[][] sparseArr &#x3D; new int[sum+1][3];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 给稀疏数组赋值</span><br><span class="line">		sparseArr[0][0] &#x3D; 11;</span><br><span class="line">		sparseArr[0][1] &#x3D; 11;</span><br><span class="line">		sparseArr[0][2] &#x3D; sum;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 遍历原始二维数组，将非0的值存放到 sparseArr中</span><br><span class="line">		int count &#x3D; 0; &#x2F;&#x2F;count 用于记录是第几个非0数据</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 11; i++)&#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 11; j++)&#123;</span><br><span class="line">				if (chessArr1[i][j] !&#x3D;0 )&#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][0] &#x3D; i;</span><br><span class="line">					sparseArr[count][1] &#x3D; j;</span><br><span class="line">					sparseArr[count][2] &#x3D; chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出稀疏数组</span><br><span class="line">		System.out.println(&quot;得到稀疏数组为~~~~&quot;);</span><br><span class="line">		for (int[] row : sparseArr)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 将稀疏数组 --》 恢复成 原始的二维数组</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 &#x3D; int [11][11]</span><br><span class="line">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span><br><span class="line">		int[][] chessArr2 &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span><br><span class="line">		for (int i &#x3D; 1; i &lt; sparseArr.length; i++)&#123;</span><br><span class="line">			chessArr2[sparseArr[1][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出原始二维数组chessArr2</span><br><span class="line">		System.out.println(&quot;恢复后的二维数组chessArr2&quot;);</span><br><span class="line">		for (int[] row : chessArr2)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>稀疏数组</tag>
        <tag>sparsearray</tag>
      </tags>
  </entry>
  <entry>
    <title>03.Java基础知识-HelloWorld</title>
    <url>/2020/07/03/03-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-HelloWorld/</url>
    <content><![CDATA[<h2 id="一、开发步骤"><a href="#一、开发步骤" class="headerlink" title="一、开发步骤"></a>一、开发步骤</h2><ol>
<li><h5 id="将Java代码编写到扩展名为-java的文件中"><a href="#将Java代码编写到扩展名为-java的文件中" class="headerlink" title="将Java代码编写到扩展名为.java的文件中"></a>将Java代码编写到扩展名为.java的文件中</h5></li>
<li><h5 id="通过javac命令对该java文件进行编译。"><a href="#通过javac命令对该java文件进行编译。" class="headerlink" title="通过javac命令对该java文件进行编译。"></a>通过javac命令对该java文件进行编译。</h5></li>
<li><h5 id="通过java命令对生成的class文件进行运行"><a href="#通过java命令对生成的class文件进行运行" class="headerlink" title="通过java命令对生成的class文件进行运行"></a>通过java命令对生成的class文件进行运行</h5><h2 id="二、步骤一：编写"><a href="#二、步骤一：编写" class="headerlink" title="二、步骤一：编写"></a>二、步骤一：编写</h2></li>
</ol>
<ul>
<li>选择最简单的编辑器:记事本。敲入代码  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>将文件保存成Test.java,这个文件是存放java代码的文件，称为源文件。</li>
<li>注意拓展名是否隐藏<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/346939038BBD427ABBFB641BF569B224/2202" alt=""><h2 id="三、步骤二：编译"><a href="#三、步骤二：编译" class="headerlink" title="三、步骤二：编译"></a>三、步骤二：编译</h2><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/5A68EBF692DE4587804070655058A42F/2229" alt=""></li>
<li>有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件。</li>
<li>在该源文件目录下，通过javac编译工具对Test.java文件进行编译。</li>
<li>如果程序没有错误，没有任何提示，但在当前目录下会出现一个Test.class文件，该文件称为字节码文件，也是可以执行的java的程序。<h2 id="四、步骤三：运行"><a href="#四、步骤三：运行" class="headerlink" title="四、步骤三：运行"></a>四、步骤三：运行</h2></li>
<li>有了可执行的java程序(Test.class字节码文件)</li>
<li>通过运行工具java.exe对字节码文件进行执行。</li>
<li>出现提示:缺少一个名称为main的方法。<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/A2FABB30A9974F52A7EFCD555CF04898/2231" alt=""></li>
<li>因为一个程序的执行需要-一个起始点或者入口，所以在Test类中的加入  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void</span><br><span class="line">main(String] args)&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>对修改后的Test.java源文件需要重新编译，生成新的class文件后，再进行执行。</li>
<li>发现没有编译失败，但也没有任何效果，因为并没有告诉JVM要帮我们做什么事情，也就是没有可以具体执行的语句。</li>
<li>想要和JVM来个互动，只要在main方法中加入一句  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.printn(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure></li>
<li>因为程序进行改动，所以再重新编译，运行即可。<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2></li>
<li>学习编程最容易犯的错是语法错误。</li>
<li>Java要求你必须按照语法规则编写代码。</li>
<li>如果你的程序违反了语法规则。例如:忘记了分号、大括号、引号，或者拼错了单词，java编译器都会报语法错误。</li>
<li>尝试着去看懂编译器会报告的错误信息。</li>
</ul>
<p><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/B5F7F7C478644F4A9C740EAC4852D842/2233" alt=""><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/B48B4B0D63C548A1B1F0843F634B2F1B/2235" alt=""></p>
<h2 id="六、代码示例"><a href="#六、代码示例" class="headerlink" title="六、代码示例"></a>六、代码示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">对第一个java程序进行总结</span><br><span class="line">1. java程序编写-编译-运行的过程</span><br><span class="line">编写：我们将编写的java代码保存在以&quot;.java&quot;结尾的源文件中</span><br><span class="line">编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java</span><br><span class="line">运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。</span><br><span class="line">而且要求声明为public的类的类名必须与源文件名相同。</span><br><span class="line"></span><br><span class="line">3. 程序的入口是main()方法。格式是固定的。</span><br><span class="line"></span><br><span class="line">4. 输出语句：</span><br><span class="line">System.out.println():先输出数据，然后换行</span><br><span class="line">System.out.print():只输出数据</span><br><span class="line"></span><br><span class="line">5.每一行执行语句都以&quot;;&quot;结束。</span><br><span class="line"></span><br><span class="line">6.编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">	public static void main(String[] args) &#123;&#x2F;&#x2F;public static void main(String a[]) &#123;&#x2F;&#x2F;arguments:参数</span><br><span class="line">		System.out.print(&quot;Hello World!&quot;);</span><br><span class="line">		System.out.println();&#x2F;&#x2F;换行</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>03.数据结构-队列</title>
    <url>/2020/07/05/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列-数组实现"><a href="#队列-数组实现" class="headerlink" title="队列-数组实现"></a>队列-数组实现</h2><ol>
<li><h4 id="队列的一个使用场景"><a href="#队列的一个使用场景" class="headerlink" title="队列的一个使用场景"></a>队列的一个使用场景</h4><p> 银行排队的案例:<br> <img src="https://note.youdao.com/yws/public/resource/03d703e92a974f5336caf854bb9b1235/xmlnote/B5E35C2F052E4703A800D485903EB7F5/2346" alt=""></p>
</li>
<li><h4 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h4><ol>
<li>队列是一个 有序列表，可以用 数组或是链表来实现。</li>
<li>遵循 先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li>
<li>示意图：(使用数组模拟队列示意图)<br><img src="https://note.youdao.com/yws/public/resource/03d703e92a974f5336caf854bb9b1235/xmlnote/67F2BC5DC6244442BCCD19A5C8C91845/2361" alt=""></li>
</ol>
</li>
<li><h4 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h4><ul>
<li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中maxSize 是该队列的最大容量。</p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标，front会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示:<br><img src="https://note.youdao.com/yws/public/resource/03d703e92a974f5336caf854bb9b1235/xmlnote/67F2BC5DC6244442BCCD19A5C8C91845/2361" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; 创建一个队列</span><br><span class="line">		ArrayQueue queue &#x3D; new ArrayQueue(3);</span><br><span class="line">		&#x2F;&#x2F; 接受用户输入</span><br><span class="line">		char key &#x3D; &#39; &#39;;</span><br><span class="line">		&#x2F;&#x2F; 创建输出</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		boolean loop &#x3D; true;</span><br><span class="line">		&#x2F;&#x2F;输出一个菜单</span><br><span class="line">		while (loop) &#123;</span><br><span class="line">			System.out.println(&quot;\t\ts(show): 显示队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\te(exit): 退出程序&quot;);</span><br><span class="line">			System.out.println(&quot;\t\ta(add): 添加数据到队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\tg(get): 从队列取出数据&quot;);</span><br><span class="line">			System.out.println(&quot;\t\th(head): 查看队列头的数据&quot;);</span><br><span class="line">			key &#x3D; sc.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">			switch (key) &#123;</span><br><span class="line">				case &#39;a&#39; : &#x2F;&#x2F; 添加数据到队列</span><br><span class="line">					System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">					int n &#x3D; sc.nextInt();</span><br><span class="line">					queue.addQueue(n);</span><br><span class="line">					break;</span><br><span class="line">				case &#39;g&#39; : &#x2F;&#x2F; 从队列取出数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;取出的数据是：%d\n&quot;,queue.getQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;s&#39; : &#x2F;&#x2F; 显示队列</span><br><span class="line">					queue.showQueue();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;h&#39; : &#x2F;&#x2F; 查看队列头的数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;队列头的数据是：%d\n&quot;,queue.headQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;e&#39; : &#x2F;&#x2F; 退出程序</span><br><span class="line">	    sc.close();</span><br><span class="line">					loop &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;程序退出~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ArrayQueue&#123;</span><br><span class="line">	private int MaxSize; &#x2F;&#x2F; 队列的最大容量</span><br><span class="line">	private int front; &#x2F;&#x2F; 队列头</span><br><span class="line">	private int rear; &#x2F;&#x2F; 队列尾</span><br><span class="line">	private int[] arr; &#x2F;&#x2F; 该数据用于存放数据, 模拟队列</span><br><span class="line">	</span><br><span class="line">	public ArrayQueue(int arrMaxSize)&#123;</span><br><span class="line">		arr &#x3D;  new int[arrMaxSize];</span><br><span class="line">		MaxSize &#x3D; arrMaxSize;</span><br><span class="line">		front &#x3D; -1; &#x2F;&#x2F; 指向队列头部，分析出front是指向队列头的前一个位置.</span><br><span class="line">		rear &#x3D; -1; &#x2F;&#x2F; 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否满</span><br><span class="line">	public boolean isFull()&#123;</span><br><span class="line">		return rear &#x3D;&#x3D; MaxSize-1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	public boolean isEmpty()&#123;</span><br><span class="line">		return front &#x3D;&#x3D; rear;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 添加数据到队列</span><br><span class="line">	public void addQueue(int n)&#123;</span><br><span class="line">		if (isFull()) &#123;</span><br><span class="line">			System.out.println(&quot;队列已满，不能添加！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		rear++; &#x2F;&#x2F; 进队列，rear后移一位</span><br><span class="line">		arr[rear] &#x3D; n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 获取队列的数据, 出队列</span><br><span class="line">	public int getQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		front++; &#x2F;&#x2F; 出队列，front后移一位</span><br><span class="line">		return arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的所有数据</span><br><span class="line">	public void showQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			System.out.println(&quot;队列空的，没有数据~~&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 遍历</span><br><span class="line">		for (int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">			System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的头数据， 注意不是取出数据</span><br><span class="line">	public int headQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[front+1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>问题分析并优化</p>
<ol>
<li>目前数组使用一次就不能用， 没有达到复用的效果</li>
<li>将这个数组使用算法，改进成一个列 环形的队列 取模：%</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h4><p> 对前面的数组模拟队列的优化，充分利用数组。 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<ul>
<li><p>分析说明</p>
<ol>
<li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front 满]</li>
<li>rear == front [空]</li>
<li>分析示意图<br><img src="https://note.youdao.com/yws/public/resource/03d703e92a974f5336caf854bb9b1235/xmlnote/67F2BC5DC6244442BCCD19A5C8C91845/2361" alt=""></li>
<li>思路如下<ol>
<li>front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素<br>front 的初始值 = 0</li>
<li>rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.<br>rear 的初始值 = 0</li>
<li>当队列满时，条件是  (rear  + 1) % maxSize == front 【满】</li>
<li>对队列为空的条件， rear == front 【空】</li>
<li>当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize</li>
</ol>
</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试一把</span><br><span class="line">		System.out.println(&quot;测试数组模拟环形队列的案例~~~&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建一个环形队列</span><br><span class="line">		CircleArrayQueue queue &#x3D; new CircleArrayQueue(4); &#x2F;&#x2F;说明设置4, 其队列的有效数据最大是3</span><br><span class="line">		&#x2F;&#x2F; 接受用户输入</span><br><span class="line">		char key &#x3D; &#39; &#39;;</span><br><span class="line">		&#x2F;&#x2F; 创建输出</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		boolean loop &#x3D; true;</span><br><span class="line">		&#x2F;&#x2F;输出一个菜单</span><br><span class="line">		while (loop) &#123;</span><br><span class="line">			System.out.println(&quot;\t\ts(show): 显示队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\te(exit): 退出程序&quot;);</span><br><span class="line">			System.out.println(&quot;\t\ta(add): 添加数据到队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\tg(get): 从队列取出数据&quot;);</span><br><span class="line">			System.out.println(&quot;\t\th(head): 查看队列头的数据&quot;);</span><br><span class="line">			key &#x3D; sc.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">			switch (key) &#123;</span><br><span class="line">				case &#39;a&#39; : &#x2F;&#x2F; 添加数据到队列</span><br><span class="line">					System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">					int n &#x3D; sc.nextInt();</span><br><span class="line">					queue.addQueue(n);</span><br><span class="line">					break;</span><br><span class="line">				case &#39;g&#39; : &#x2F;&#x2F; 从队列取出数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;取出的数据是：%d\n&quot;,queue.getQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;s&#39; : &#x2F;&#x2F; 显示队列</span><br><span class="line">					queue.showQueue();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;h&#39; : &#x2F;&#x2F; 查看队列头的数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;队列头的数据是：%d\n&quot;,queue.headQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;e&#39; : &#x2F;&#x2F; 退出程序</span><br><span class="line">					sc.close();</span><br><span class="line">					loop &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;程序退出~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class CircleArrayQueue&#123;</span><br><span class="line">	private int MaxSize; &#x2F;&#x2F; 表示数组的最大容量</span><br><span class="line">	&#x2F;&#x2F; front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span><br><span class="line">	&#x2F;&#x2F; front 的初始值 &#x3D; 0</span><br><span class="line">	private int front; </span><br><span class="line">	&#x2F;&#x2F; rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span><br><span class="line">	&#x2F;&#x2F; rear 的初始值 &#x3D; 0</span><br><span class="line">	private int rear; &#x2F;&#x2F; 队列尾</span><br><span class="line">	private int[] arr; &#x2F;&#x2F; 该数据用于存放数据, 模拟队列</span><br><span class="line"></span><br><span class="line">	public CircleArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">		arr &#x3D; new int[arrMaxSize];</span><br><span class="line">		MaxSize &#x3D; arrMaxSize;</span><br><span class="line">		front &#x3D; 0; &#x2F;&#x2F; 指向队列头部，分析出front是指向队列头的位置</span><br><span class="line">		rear &#x3D; 0; &#x2F;&#x2F; 指向队列尾，指向队列尾的后一个位置</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 当前队列有效的数据的个数</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return ( rear + MaxSize - front ) % MaxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 判断队列是否满</span><br><span class="line">	public boolean isFull()&#123;</span><br><span class="line">		return ( rear + 1 ) % MaxSize &#x3D;&#x3D; front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	public boolean isEmpty()&#123;</span><br><span class="line">		return front &#x3D;&#x3D; rear;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 添加数据到队列</span><br><span class="line">	public void addQueue(int n)&#123;</span><br><span class="line">		if (isFull()) &#123;</span><br><span class="line">			System.out.println(&quot;队列已满，不能添加！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;直接将数据加入</span><br><span class="line">		arr[rear] &#x3D; n;</span><br><span class="line">		&#x2F;&#x2F;将 rear 后移, 这里必须考虑取模</span><br><span class="line">		rear &#x3D; ( rear + 1 ) % MaxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 获取队列的数据, 出队列</span><br><span class="line">	public int getQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 这里需要分析出 front是指向队列的第一个元素</span><br><span class="line">		&#x2F;&#x2F; 1. 先把 front 对应的值保留到一个临时变量</span><br><span class="line">		&#x2F;&#x2F; 2. 将 front 后移, 考虑取模</span><br><span class="line">		&#x2F;&#x2F; 3. 将临时保存的变量返回</span><br><span class="line">		int temp &#x3D; arr[front];</span><br><span class="line">		front &#x3D; ( front + 1 ) % MaxSize;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的所有数据</span><br><span class="line">	public void showQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			System.out.println(&quot;队列空的，没有数据~~&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 思路：从front开始遍历，遍历多少个元素</span><br><span class="line">		&#x2F;&#x2F; 动脑筋</span><br><span class="line">		for (int i &#x3D; front; i &lt; front + size(); i++)&#123;</span><br><span class="line">			System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i % MaxSize, arr[i % MaxSize]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的头数据， 注意不是取出数据</span><br><span class="line">	public int headQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，没有数据~~&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>队列</tag>
        <tag>环形队列</tag>
        <tag>数组模拟队列</tag>
        <tag>数组模拟环形队列</tag>
      </tags>
  </entry>
  <entry>
    <title>04.Java基础知识-关键字、保留字与标识符</title>
    <url>/2020/07/05/04-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h2><ul>
<li><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul>
<li><strong>定义</strong>：被Java 语言赋予了特殊含义，用做专门用途的字符串（单词）</li>
<li><strong>特点</strong>：关键字中所有字母都为小写</li>
<li><strong>官方地址</strong>： <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/CC4BE9A8398A48D7A28195BFE62437B2/2416" alt=""><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/F7B6BE2FF852413398DC2E1E6DC18478/2419" alt=""></li>
<li><strong>注</strong>：true、false、null虽然不是关键字，但是命名时不可用。</li>
</ul>
</li>
<li><h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><ul>
<li><strong>Java保留字</strong>：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字goto 、const<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2></li>
</ul>
</li>
<li><h4 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li>
<li><strong>技巧</strong>：凡是自己可以起名字的地方都叫标识符。</li>
</ul>
</li>
<li><h4 id="定义合法标识符规则"><a href="#定义合法标识符规则" class="headerlink" title="定义合法标识符规则"></a>定义合法标识符规则</h4><ul>
<li>由26 个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格</li>
</ul>
</li>
<li><h4 id="Java中的名称命名规范"><a href="#Java中的名称命名规范" class="headerlink" title="Java中的名称命名规范"></a>Java中的名称命名规范</h4><ul>
<li><strong>包名</strong>：多单词组成时所有字母都小写：xxxyyyzzz</li>
<li><strong>类名、接口名</strong>：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
<li><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li>
<li><strong>常量名</strong>：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ul>
</li>
<li><strong>注意1</strong>：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</li>
<li><strong>注意2</strong>：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>关键字</tag>
        <tag>保留字</tag>
        <tag>标识符</tag>
      </tags>
  </entry>
  <entry>
    <title>05.Java基础知识-变量与数据类型</title>
    <url>/2020/07/05/05-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><ul>
<li><p><strong>变量的概念</strong>：</p>
<ul>
<li>内存中的一个存储区域</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元。包含变量类型、变变量名和存储的值</li>
</ul>
</li>
<li><p><strong>变量的作用</strong>：</p>
<ul>
<li>用于在内存中保存数据</li>
</ul>
</li>
<li><p><strong>使用变量注意</strong>：</p>
<ul>
<li>Java中每个变量必须先声明，后使用</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量的作用域：其定义所在的一对{ }内</li>
<li>变量只有在其作用域内才有效</li>
<li>同一个作用域内，不能定义重名的变量</li>
</ul>
</li>
<li><p><strong>声明变量</strong></p>
<ul>
<li>语法：&lt;数据类型&gt; &lt;变量名称&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int var;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>变量的赋值</strong></p>
<ul>
<li>语法：&lt;变量名称&gt; = &lt;值&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var &#x3D; 10;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>声明和赋值变量</strong></p>
<ul>
<li>语法： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int var &#x3D; 10;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>变量的分类-按数据类型</strong></p>
<ul>
<li>对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间。<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/B5873A62EB3544FFA7E076B8E36CF587/2483" alt=""></li>
</ul>
</li>
<li><p><strong>变量的分类-按声明的位置的不同</strong></p>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/708C345927B54C2CBF5489397B6A03C4/2486" alt=""></li>
<li>注意：二者在初始化值方面的异同:<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，需显式初始化。<h2 id="二、整数类型"><a href="#二、整数类型" class="headerlink" title="二、整数类型"></a>二、整数类型</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。</p>
</li>
<li><p>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</p>
</li>
<li><p>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/E2C2993C46C843C09A8F849F90C5583D/2510" alt=""></p>
</li>
<li><p>500MB 1MB = 1024KB 1KB= 1024B B= byte ? bit?<br>bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。</p>
<h2 id="三、浮点类型"><a href="#三、浮点类型" class="headerlink" title="三、浮点类型"></a>三、浮点类型</h2></li>
<li><p>与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。</p>
</li>
<li><p>浮点型常量有两种表示形式：</p>
<ul>
<li>十进制数形式：如：5.12、512.0f、.512 (必须有小数点）</li>
<li>科学计数法形式:如：5.12e2、512E2、100E-2</li>
</ul>
</li>
<li><p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。</p>
</li>
<li><p>double:双精度，精度是float的两倍。通常采用此类型。</p>
</li>
<li><p>Java 的浮点型常量默认为double型，声明float 型常量，须后加‘f’ 或‘F’ 。<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/E77732E612154C8DBDEA76B53737594B/2512" alt=""></p>
<h2 id="四、字符类型"><a href="#四、字符类型" class="headerlink" title="四、字符类型"></a>四、字符类型</h2></li>
<li><p>char 型数据用来表示通常意义上“字符”(2字节)</p>
</li>
<li><p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</p>
</li>
<li><p>字符型变量的三种表现形式：</p>
<ul>
<li>字符常量是用单引号(‘ ‘)括起来的单个字符。例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c1 &#x3D; &#39;a&#39;;</span><br><span class="line">char c2&#x3D; &#39;中&#39;;</span><br><span class="line">char c3 &#x3D; &#39;9&#39;;</span><br></pre></td></tr></table></figure></li>
<li>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c3 &#x3D; ‘\n’; &#x2F;&#x2F; &#39;\n&#39;表示换行符</span><br></pre></td></tr></table></figure>
  <img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/5F7A6D12B93A40B79D673C525F26E328/2514" alt=""></li>
<li>直接使用 Unicode值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个十六进制整数。如：\u000a 表示 \n。</li>
</ul>
</li>
<li><p>char类型是可以进行运算的。因为它都对应有Unicode码。</p>
<h2 id="五、布尔类型"><a href="#五、布尔类型" class="headerlink" title="五、布尔类型"></a>五、布尔类型</h2></li>
<li><p>boolean 类型用来判断逻辑条件，一般用于程序流程控制：</p>
<ul>
<li>if条件控制语句；</li>
<li>while循环控制语句；</li>
<li>do-while循环控制语句；</li>
<li>for循环控制语句；</li>
</ul>
</li>
<li><p>boolean类型数据只允许取值true和false，无null。</p>
<ul>
<li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</li>
<li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。———《java虚拟机规范 8版》<h2 id="六、String字符串类型"><a href="#六、String字符串类型" class="headerlink" title="六、String字符串类型"></a>六、String字符串类型</h2></li>
</ul>
</li>
<li><p>String不是基本数据类型，属于引用数据类型</p>
</li>
<li><p>使用方式与基本数据类型一致。例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; “abcd”;</span><br></pre></td></tr></table></figure></li>
<li><p>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; str + “xyz” ;</span><br><span class="line">int n &#x3D; 100;</span><br><span class="line">str &#x3D; str + n;</span><br></pre></td></tr></table></figure>
<h2 id="七、类型转换"><a href="#七、类型转换" class="headerlink" title="七、类型转换"></a>七、类型转换</h2></li>
<li><p>基本数据类型转换</p>
<ul>
<li>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：<img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/7190B9BDC12F444EB401EC5A2E67BE30/2584" alt=""></li>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。</li>
<li>byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</li>
<li>boolean类型不能与其它数据类型运算。</li>
<li>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。</li>
</ul>
</li>
<li><p>强制类型转换</p>
<ul>
<li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</li>
<li>如：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double a &#x3D; 1.23;</span><br><span class="line">int i &#x3D; (int)a;</span><br></pre></td></tr></table></figure></li>
<li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。</li>
<li>如：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a &#x3D; “43”;</span><br><span class="line">int i &#x3D; Integer.parseInt(a);</span><br></pre></td></tr></table></figure></li>
<li>boolean类型不可以转换为其它的数据类型。</li>
</ul>
</li>
</ul>
<h2 id="八、了解"><a href="#八、了解" class="headerlink" title="八、了解"></a>八、了解</h2><p><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/C1D1D0A1B8EE4D77AABF1519556CA608/2551" alt=""><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/E5FF3C07634B4634BAD1908CAB7A52F6/2553" alt=""><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/F7D16639A1D74A12BF125F2240484199/2555" alt=""></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>变量</tag>
        <tag>整数类型</tag>
        <tag>浮点类型</tag>
        <tag>字符类型</tag>
        <tag>布尔类型</tag>
        <tag>String字符串类型</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub&amp;Git基础</title>
    <url>/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-概述与目的"><a href="#1-概述与目的" class="headerlink" title="1.概述与目的"></a>1.概述与目的</h2><ol>
<li><h5 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h5>Git是一个免费、开源的版本控制软件</li>
<li><h5 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h5>版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。（记录文件的所有历史变化、随时可恢复到任何一个历史状态、多人协作开发或修改错误恢复）</li>
<li><h5 id="什么是Github"><a href="#什么是Github" class="headerlink" title="什么是Github"></a>什么是Github</h5>Github是全球最大的社交编程及代码托管网站（<a href="https://github.com/）。" target="_blank" rel="noopener">https://github.com/）。</a><br>Github可以托管各种git库，并提供一个web界面（用户名.github.io/仓库名）</li>
<li><h5 id="Github和Git是什么关系"><a href="#Github和Git是什么关系" class="headerlink" title="Github和Git是什么关系"></a>Github和Git是什么关系</h5>Git是版本控制软件<br>Github是项目代码托管的平台，借助Git来管理项目代码</li>
<li><h5 id="为什么学习github"><a href="#为什么学习github" class="headerlink" title="为什么学习github"></a>为什么学习github</h5>学习优秀的开源项目<br>关注行业前辈了解最新的行业动态<br>借助github托管项目代码</li>
<li><h5 id="简单介绍Git"><a href="#简单介绍Git" class="headerlink" title="简单介绍Git"></a>简单介绍Git</h5>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢?比如说自己在电脑上改了文件A,其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/1.png" class="">
借助Github托管项目代码。<h2 id="2-GitHub基本概念"><a href="#2-GitHub基本概念" class="headerlink" title="2.GitHub基本概念"></a>2.GitHub基本概念</h2></li>
<li><h5 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h5>仓库用来存放项目代码，每个项目对应一个仓库(Repository)，多个开源项目则有多个仓库（Repositories）。</li>
<li><h5 id="复制克隆项目（fork）"><a href="#复制克隆项目（fork）" class="headerlink" title="复制克隆项目（fork）"></a>复制克隆项目（fork）</h5>完全复制别人的项目到自己的GitHub,丝毫不会影响原有项目的代码与结构。fork的项目是独立存在的！</li>
<li><h5 id="发起请求-Pull-Request"><a href="#发起请求-Pull-Request" class="headerlink" title="发起请求(Pull Request)"></a>发起请求(Pull Request)</h5>发起请求，这个其实是基于Fork的。如果你fork了别人的项目并且在其基础上做了改进，后来觉得改进的很不错，应该要把这些改进让更多的人收益，于是就想把自己的改进合并到原有项目里，这个时候你就可以发起一个PullRequest(简称PR)，原有项目创建人就可以收到这个请求，这个时候你会仔细查看他的代码，并且测试觉得ok了，就会接受他的PR,这个时候他做的改进原有项目就会拥有了。</li>
<li><h5 id="事务卡片-Issue"><a href="#事务卡片-Issue" class="headerlink" title="事务卡片(Issue)"></a>事务卡片(Issue)</h5>发现代码BUG，但是目前没有成型代码，需要讨论时用。</li>
</ol>
<p>举个例子，就是你开源了一个项目，别人发现你的项目中有bug,或者哪些地方做的不够好，他就可以给你提个Issue,即问题，提的问题多了，也就是Issues，然后你.看到了这些问题就可以去逐个修复，修复ok了就可以一个个的Close掉。</p>
<h2 id="3-GitHub上创建仓库"><a href="#3-GitHub上创建仓库" class="headerlink" title="3.GitHub上创建仓库"></a>3.GitHub上创建仓库</h2><p>一个git库（仓库）对应一个开源项目</p>
<p>通过git管理git库</p>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/3.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/4.png" class="">
<h2 id="4-GitHub上管理仓库"><a href="#4-GitHub上管理仓库" class="headerlink" title="4.GitHub上管理仓库"></a>4.GitHub上管理仓库</h2><ol>
<li><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/5.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/6.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/7.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/8.png" class=""></li>
<li><h5 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h5><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/9.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/10.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/11.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/12.png" class=""></li>
<li><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5>可在commits按钮查看删除信息<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/9.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/13.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/14.png" class="">
<h2 id="5-在本地使用Git"><a href="#5-在本地使用Git" class="headerlink" title="5.在本地使用Git"></a>5.在本地使用Git</h2><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/15.png" class="">
工作流程：</li>
<li>从远程仓库中克隆 Git 资源作为本地仓库。</li>
<li>从本地仓库中checkout代码然后进行代码修改</li>
<li>在提交前先将代码提交到暂存区。</li>
<li>提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。</li>
<li>在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。</li>
</ol>
<p>下图展示了 Git 的工作流程：</p>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/2.png" class="">
<h5 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Programmingmakesmebald&quot; #名称</span><br><span class="line">git config --global user.email &quot;1731082812@qq.com&quot;   #邮箱</span><br></pre></td></tr></table></figure>
<h5 id="SSH设置"><a href="#SSH设置" class="headerlink" title="SSH设置"></a>SSH设置</h5><p>现在本地生成ssh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 1701082812@qq.com</span><br></pre></td></tr></table></figure>
<p> 一直回车</p>
<p>GitHub上配置：<br>①github②settings③SSH and …④New SSH⑤ title任意⑥key中输入 刚才在本地生成的ssh（<br>将本地刚才生成的id_rsa.pub内容复制到远程的Key中）</p>
<p>测试连通性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果本地和远程成功通信，则可以在 /.ssh目录中 发现known_hosts文件如果失败：多尝试几次、检查回车符</p>
<h5 id="本地仓库初始化代码"><a href="#本地仓库初始化代码" class="headerlink" title="本地仓库初始化代码"></a>本地仓库初始化代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h5 id="在远程建立git项目"><a href="#在远程建立git项目" class="headerlink" title="在远程建立git项目"></a>在远程建立git项目</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①new②建立项目③ 生成  https:&#x2F;&#x2F;github.com&#x2F;Programmingmakesmebald&#x2F;First-GitHub.git</span><br></pre></td></tr></table></figure>

<h5 id="本地项目-远程项目关联"><a href="#本地项目-远程项目关联" class="headerlink" title="本地项目-远程项目关联"></a>本地项目-远程项目关联</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:yanqun&#x2F;mygitremote.git</span><br></pre></td></tr></table></figure>

<h5 id="工作区域（上传文件到Github）"><a href="#工作区域（上传文件到Github）" class="headerlink" title="工作区域（上传文件到Github）"></a>工作区域（上传文件到Github）</h5><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看工作区状态：git status</span><br><span class="line">添加到暂存区  ：git add 文件名.后缀名</span><br><span class="line">提交到本地仓库：git commit -m “提交描述”</span><br><span class="line">上传到远程仓库：git push</span><br></pre></td></tr></table></figure>
<p>第一次发布项目（本地-远程）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .    &#x2F;&#x2F;文件-暂存区.&quot;代表当前目录所有文件</span><br><span class="line">git commit -m “提交描述” &#x2F;&#x2F;暂存区在本地分支（默认master）</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>第一次下载项目（远程-本地）</p>
<p>下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Programmingmakesmebald&#x2F;First-GitHub.git</span><br></pre></td></tr></table></figure>
<p>提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “提交到分支描述”</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>更新（远程-本地）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/16.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/17.png" class="">
<h2 id="6-问题"><a href="#6-问题" class="headerlink" title="6.问题"></a>6.问题</h2><ol>
<li><h5 id="上传时要输入账号密码（私有项目，没有权限）"><a href="#上传时要输入账号密码（私有项目，没有权限）" class="headerlink" title="上传时要输入账号密码（私有项目，没有权限）"></a>上传时要输入账号密码（私有项目，没有权限）</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①在 .git文件 里面找到config 打开</span><br></pre></td></tr></table></figure>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/18.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/19.png" class="">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">②将 [remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;仓库名.git</span><br><span class="line">改为</span><br><span class="line">[remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;用户名:密码@github.com&#x2F;用户名&#x2F;仓库名.git</span><br><span class="line">列</span><br><span class="line">[remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;Rodma1:chenyun123@github.com&#x2F;Rodma1&#x2F;test.git</span><br><span class="line">保存就解决了</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="上传错误-（git-push）"><a href="#上传错误-（git-push）" class="headerlink" title="上传错误 （git push）"></a>上传错误 （git push）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：git pull --rebase origin master</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Git GitHub</category>
      </categories>
      <tags>
        <tag>Git GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客及使用</title>
    <url>/2020/07/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h3><h5 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;blogname&quot;</span><br></pre></td></tr></table></figure>
<h5 id="2-清除"><a href="#2-清除" class="headerlink" title="2. 清除"></a>2. 清除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<h5 id="3-生成"><a href="#3-生成" class="headerlink" title="3. 生成"></a>3. 生成</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h5 id="4-部署"><a href="#4-部署" class="headerlink" title="4. 部署"></a>4. 部署</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><h5 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1. 安装node.js"></a>1. 安装node.js</h5><h5 id="2-安装淘宝的cnpm-管理器"><a href="#2-安装淘宝的cnpm-管理器" class="headerlink" title="2. 安装淘宝的cnpm 管理器"></a>2. 安装淘宝的cnpm 管理器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h5 id="3-安装hexo框架"><a href="#3-安装hexo框架" class="headerlink" title="3. 安装hexo框架"></a>3. 安装hexo框架</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h5 id="4-生成博客-初始化博客"><a href="#4-生成博客-初始化博客" class="headerlink" title="4. 生成博客 初始化博客"></a>4. 生成博客 初始化博客</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h5 id="5-启动本地博客服务"><a href="#5-启动本地博客服务" class="headerlink" title="5. 启动本地博客服务"></a>5. 启动本地博客服务</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h5 id="6-本地访问地址"><a href="#6-本地访问地址" class="headerlink" title="6. 本地访问地址"></a>6. 本地访问地址</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h5 id="1-新建文章-1"><a href="#1-新建文章-1" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;文章名&quot; &#x2F;&#x2F;new</span><br></pre></td></tr></table></figure>
<h5 id="2-新建页面"><a href="#2-新建页面" class="headerlink" title="2. 新建页面"></a>2. 新建页面</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-本地运行-预览"><a href="#3-本地运行-预览" class="headerlink" title="3. 本地运行(预览)"></a>3. 本地运行(预览)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s &#x2F;&#x2F;sever</span><br></pre></td></tr></table></figure>
<h5 id="4-清除缓存"><a href="#4-清除缓存" class="headerlink" title="4. 清除缓存"></a>4. 清除缓存</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo c &#x2F;&#x2F;clean</span><br></pre></td></tr></table></figure>
<h5 id="5-生成"><a href="#5-生成" class="headerlink" title="5. 生成"></a>5. 生成</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &#x2F;&#x2F;generate</span><br></pre></td></tr></table></figure>

<h5 id="6-部署到github"><a href="#6-部署到github" class="headerlink" title="6. 部署到github"></a>6. 部署到github</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d &#x2F;&#x2F;deploy</span><br></pre></td></tr></table></figure>

<h5 id="7-推送到分支"><a href="#7-推送到分支" class="headerlink" title="7. 推送到分支"></a>7. 推送到分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<h3 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h3><h5 id="1-配置-config-yml"><a href="#1-配置-config-yml" class="headerlink" title="1. 配置_config.yml"></a>1. 配置_config.yml</h5><p><img src="https://note.youdao.com/yws/public/resource/c787d7b896281d5ba673d153aafef5fd/xmlnote/6C868E73909342698065B61509E7587A/1687" alt=""></p>
<h5 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2.更换主题"></a>2.更换主题</h5><p><img src="https://note.youdao.com/yws/public/resource/c787d7b896281d5ba673d153aafef5fd/xmlnote/8C90846B6AD84437BB71F132E432317F/1717" alt=""></p>
<h5 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h5><p>解决代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="https://note.youdao.com/yws/public/resource/c787d7b896281d5ba673d153aafef5fd/xmlnote/894FED74F0534D4DAA40DE1FB7AB33E7/1700" alt=""><br><img src="https://note.youdao.com/yws/public/resource/c787d7b896281d5ba673d153aafef5fd/xmlnote/8037CC2D4413440E9E5143802E03951E/1702" alt=""></p>
<h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><h5 id="hexo主题网站"><a href="#hexo主题网站" class="headerlink" title="hexo主题网站"></a><a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题网站</a></h5><h6 id="进入主题文件"><a href="#进入主题文件" class="headerlink" title="进入主题文件"></a>进入主题文件</h6><p><img src="https://note.youdao.com/yws/public/resource/c787d7b896281d5ba673d153aafef5fd/xmlnote/B511CE78EB56495988A526E8EB7CE6E0/1713" alt=""></p>
<h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Fechin&#x2F;hexo-theme-diaspora.git</span><br></pre></td></tr></table></figure>
<p><img src="https://note.youdao.com/yws/public/resource/c787d7b896281d5ba673d153aafef5fd/xmlnote/DD3AC86B27554C9E90FEC6A430544BE2/1726" alt=""></p>
]]></content>
      <categories>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM文件上传</title>
    <url>/2020/07/01/SSM%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="SSM–文件上传"><a href="#SSM–文件上传" class="headerlink" title="SSM–文件上传"></a>SSM–文件上传</h1><h3 id="1-配置（applicationContext-Controller-xml）"><a href="#1-配置（applicationContext-Controller-xml）" class="headerlink" title="1.配置（applicationContext-Controller.xml）"></a>1.配置（applicationContext-Controller.xml）</h3><p>在SpringMVC中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传的配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 上传单个文件的最大值，单位Byte，-1表示无限制 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"104857600"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-编写控制器（Controller）"><a href="#2-编写控制器（Controller）" class="headerlink" title="2.编写控制器（Controller）"></a>2.编写控制器（Controller）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testUpload"</span>)</span><br><span class="line">    <span class="function">String <span class="title">testUpload</span><span class="params">(@RequestParam(<span class="string">"miaoshu"</span>)</span> String desc,@<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"文件描述信息:%s"</span>,desc));</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        InputStream input = file.getInputStream();</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        OutputStream out=<span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1atupian\\"</span>+fileName);</span><br><span class="line">        <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = input.read(bs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.print(String.format(<span class="string">"上传成功!"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-前台上传框（jsp）"><a href="#3-前台上传框（jsp）" class="headerlink" title="3.前台上传框（jsp）"></a>3.前台上传框（jsp）</h3><p>form表单中需要注意的是上传的方式必须为Post  method=”post”</p>
<p>必须加上enctype=”multipart/form-data”属性   enctype=”multipart/form-data”</p>
<p>get的方式地址栏改变将显示文件的内容，若文件过大时地址栏的大小不能够放下该文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文件上传：</span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"controller/testUpload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">                请选择文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line">                文件的描述：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"miaoshu"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>SSM文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>图片处理</title>
    <url>/2020/07/01/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://note.youdao.com/yws/public/resource/c787d7b896281d5ba673d153aafef5fd/xmlnote/6C868E73909342698065B61509E7587A/1687" alt=""></p>
]]></content>
  </entry>
</search>
