<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01.Java语言概述</title>
    <url>/2020/07/03/01-Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、Java基础知识图解"><a href="#一、Java基础知识图解" class="headerlink" title="一、Java基础知识图解"></a>一、Java基础知识图解</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/1753" alt=""></p>
<h2 id="二、Windows操作cmd"><a href="#二、Windows操作cmd" class="headerlink" title="二、Windows操作cmd"></a>二、Windows操作cmd</h2><h4 id="1-常用DOS命令"><a href="#1-常用DOS命令" class="headerlink" title="1. 常用DOS命令"></a>1. 常用DOS命令</h4><ul>
<li>dir：列出当前目录下的文件及文件夹</li>
<li>md：创建目录</li>
<li>rd：删除目录</li>
<li>d：进入D盘</li>
<li>cd：进入到指定目录</li>
<li>cd..：返回上级目录</li>
<li>cd\：退回到根目录</li>
<li>echo&gt;xxx.xxx：创建xxx.xxx文件</li>
<li>echo xxx &gt;xxx.xxx：创建xxx.xxx文件并写入xxx</li>
<li>echo &gt;xxx.xxx xxx：创建xxx.xxx文件并写入xxx</li>
<li>del：删除文件</li>
<li>exit：退出dos命令行即退出cmd<h4 id="2-常用快捷键"><a href="#2-常用快捷键" class="headerlink" title="2. 常用快捷键"></a>2. 常用快捷键</h4></li>
<li>← →：移动光标</li>
<li>↑ ↓：调阅历史操作命令</li>
<li>Delete Backspace：删除字符<h2 id="三、Java语言"><a href="#三、Java语言" class="headerlink" title="三、Java语言"></a>三、Java语言</h2><h4 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a>1. 来源</h4>Java语言是SUN(Stanford University Network,斯坦福大学网络公司) 1995年推出的一门高级编程语言。<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4>Java语言是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序(applet)。applet使用现代的图形用户界面与Web用户进行交互。applet内嵌在HTML代码中。<h4 id="3-现状"><a href="#3-现状" class="headerlink" title="3. 现状"></a>3. 现状</h4>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。<h4 id="4-简史"><a href="#4-简史" class="headerlink" title="4. 简史"></a>4. 简史</h4></li>
<li>1991年Green项目，开发语言最初命名为Oak (橡树)</li>
<li>1994年，开发组意识到Oak非常适合于互联网</li>
<li>1996年，发布JDK 1.0，约8.3万 个网页应用Java技术来制作</li>
<li>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最</li>
<li>1998年，发布JDK 1.2，同年发布企业平台J2EE</li>
<li>1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技 术诞生</li>
<li>2004年，发布里程碑式版本: JDK 1.5，为突出此版本的重要性，更名为JDK 5.0</li>
<li>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE, J2ME -&gt; JavaME</li>
<li>2009年，Oracle公司收购SUN，交易价格74亿美元</li>
<li>2011年，发布JDK 7.0</li>
<li>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本</li>
<li>2017年，发布JDK 9.0，最大限度实现模块化</li>
<li>2018年3月，发布JDK 10.0，版本号也称为18.3</li>
<li>2018年9月，发布JDK 11.0，版本号也称为18.9<h4 id="5-Java语言的诞生"><a href="#5-Java语言的诞生" class="headerlink" title="5. Java语言的诞生"></a>5. Java语言的诞生</h4></li>
<li>java之父James Gosl ing团队在开发”Green”项目时，发现c缺少垃圾回收系统，还有可移植的安全性、分布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。</li>
<li>Java确实是从c语言和C++语言继承了许多成份，甚至可以将Java看成是类c语言发展和衍生的产物。比如Java语言的变量声明，操作符形式，参数传递，流程控制等方面和C语言、C++语言完全相同。但同时，Java是一个纯粹的面向对象的程序设计语言，它继承了C++语言面向对象技术的核心。Java舍弃了c语言中容易引起错误的指针(以引用取代)、运算符重载(operator overloading)、多重继承<br>(以接口取代)等特性，增加了垃圾回收器功能用于回收不再被引用的对象所占据的内存空间。JDK1.5又引入了泛型编程(GenericProgramming)、类型安全的枚举、不定长参数和自动装/拆箱<h4 id="6-Java的主要特性"><a href="#6-Java的主要特性" class="headerlink" title="6. Java的主要特性"></a>6. Java的主要特性</h4></li>
<li><h5 id="Java语言是易学的"><a href="#Java语言是易学的" class="headerlink" title="Java语言是易学的"></a>Java语言是易学的</h5>  Java语言的语法与c语言和C++语言很接近，使得大多数程序员很容易学习和使用Java。</li>
<li><h5 id="Java语言是强制面向对象的"><a href="#Java语言是强制面向对象的" class="headerlink" title="Java语言是强制面向对象的"></a>Java语言是强制面向对象的</h5>  Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制<br>(关键字为implements)。</li>
<li><h5 id="Java语言是分布式的"><a href="#Java语言是分布式的" class="headerlink" title="Java语言是分布式的"></a>Java语言是分布式的</h5>  Java语 言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口(java net) ，它提供了用于网络应用编程的类<br>库，包括URL、URLConnection、 Socket、 ServerSocket等。 Java 的RMI (远程<br>方法激活)机制也是开发分布式应用的重要手段。</li>
<li><h5 id="Java语言是健壮的"><a href="#Java语言是健壮的" class="headerlink" title="Java语言是健壮的"></a>Java语言是健壮的</h5>  Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。</li>
<li><h5 id="Java语言是安全的"><a href="#Java语言是安全的" class="headerlink" title="Java语言是安全的"></a>Java语言是安全的</h5>  Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如:安全防范机制(类ClassLoader)，如分配不同的名字空间以防替代本地的同名类、字节代码检查。</li>
<li><h5 id="Java语言是体系结构中立的"><a href="#Java语言是体系结构中立的" class="headerlink" title="Java语言是体系结构中立的"></a>Java语言是体系结构中立的</h5>  Java程序(后缀为java的文件)在Java平台上被<br>编译为体系结构中立的字节码格式(后缀为class的文件)，然后可以在实现这个</li>
<li><h5 id="Java平台的任何系统中运行"><a href="#Java平台的任何系统中运行" class="headerlink" title="Java平台的任何系统中运行"></a>Java平台的任何系统中运行</h5>  Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统的解释器中运行。</li>
<li><h5 id="Java是性能略高的"><a href="#Java是性能略高的" class="headerlink" title="Java是性能略高的"></a>Java是性能略高的</h5>  与那些解释型的高级脚本语言相比，Java的性能还是较优的。</li>
<li><h5 id="Java语言是原生支持多线程的"><a href="#Java语言是原生支持多线程的" class="headerlink" title="Java语言是原生支持多线程的"></a>Java语言是原生支持多线程的</h5>  在Java语言中，线程是一-种特殊的对象，它必须<br>由Thread类或其子(孙)类来创建。</li>
</ul>
<h4 id="7-Java技术平台"><a href="#7-Java技术平台" class="headerlink" title="7. Java技术平台"></a>7. Java技术平台</h4><ul>
<li><h5 id="Java-SE-Java-Standard-Edition-标准版"><a href="#Java-SE-Java-Standard-Edition-标准版" class="headerlink" title="Java SE(Java Standard Edition)标准版"></a>Java SE(Java Standard Edition)标准版</h5>  支持面向桌面级应用(如Windows’下的应用程序)的Java平台，提供了完整的Java核心API，此版本以前称为J2SE</li>
<li><h5 id="Java-EE-Java-Enterprise-Edition-企业版"><a href="#Java-EE-Java-Enterprise-Edition-企业版" class="headerlink" title="Java EE(Java Enterprise Edition)企业版"></a>Java EE(Java Enterprise Edition)企业版</h5>  是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等 ,主要针对于Web应用程序开发。版本以前称为J2EE<h4 id="8-Java应用领域"><a href="#8-Java应用领域" class="headerlink" title="8.Java应用领域"></a>8.Java应用领域</h4>从Java的应用领域来分，Java语言的应用方向主要表现在以下几个方面:</li>
<li><h5 id="企业级应用"><a href="#企业级应用" class="headerlink" title="企业级应用"></a>企业级应用</h5>  主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</li>
<li><h5 id="Android平台应用"><a href="#Android平台应用" class="headerlink" title="Android平台应用"></a>Android平台应用</h5>  Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实。</li>
<li><h5 id="大数据平台开发"><a href="#大数据平台开发" class="headerlink" title="大数据平台开发"></a>大数据平台开发</h5>  各类框架有Hadoop, spark, storm,flink等，就这类技术生态圈来讲，还有各种中间件如flume, kafka, sqoop等等 ，这些框架以及工具大多数是用Java编写而成，但提供诸如Java, sscala,Python,R等各种语言API供编程。</li>
<li><h5 id="移动领域应用"><a href="#移动领域应用" class="headerlink" title="移动领域应用"></a>移动领域应用</h5>  主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。<h2 id="四、Java语言运行机制及运行过程"><a href="#四、Java语言运行机制及运行过程" class="headerlink" title="四、Java语言运行机制及运行过程"></a>四、Java语言运行机制及运行过程</h2></li>
</ul>
<ol>
<li><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ol>
<li><h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多肽</li>
</ul>
</li>
<li><h5 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h5><ul>
<li>吸收了C/C++语言的优点，但是去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供一个相对安全的内存管理和访问机制</li>
</ul>
</li>
<li><h5 id="跨平台性"><a href="#跨平台性" class="headerlink" title="跨平台性"></a>跨平台性</h5><ul>
<li>跨平台性：通过Java语言编程的应用程序在不同平台上都可以运行。“Write once，Run Anywhere”</li>
<li>原理:只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。<br><img src="http://qd1ql2976.bkt.clouddn.com/2003" alt=""></li>
</ul>
</li>
</ol>
</li>
<li><h4 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h4></li>
</ol>
<ul>
<li>Java虚拟机（Java Virtual Machine）</li>
<li>垃圾收集机制（Garbage Collection）</li>
</ul>
<ol start="3">
<li><h4 id="核心机制——Java虚拟机"><a href="#核心机制——Java虚拟机" class="headerlink" title="核心机制——Java虚拟机"></a>核心机制——Java虚拟机</h4></li>
</ol>
<ul>
<li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。<br><img src="http://qd1ql2976.bkt.clouddn.com/2047" alt=""></li>
<li>对于不同的平台，有不同的虚拟机。</li>
<li>只有某平台提供了对应的java虚拟机，java程序才可在此平台运行</li>
<li>Java虛拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”<br><img src="http://qd1ql2976.bkt.clouddn.com/2049" alt=""></li>
</ul>
<ol start="4">
<li><h4 id="核心机制——垃圾回收"><a href="#核心机制——垃圾回收" class="headerlink" title="核心机制——垃圾回收"></a>核心机制——垃圾回收</h4></li>
</ol>
<ul>
<li><p>不再使用的内存空间应回收一垃圾回收。</p>
<ul>
<li>在C/C++等语言中，由程序员负责回收无用内存。</li>
<li>Java语言消除了程序员回收无用内存空间的责任:它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。</li>
</ul>
</li>
<li><p>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</p>
</li>
<li><p>Java程序还会出现内存泄漏和内存溢出问题吗?会!</p>
<h2 id="五、Java语言的环境搭建"><a href="#五、Java语言的环境搭建" class="headerlink" title="五、Java语言的环境搭建"></a>五、Java语言的环境搭建</h2></li>
<li><h4 id="JDK-Java-Development-Kit-Java开发工具包"><a href="#JDK-Java-Development-Kit-Java开发工具包" class="headerlink" title="JDK(Java Development Kit Java开发工具包)"></a>JDK(Java Development Kit Java开发工具包)</h4><p>  JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。</p>
<h5 id="其中的开发工具"><a href="#其中的开发工具" class="headerlink" title="其中的开发工具:"></a>其中的开发工具:</h5><ul>
<li>译工具(javac.exe)</li>
<li>打包工具(jar.exe)等</li>
</ul>
</li>
<li><h4 id="JRE-Java-Runtime-Environment-Java运-行环境"><a href="#JRE-Java-Runtime-Environment-Java运-行环境" class="headerlink" title="JRE(Java Runtime Environment Java运 行环境)"></a>JRE(Java Runtime Environment Java运 行环境)</h4><p>  包括Java虛拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
</li>
<li><h4 id="JDK、JRE、JVM的关系"><a href="#JDK、JRE、JVM的关系" class="headerlink" title="JDK、JRE、JVM的关系"></a>JDK、JRE、JVM的关系</h4><p>  <img src="http://qd1ql2976.bkt.clouddn.com/2085" alt=""><br>  <img src="http://qd1ql2976.bkt.clouddn.com/2087" alt=""></p>
</li>
<li><h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><p>  <img src="http://qd1ql2976.bkt.clouddn.com/2095" alt=""><br>  <img src="http://qd1ql2976.bkt.clouddn.com/2097" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>01.数据结构</title>
    <url>/2020/07/04/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构包括：线性结构和非线性结构。</p>
<ul>
<li><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</li>
<li>线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。</li>
<li>顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。</li>
<li>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</li>
<li>线性结构常见的有：数组、队列、链表和栈。</li>
</ol>
</li>
<li><h4 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h4><ol>
<li>二维数组</li>
<li>多维数组</li>
<li>广义表</li>
<li>树结构</li>
<li>图结构</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>线性结构</tag>
        <tag>非线性结构</tag>
        <tag>顺序存储结构</tag>
        <tag>链式存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title>02.数据结构-稀疏sparsearray数组</title>
    <url>/2020/07/04/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8Fsparsearray%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="稀疏sparsearray数组"><a href="#稀疏sparsearray数组" class="headerlink" title="稀疏sparsearray数组"></a>稀疏sparsearray数组</h2><ol>
<li><h4 id="先看一个实际的需求"><a href="#先看一个实际的需求" class="headerlink" title="先看一个实际的需求"></a>先看一个实际的需求</h4><ul>
<li>编写的五子棋程序中，有存盘退出和续上盘的功能。<br><img src="http://qd1ql2976.bkt.clouddn.com/2296" alt=""></li>
<li>分析问题: 因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据→稀疏数组。</li>
</ul>
</li>
<li><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p> 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<h5 id="稀疏数组的处理方法是"><a href="#稀疏数组的处理方法是" class="headerlink" title="稀疏数组的处理方法是:"></a>稀疏数组的处理方法是:</h5><ol>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模<h5 id="稀疏数组举例说明"><a href="#稀疏数组举例说明" class="headerlink" title="稀疏数组举例说明"></a>稀疏数组举例说明</h5><img src="http://qd1ql2976.bkt.clouddn.com/2307" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2309" alt=""></li>
</ol>
</li>
<li><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ul>
<li><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</p>
</li>
<li><p>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</p>
</li>
<li><p>整体思路分析<br><img src="http://qd1ql2976.bkt.clouddn.com/2326" alt=""></p>
</li>
<li><p>二维数组 转 稀疏数组的思路</p>
<ol>
<li>遍历  原始的二维数组，得到有效数据的个数 sum</li>
<li>根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]</li>
<li>将二维数组的有效数据数据存入到 稀疏数组</li>
</ol>
</li>
<li><p>稀疏数组转原始的二维数组的思路</p>
<ol>
<li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</li>
<li>在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.sparsearray;</span><br><span class="line"></span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; 创建11*11的二维数组</span><br><span class="line">		int[][] chessArr1&#x3D;new int[11][11];</span><br><span class="line">		&#x2F;&#x2F; 0代表没有棋子，1代表黑子，2代表蓝子</span><br><span class="line">		chessArr1[1][2]&#x3D;1;</span><br><span class="line">		chessArr1[2][3]&#x3D;2;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出原始二维数组chessArr1</span><br><span class="line">		System.out.println(&quot;输出原始的二维数组chessArr1&quot;);</span><br><span class="line">		for (int[] row : chessArr1)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 将二维数组 转 稀疏数组</span><br><span class="line">		&#x2F;&#x2F; 遍历chessArr1  非0数据的个数计为sum</span><br><span class="line">		int sum&#x3D;0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; chessArr1.length; i++)&#123;</span><br><span class="line">			for(int j &#x3D; 0;j &lt; chessArr1.length; j++)&#123;</span><br><span class="line">				if(chessArr1[i][j] !&#x3D; 0)&#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 输出sum</span><br><span class="line">		System.out.println(&quot;sum&#x3D;&quot;+sum);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建稀疏数组</span><br><span class="line">		int[][] sparseArr &#x3D; new int[sum+1][3];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 给稀疏数组赋值</span><br><span class="line">		sparseArr[0][0] &#x3D; 11;</span><br><span class="line">		sparseArr[0][1] &#x3D; 11;</span><br><span class="line">		sparseArr[0][2] &#x3D; sum;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 遍历原始二维数组，将非0的值存放到 sparseArr中</span><br><span class="line">		int count &#x3D; 0; &#x2F;&#x2F;count 用于记录是第几个非0数据</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 11; i++)&#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 11; j++)&#123;</span><br><span class="line">				if (chessArr1[i][j] !&#x3D;0 )&#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][0] &#x3D; i;</span><br><span class="line">					sparseArr[count][1] &#x3D; j;</span><br><span class="line">					sparseArr[count][2] &#x3D; chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出稀疏数组</span><br><span class="line">		System.out.println(&quot;得到稀疏数组为~~~~&quot;);</span><br><span class="line">		for (int[] row : sparseArr)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 将稀疏数组 --》 恢复成 原始的二维数组</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 &#x3D; int [11][11]</span><br><span class="line">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span><br><span class="line">		int[][] chessArr2 &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span><br><span class="line">		for (int i &#x3D; 1; i &lt; sparseArr.length; i++)&#123;</span><br><span class="line">			chessArr2[sparseArr[1][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出原始二维数组chessArr2</span><br><span class="line">		System.out.println(&quot;恢复后的二维数组chessArr2&quot;);</span><br><span class="line">		for (int[] row : chessArr2)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>稀疏数组</tag>
        <tag>sparsearray</tag>
      </tags>
  </entry>
  <entry>
    <title>02.Java基础知识-文档及规范</title>
    <url>/2020/07/03/02-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%96%87%E6%A1%A3%E5%8F%8A%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="一、Java-API文档"><a href="#一、Java-API文档" class="headerlink" title="一、Java API文档"></a>一、Java API文档</h2><ul>
<li>API (Application Programming Interface,应用程序编程接口)是Java提供的基本编程接口。</li>
<li>Java语言提供了大量的基础类，因此Oracle也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。</li>
<li>下载API: <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br><img src="http://qd1ql2976.bkt.clouddn.com/2119" alt=""><h2 id="二、良好的编程风格"><a href="#二、良好的编程风格" class="headerlink" title="二、良好的编程风格"></a>二、良好的编程风格</h2></li>
<li><h4 id="正确的注释和注释风格"><a href="#正确的注释和注释风格" class="headerlink" title="正确的注释和注释风格"></a>正确的注释和注释风格</h4><ul>
<li>使用文档注释来注释整个类或整个方法。</li>
<li>如果注释方法中的某一一个步骤，使用单行或多行注释。</li>
</ul>
</li>
<li><h4 id="正确的缩进和空白"><a href="#正确的缩进和空白" class="headerlink" title="正确的缩进和空白"></a>正确的缩进和空白</h4><ul>
<li>使用一次tab操作，实现缩进</li>
<li>运算符两边习惯性各加一一个空格。比如: 2+4* 5。</li>
</ul>
</li>
<li><h4 id="块的风格"><a href="#块的风格" class="headerlink" title="块的风格"></a>块的风格</h4><ul>
<li>JavaAPI源代码选择了行尾风格<br><img src="http://qd1ql2976.bkt.clouddn.com/2135" alt=""><h2 id="三、注释"><a href="#三、注释" class="headerlink" title="三、注释"></a>三、注释</h2></li>
</ul>
</li>
<li>用于注解说明解释程序的文字就是注释。</li>
<li>Java中的注释类型:<ul>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释(java特有)</li>
</ul>
</li>
<li>提高了代码的阅读性;调试程序的重要方法。</li>
<li>注释是一个程序员必须要具有的良好编程习惯。</li>
<li>将自己的思想通过注释先整理出来，再用代码去体现</li>
<li><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式: &#x2F;&#x2F;注释文字</span><br></pre></td></tr></table></figure></li>
<li><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式: &#x2F;*注释文字*&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h4><ul>
<li>对于单行和多行注释，被注释的文字，不会被JVM (java虚拟机)解释执行。</li>
<li>多行注释里面不允许有多行注释嵌套。</li>
</ul>
</li>
<li><h4 id="文档注释-Java特有"><a href="#文档注释-Java特有" class="headerlink" title="文档注释(Java特有)"></a>文档注释(Java特有)</h4>  格式:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">@author指定java程序的作者</span><br><span class="line">@version指定源文件的版本</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="javadoc解析"><a href="#javadoc解析" class="headerlink" title="javadoc解析"></a>javadoc解析</h4><ul>
<li>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。<br><img src="http://qd1ql2976.bkt.clouddn.com/2176" alt=""><h2 id="四、注释示例"><a href="#四、注释示例" class="headerlink" title="四、注释示例"></a>四、注释示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">1. java规范的三种注释方式：</span><br><span class="line">单行注释</span><br><span class="line">多行注释</span><br><span class="line">文档注释(java特有)</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">单行注释和多行注释的作用：</span><br><span class="line">① 对所写的程序进行解释说明，增强可读性。方便自己，方便别人</span><br><span class="line">② 调试所写的代码</span><br><span class="line"></span><br><span class="line">3. 特点：单行注释和多行注释，注释了的内容不参与编译。</span><br><span class="line">         换句话说，编译以后生成的.class结尾的字节码文件中不包含注释掉的信息</span><br><span class="line"></span><br><span class="line">4. 文档注释的使用：</span><br><span class="line">    注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</span><br><span class="line"></span><br><span class="line">5. 多行注释不可以嵌套使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">文档注释</span><br><span class="line">@author shkstart</span><br><span class="line">@version v1.0</span><br><span class="line">这是我的第一个java程序！非常的开森！</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">public class HelloJava&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	多行注释：</span><br><span class="line">	如下的main方法是程序的入口！</span><br><span class="line">	main的格式是固定的！</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	如下的方式是main()，作用：程序的入口。</span><br><span class="line">	*&#x2F;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		&#x2F;&#x2F;单行注释：如下的语句表示输出到控制台</span><br><span class="line">		&#x2F;&#x2F;System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>03.Java基础知识-HelloWorld</title>
    <url>/2020/07/03/03-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-HelloWorld/</url>
    <content><![CDATA[<h2 id="一、开发步骤"><a href="#一、开发步骤" class="headerlink" title="一、开发步骤"></a>一、开发步骤</h2><ol>
<li><h5 id="将Java代码编写到扩展名为-java的文件中"><a href="#将Java代码编写到扩展名为-java的文件中" class="headerlink" title="将Java代码编写到扩展名为.java的文件中"></a>将Java代码编写到扩展名为.java的文件中</h5></li>
<li><h5 id="通过javac命令对该java文件进行编译。"><a href="#通过javac命令对该java文件进行编译。" class="headerlink" title="通过javac命令对该java文件进行编译。"></a>通过javac命令对该java文件进行编译。</h5></li>
<li><h5 id="通过java命令对生成的class文件进行运行"><a href="#通过java命令对生成的class文件进行运行" class="headerlink" title="通过java命令对生成的class文件进行运行"></a>通过java命令对生成的class文件进行运行</h5><h2 id="二、步骤一：编写"><a href="#二、步骤一：编写" class="headerlink" title="二、步骤一：编写"></a>二、步骤一：编写</h2></li>
</ol>
<ul>
<li>选择最简单的编辑器:记事本。敲入代码  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>将文件保存成Test.java,这个文件是存放java代码的文件，称为源文件。</li>
<li>注意拓展名是否隐藏<br><img src="http://qd1ql2976.bkt.clouddn.com/2202" alt=""><h2 id="三、步骤二：编译"><a href="#三、步骤二：编译" class="headerlink" title="三、步骤二：编译"></a>三、步骤二：编译</h2><img src="http://qd1ql2976.bkt.clouddn.com/2229" alt=""></li>
<li>有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件。</li>
<li>在该源文件目录下，通过javac编译工具对Test.java文件进行编译。</li>
<li>如果程序没有错误，没有任何提示，但在当前目录下会出现一个Test.class文件，该文件称为字节码文件，也是可以执行的java的程序。<h2 id="四、步骤三：运行"><a href="#四、步骤三：运行" class="headerlink" title="四、步骤三：运行"></a>四、步骤三：运行</h2></li>
<li>有了可执行的java程序(Test.class字节码文件)</li>
<li>通过运行工具java.exe对字节码文件进行执行。</li>
<li>出现提示:缺少一个名称为main的方法。<br><img src="http://qd1ql2976.bkt.clouddn.com/2231" alt=""></li>
<li>因为一个程序的执行需要-一个起始点或者入口，所以在Test类中的加入  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void</span><br><span class="line">main(String] args)&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>对修改后的Test.java源文件需要重新编译，生成新的class文件后，再进行执行。</li>
<li>发现没有编译失败，但也没有任何效果，因为并没有告诉JVM要帮我们做什么事情，也就是没有可以具体执行的语句。</li>
<li>想要和JVM来个互动，只要在main方法中加入一句  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.printn(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure></li>
<li>因为程序进行改动，所以再重新编译，运行即可。<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2></li>
<li>学习编程最容易犯的错是语法错误。</li>
<li>Java要求你必须按照语法规则编写代码。</li>
<li>如果你的程序违反了语法规则。例如:忘记了分号、大括号、引号，或者拼错了单词，java编译器都会报语法错误。</li>
<li>尝试着去看懂编译器会报告的错误信息。</li>
</ul>
<p><img src="http://qd1ql2976.bkt.clouddn.com/2233" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2235" alt=""></p>
<h2 id="六、代码示例"><a href="#六、代码示例" class="headerlink" title="六、代码示例"></a>六、代码示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">对第一个java程序进行总结</span><br><span class="line">1. java程序编写-编译-运行的过程</span><br><span class="line">编写：我们将编写的java代码保存在以&quot;.java&quot;结尾的源文件中</span><br><span class="line">编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java</span><br><span class="line">运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。</span><br><span class="line">而且要求声明为public的类的类名必须与源文件名相同。</span><br><span class="line"></span><br><span class="line">3. 程序的入口是main()方法。格式是固定的。</span><br><span class="line"></span><br><span class="line">4. 输出语句：</span><br><span class="line">System.out.println():先输出数据，然后换行</span><br><span class="line">System.out.print():只输出数据</span><br><span class="line"></span><br><span class="line">5.每一行执行语句都以&quot;;&quot;结束。</span><br><span class="line"></span><br><span class="line">6.编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">	public static void main(String[] args) &#123;&#x2F;&#x2F;public static void main(String a[]) &#123;&#x2F;&#x2F;arguments:参数</span><br><span class="line">		System.out.print(&quot;Hello World!&quot;);</span><br><span class="line">		System.out.println();&#x2F;&#x2F;换行</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>04.Java基础知识-关键字、保留字与标识符</title>
    <url>/2020/07/05/04-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h2><ul>
<li><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul>
<li><strong>定义</strong>：被Java 语言赋予了特殊含义，用做专门用途的字符串（单词）</li>
<li><strong>特点</strong>：关键字中所有字母都为小写</li>
<li><strong>官方地址</strong>： <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a><br><img src="http://qd1ql2976.bkt.clouddn.com/2416" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2419" alt=""></li>
<li><strong>注</strong>：true、false、null虽然不是关键字，但是命名时不可用。</li>
</ul>
</li>
<li><h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><ul>
<li><strong>Java保留字</strong>：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字goto 、const<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2></li>
</ul>
</li>
<li><h4 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li>
<li><strong>技巧</strong>：凡是自己可以起名字的地方都叫标识符。</li>
</ul>
</li>
<li><h4 id="定义合法标识符规则"><a href="#定义合法标识符规则" class="headerlink" title="定义合法标识符规则"></a>定义合法标识符规则</h4><ul>
<li>由26 个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格</li>
</ul>
</li>
<li><h4 id="Java中的名称命名规范"><a href="#Java中的名称命名规范" class="headerlink" title="Java中的名称命名规范"></a>Java中的名称命名规范</h4><ul>
<li><strong>包名</strong>：多单词组成时所有字母都小写：xxxyyyzzz</li>
<li><strong>类名、接口名</strong>：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
<li><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li>
<li><strong>常量名</strong>：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ul>
</li>
<li><strong>注意1</strong>：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</li>
<li><strong>注意2</strong>：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>关键字</tag>
        <tag>保留字</tag>
        <tag>标识符</tag>
      </tags>
  </entry>
  <entry>
    <title>04.数据结构-链表</title>
    <url>/2020/07/06/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一、链表-Linked-List-介绍"><a href="#一、链表-Linked-List-介绍" class="headerlink" title="一、链表(Linked List)介绍"></a>一、链表(Linked List)介绍</h2><p>链表是有序的列表，但是它在内存中是存储如下</p>
<p><img src="http://qd1ql2976.bkt.clouddn.com/2630" alt=""></p>
<p><strong>上图小结:</strong></p>
<ul>
<li>链表是以节点的方式来存储,是链式存储</li>
<li>每个节点包含 data 域， next 域：指向下一个节点.</li>
<li>如图：发现链表的各个节点不一定是连续存储.</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定<ul>
<li>单链表(带头结点) 逻辑结构示意图如下<br><img src="http://qd1ql2976.bkt.clouddn.com/2633" alt=""><h2 id="二、单链表的应用实例"><a href="#二、单链表的应用实例" class="headerlink" title="二、单链表的应用实例"></a>二、单链表的应用实例</h2>使用带 head 头的单向链表实现–水浒英雄排行榜管理完成对英雄人物的增删改查操作。<br><img src="http://qd1ql2976.bkt.clouddn.com/2635" alt=""></li>
</ul>
</li>
</ul>
<ol>
<li><p>第一种方法在添加英雄时，直接添加到链表的尾部<br>思路分析示意图:<br><img src="http://qd1ql2976.bkt.clouddn.com/2637" alt=""></p>
</li>
<li><p>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)<br>思路的分析示意图:<br><img src="http://qd1ql2976.bkt.clouddn.com/2639" alt=""></p>
</li>
<li><p>修改节点功能<br>思路<br>先找到该节点，通过遍历</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.name &#x3D; newHeroNode.name ;</span><br><span class="line">temp.nickname&#x3D; newHeroNode.nickname</span><br></pre></td></tr></table></figure></li>
<li><p>删除节点<br>思路分析的示意图:<br><img src="http://qd1ql2976.bkt.clouddn.com/2641" alt=""></p>
</li>
<li><p>代码演示:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个链表</span><br><span class="line">		SingleLinkedList singlelinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode h1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">		HeroNode h2 &#x3D; new HeroNode(2,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">		HeroNode h3 &#x3D; new HeroNode(3,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode h4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		&#x2F;&#x2F;直接添加无排序</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h1);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h2);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h3);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h4);</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		singlelinkedList.addByOrder(h3);</span><br><span class="line">		singlelinkedList.addByOrder(h2);</span><br><span class="line">		singlelinkedList.addByOrder(h4);</span><br><span class="line">		singlelinkedList.addByOrder(h1);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		System.out.println(&quot;修改豹子头林冲&quot;);</span><br><span class="line">		HeroNode h5 &#x3D; new HeroNode(4,&quot;林冲~~~&quot;,&quot;豹子头~~~&quot;);</span><br><span class="line">		singlelinkedList.update(h5);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		&#x2F;&#x2F;删除</span><br><span class="line">		System.out.println(&quot;删除豹子头林冲&quot;);</span><br><span class="line">		singlelinkedList.delete(1);</span><br><span class="line">		singlelinkedList.delete(2);</span><br><span class="line">		singlelinkedList.delete(3);</span><br><span class="line">		singlelinkedList.delete(4);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义SingleLinkedList 管理我们的英雄</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">	&#x2F;&#x2F;思路，当不考虑编号顺序时</span><br><span class="line">	&#x2F;&#x2F;1. 找到当前链表的最后节点</span><br><span class="line">	&#x2F;&#x2F;2. 将最后这个节点的next 指向 新的节点</span><br><span class="line">	public void add(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		&#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			&#x2F;&#x2F;找到链表的最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;遍历结束</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;如果没有找到最后, 将将temp后移</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;当退出while循环时，temp就指向了链表的最后</span><br><span class="line">		&#x2F;&#x2F;将最后这个节点的next 指向 新的节点</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;添加成功&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span><br><span class="line">	&#x2F;&#x2F;(如果有这个排名，则添加失败，并给出提示)</span><br><span class="line">	public void addByOrder(HeroNode heroNode)&#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span><br><span class="line">		&#x2F;&#x2F;因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F; flag标志添加的编号是否存在，默认为false</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break ;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else if(temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;后移，遍历当前链表</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			System.out.printf(&quot;添加失败，排名为%d的英雄已经存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;插入到链表中, temp的后面</span><br><span class="line">			heroNode.next &#x3D; temp.next;</span><br><span class="line">			temp.next &#x3D; heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改节点的信息, 根据no编号来修改，即no编号不能改.</span><br><span class="line">	&#x2F;&#x2F;说明</span><br><span class="line">	&#x2F;&#x2F;1. 根据 newHeroNode 的 no 来修改即可</span><br><span class="line">	public void update(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;遍历</span><br><span class="line">		&#x2F;&#x2F;找到需要修改的节点, 根据no编号</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F;表示是否找到该节点</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;&#x2F;&#x2F;已经遍历完链表</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;&#x2F;&#x2F;找到</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;根据flag 判断是否找到要修改的节点</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			temp.next.name &#x3D; heroNode.name;</span><br><span class="line">			temp.next.nickName &#x3D; heroNode.nickName;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	&#x2F;&#x2F;思路</span><br><span class="line">	&#x2F;&#x2F;1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span><br><span class="line">	&#x2F;&#x2F;2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span><br><span class="line">	public void delete(int no)&#123;</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false; &#x2F;&#x2F; 标志是否找到待删除节点的</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; no)&#123;&#x2F;&#x2F;找到的待删除节点的前一个节点temp</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;temp后移，遍历</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;判断flag</span><br><span class="line">		if (flag)&#123; &#x2F;&#x2F;找到</span><br><span class="line">			temp.next &#x3D; temp.next.next;&#x2F;&#x2F;可以删除</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示链表[遍历]</span><br><span class="line">	public void list()&#123;</span><br><span class="line">		&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;链表为空，没有数据！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;输出节点的信息</span><br><span class="line">			System.out.println(temp.next);</span><br><span class="line">			&#x2F;&#x2F;将temp后移， 一定小心</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">	int no;</span><br><span class="line">	String name;</span><br><span class="line">	String nickName;</span><br><span class="line">	HeroNode next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode(int no, String name, String nickName)&#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickName &#x3D; nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickName&#x3D;&quot; + nickName  + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title>05.Java基础知识-变量与数据类型</title>
    <url>/2020/07/05/05-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><ul>
<li><p><strong>变量的概念</strong>：</p>
<ul>
<li>内存中的一个存储区域</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元。包含变量类型、变变量名和存储的值</li>
</ul>
</li>
<li><p><strong>变量的作用</strong>：</p>
<ul>
<li>用于在内存中保存数据</li>
</ul>
</li>
<li><p><strong>使用变量注意</strong>：</p>
<ul>
<li>Java中每个变量必须先声明，后使用</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量的作用域：其定义所在的一对{ }内</li>
<li>变量只有在其作用域内才有效</li>
<li>同一个作用域内，不能定义重名的变量</li>
</ul>
</li>
<li><p><strong>声明变量</strong></p>
<ul>
<li>语法：&lt;数据类型&gt; &lt;变量名称&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int var;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>变量的赋值</strong></p>
<ul>
<li>语法：&lt;变量名称&gt; = &lt;值&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var &#x3D; 10;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>声明和赋值变量</strong></p>
<ul>
<li>语法： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int var &#x3D; 10;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>变量的分类-按数据类型</strong></p>
<ul>
<li>对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间。<br><img src="http://qd1ql2976.bkt.clouddn.com/2483" alt=""></li>
</ul>
</li>
<li><p><strong>变量的分类-按声明的位置的不同</strong></p>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量<br><img src="http://qd1ql2976.bkt.clouddn.com/2486" alt=""></li>
<li>注意：二者在初始化值方面的异同:<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，需显式初始化。<h2 id="二、整数类型"><a href="#二、整数类型" class="headerlink" title="二、整数类型"></a>二、整数类型</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。</p>
</li>
<li><p>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</p>
</li>
<li><p>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long<br><img src="http://qd1ql2976.bkt.clouddn.com/2510" alt=""></p>
</li>
<li><p>500MB 1MB = 1024KB 1KB= 1024B B= byte ? bit?<br>bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。</p>
<h2 id="三、浮点类型"><a href="#三、浮点类型" class="headerlink" title="三、浮点类型"></a>三、浮点类型</h2></li>
<li><p>与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。</p>
</li>
<li><p>浮点型常量有两种表示形式：</p>
<ul>
<li>十进制数形式：如：5.12、512.0f、.512 (必须有小数点）</li>
<li>科学计数法形式:如：5.12e2、512E2、100E-2</li>
</ul>
</li>
<li><p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。</p>
</li>
<li><p>double:双精度，精度是float的两倍。通常采用此类型。</p>
</li>
<li><p>Java 的浮点型常量默认为double型，声明float 型常量，须后加‘f’ 或‘F’ 。<br><img src="http://qd1ql2976.bkt.clouddn.com/2512" alt=""></p>
<h2 id="四、字符类型"><a href="#四、字符类型" class="headerlink" title="四、字符类型"></a>四、字符类型</h2></li>
<li><p>char 型数据用来表示通常意义上“字符”(2字节)</p>
</li>
<li><p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</p>
</li>
<li><p>字符型变量的三种表现形式：</p>
<ul>
<li>字符常量是用单引号(‘ ‘)括起来的单个字符。例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c1 &#x3D; &#39;a&#39;;</span><br><span class="line">char c2&#x3D; &#39;中&#39;;</span><br><span class="line">char c3 &#x3D; &#39;9&#39;;</span><br></pre></td></tr></table></figure></li>
<li>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c3 &#x3D; ‘\n’; &#x2F;&#x2F; &#39;\n&#39;表示换行符</span><br></pre></td></tr></table></figure>
  <img src="http://qd1ql2976.bkt.clouddn.com/2514" alt=""></li>
<li>直接使用 Unicode值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个十六进制整数。如：\u000a 表示 \n。</li>
</ul>
</li>
<li><p>char类型是可以进行运算的。因为它都对应有Unicode码。</p>
<h2 id="五、布尔类型"><a href="#五、布尔类型" class="headerlink" title="五、布尔类型"></a>五、布尔类型</h2></li>
<li><p>boolean 类型用来判断逻辑条件，一般用于程序流程控制：</p>
<ul>
<li>if条件控制语句；</li>
<li>while循环控制语句；</li>
<li>do-while循环控制语句；</li>
<li>for循环控制语句；</li>
</ul>
</li>
<li><p>boolean类型数据只允许取值true和false，无null。</p>
<ul>
<li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</li>
<li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。———《java虚拟机规范 8版》<h2 id="六、String字符串类型"><a href="#六、String字符串类型" class="headerlink" title="六、String字符串类型"></a>六、String字符串类型</h2></li>
</ul>
</li>
<li><p>String不是基本数据类型，属于引用数据类型</p>
</li>
<li><p>使用方式与基本数据类型一致。例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; “abcd”;</span><br></pre></td></tr></table></figure></li>
<li><p>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; str + “xyz” ;</span><br><span class="line">int n &#x3D; 100;</span><br><span class="line">str &#x3D; str + n;</span><br></pre></td></tr></table></figure>
<h2 id="七、类型转换"><a href="#七、类型转换" class="headerlink" title="七、类型转换"></a>七、类型转换</h2></li>
<li><p>基本数据类型转换</p>
<ul>
<li>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：<img src="http://qd1ql2976.bkt.clouddn.com/2584" alt=""></li>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。</li>
<li>byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</li>
<li>boolean类型不能与其它数据类型运算。</li>
<li>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。</li>
</ul>
</li>
<li><p>强制类型转换</p>
<ul>
<li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</li>
<li>如：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double a &#x3D; 1.23;</span><br><span class="line">int i &#x3D; (int)a;</span><br></pre></td></tr></table></figure></li>
<li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。</li>
<li>如：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a &#x3D; “43”;</span><br><span class="line">int i &#x3D; Integer.parseInt(a);</span><br></pre></td></tr></table></figure></li>
<li>boolean类型不可以转换为其它的数据类型。</li>
</ul>
</li>
</ul>
<h2 id="八、了解"><a href="#八、了解" class="headerlink" title="八、了解"></a>八、了解</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2551" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2553" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2555" alt=""></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>变量</tag>
        <tag>整数类型</tag>
        <tag>浮点类型</tag>
        <tag>字符类型</tag>
        <tag>布尔类型</tag>
        <tag>String字符串类型</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>05.数据结构-单链表面试题</title>
    <url>/2020/07/08/05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="单链表的常见面试题有如下"><a href="#单链表的常见面试题有如下" class="headerlink" title="单链表的常见面试题有如下:"></a>单链表的常见面试题有如下:</h2><ul>
<li><p>求单链表中有效节点的个数</p>
<ul>
<li><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span><br><span class="line">public static int getLength(HeroNode head) &#123;</span><br><span class="line">	if (head.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;空链表</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int length &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助的变量, 这里我们没有统计头节点</span><br><span class="line">	HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">	while (cur.next !&#x3D; null) &#123; &#x2F;&#x2F; while(cur !&#x3D; null) &#123;</span><br><span class="line">		length++;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查找单链表中的倒数第k个结点 【新浪面试题】</p>
<ul>
<li><p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;查找单链表中的倒数第k个结点 【新浪面试题】</span><br><span class="line">&#x2F;&#x2F;思路</span><br><span class="line">&#x2F;&#x2F;1. 编写一个方法，接收head节点，同时接收一个index </span><br><span class="line">&#x2F;&#x2F;2. index 表示是倒数第index个节点</span><br><span class="line">&#x2F;&#x2F;3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span><br><span class="line">&#x2F;&#x2F;4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span><br><span class="line">&#x2F;&#x2F;5. 如果找到了，则返回该节点，否则返回nulll</span><br><span class="line">public static HeroNode findLastIndexNode(HeroNode head, int index)&#123;</span><br><span class="line">	&#x2F;&#x2F;判断如果链表为空，返回null</span><br><span class="line">	if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;第一个遍历得到链表的长度(节点个数)</span><br><span class="line">	int length &#x3D; getLength(head);</span><br><span class="line">	&#x2F;&#x2F;第二次遍历  size-index 位置，就是我们倒数的第K个节点</span><br><span class="line">	&#x2F;&#x2F;先做一个index的校验</span><br><span class="line">	if (index &lt;&#x3D; 0 || index &gt; length)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">	for(int i &#x3D; 0; i &lt;&#x3D; length - index; i++) &#123;&#x2F;&#x2F; for(int i &#x3D;0; i&lt; size - index; i++) &#123;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单链表的反转【腾讯面试题，有点难度】</p>
<ul>
<li><p>图解思路</p>
<ol>
<li>先定义一个节点 reverseHead = new HeroNode();</li>
<li>从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端.</li>
<li>原来的链表的head.next = reverseHead.next</li>
</ol>
<p><img src="http://qd1ql2976.bkt.clouddn.com/2970" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2973" alt=""></p>
</li>
<li><p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将单链表反转</span><br><span class="line">public static void reversetList(HeroNode head)&#123;</span><br><span class="line">	&#x2F;&#x2F;如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">	if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	HeroNode reverseHead &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span><br><span class="line">	HeroNode cur &#x3D; head.next ;</span><br><span class="line">	HeroNode next &#x3D; null;&#x2F;&#x2F; 指向当前节点[cur]的下一个节点</span><br><span class="line">	&#x2F;&#x2F;遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span><br><span class="line">	while(cur !&#x3D; null) &#123;</span><br><span class="line">		next &#x3D; cur.next;&#x2F;&#x2F;先暂时保存当前节点的下一个节点，因为后面需要使用</span><br><span class="line">		cur.next &#x3D; reverseHead.next;&#x2F;&#x2F;将cur的下一个节点指向新的链表的最前端</span><br><span class="line">		reverseHead.next &#x3D; cur;&#x2F;&#x2F;将cur 连接到新的链表上</span><br><span class="line">		cur &#x3D; next;&#x2F;&#x2F;让cur后移</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将head.next 指向 reverseHead.next , 实现单链表的反转</span><br><span class="line">	head.next &#x3D; reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】</p>
<ul>
<li><p>图解思路</p>
<p><img src="http://qd1ql2976.bkt.clouddn.com/2975" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;方式2：</span><br><span class="line">&#x2F;&#x2F;可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span><br><span class="line">public static void reversePrint(HeroNode head) &#123;</span><br><span class="line">	if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return;&#x2F;&#x2F;空链表，不能打印</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;创建要给一个栈，将各个节点压入栈</span><br><span class="line">	Stack&lt;HeroNode&gt; stack &#x3D; new Stack&lt;HeroNode&gt;();</span><br><span class="line">	HeroNode cur &#x3D; head.next;</span><br><span class="line">	&#x2F;&#x2F;将链表的所有节点压入栈</span><br><span class="line">	while(cur !&#x3D; null) &#123;</span><br><span class="line">		stack.push(cur);</span><br><span class="line">		cur &#x3D; cur.next; &#x2F;&#x2F;cur后移，这样就可以压入下一个节点</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将栈中的节点进行打印,pop 出栈</span><br><span class="line">	while (stack.size() &gt; 0) &#123;</span><br><span class="line">		System.out.println(stack.pop()); &#x2F;&#x2F;stack的特点是先进后出</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>合并两个有序的单链表，合并之后的链表依然有序</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.linkedlist;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个链表</span><br><span class="line">		SingleLinkedList singlelinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode h1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">		HeroNode h2 &#x3D; new HeroNode(2,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">		HeroNode h3 &#x3D; new HeroNode(3,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode h4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		singlelinkedList.addByOrder(h3);</span><br><span class="line">		singlelinkedList.addByOrder(h2);</span><br><span class="line">		singlelinkedList.addByOrder(h4);</span><br><span class="line">		singlelinkedList.addByOrder(h1);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;创建第二个链表</span><br><span class="line">		SingleLinkedList singlelinkedList1 &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode h11 &#x3D; new HeroNode(10,&quot;张三&quot;,&quot;张三&quot;);</span><br><span class="line">		HeroNode h22 &#x3D; new HeroNode(21,&quot;李四&quot;,&quot;李四&quot;);</span><br><span class="line">		HeroNode h33 &#x3D; new HeroNode(13,&quot;王五&quot;,&quot;王五&quot;);</span><br><span class="line">		HeroNode h44 &#x3D; new HeroNode(45,&quot;刘六&quot;,&quot;刘六&quot;);</span><br><span class="line">		singlelinkedList1.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		singlelinkedList1.addByOrder(h11);</span><br><span class="line">		singlelinkedList1.addByOrder(h22);</span><br><span class="line">		singlelinkedList1.addByOrder(h33);</span><br><span class="line">		singlelinkedList1.addByOrder(h44);</span><br><span class="line">		singlelinkedList1.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;直接添加无排序</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h11);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h22);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h33);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h44);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList1.list();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;合并两个有序的单链表，合并之后的链表依然有序</span><br><span class="line">		System.out.println(&quot;合并两个有序的单链表，合并之后的链表依然有序&quot;);</span><br><span class="line">		singlelinkedListTwo(singlelinkedList1.getHead(),singlelinkedList.getHead());</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;获取有效节点的个数</span><br><span class="line">		&#x2F;*System.out.println(&quot;有效节点个数：&quot;+getLength(singlelinkedList.getHead()));*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;倒数第k个节点</span><br><span class="line">		&#x2F;*System.out.println(&quot;倒数第k个节点：&quot;+findLastIndexNode(singlelinkedList.getHead(),1));*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;翻转</span><br><span class="line">		&#x2F;*System.out.println(&quot;反转&quot;);</span><br><span class="line">		reversetList(singlelinkedList.getHead());</span><br><span class="line">		singlelinkedList.list();*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;逆序打印</span><br><span class="line">		&#x2F;*System.out.println(&quot;反转&quot;);</span><br><span class="line">		reversePrint(singlelinkedList.getHead());*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		&#x2F;*System.out.println(&quot;修改豹子头林冲&quot;);</span><br><span class="line">		HeroNode h5 &#x3D; new HeroNode(4,&quot;林冲~~~&quot;,&quot;豹子头~~~&quot;);</span><br><span class="line">		singlelinkedList.update(h5);</span><br><span class="line">		singlelinkedList.list();*&#x2F;</span><br><span class="line">		&#x2F;&#x2F;删除</span><br><span class="line">		&#x2F;*System.out.println(&quot;删除豹子头林冲&quot;);</span><br><span class="line">		singlelinkedList.delete(1);</span><br><span class="line">		singlelinkedList.delete(2);</span><br><span class="line">		singlelinkedList.delete(3);</span><br><span class="line">		singlelinkedList.delete(4);</span><br><span class="line">		singlelinkedList.list();*&#x2F;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;合并两个有序的单链表，合并之后的链表依然有序</span><br><span class="line">	public static void singlelinkedListTwo(HeroNode head1 , HeroNode head2)&#123;</span><br><span class="line">		SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode  head&#x3D; singleLinkedList.getHead();</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">		HeroNode cur &#x3D; head;</span><br><span class="line">		HeroNode cur1 &#x3D; head1.next;</span><br><span class="line">		HeroNode cur2 &#x3D; head2.next;</span><br><span class="line">		while (cur1 !&#x3D; null &amp;&amp; cur2 !&#x3D; null) &#123;</span><br><span class="line">            if (cur1.no &lt;&#x3D; cur2.no) &#123;</span><br><span class="line">            	cur.next &#x3D; cur1;</span><br><span class="line">            	cur &#x3D; cur.next;</span><br><span class="line">                cur1 &#x3D; cur1.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	cur.next &#x3D; cur2;</span><br><span class="line">            	cur &#x3D; cur.next;</span><br><span class="line">                cur2 &#x3D; cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            while (cur2 !&#x3D; null) &#123;</span><br><span class="line">            	cur.next &#x3D; cur2;</span><br><span class="line">                cur &#x3D; cur.next;</span><br><span class="line">                cur2 &#x3D; cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (cur1 !&#x3D; null) &#123;</span><br><span class="line">            	cur.next &#x3D; cur1;</span><br><span class="line">            	cur &#x3D; cur.next;</span><br><span class="line">                cur1 &#x3D; cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span><br><span class="line">	public static int getLength(HeroNode head) &#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;空链表</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		int length &#x3D; 0;</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助的变量, 这里我们没有统计头节点</span><br><span class="line">		HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">		while (cur.next !&#x3D; null) &#123; &#x2F;&#x2F; while(cur !&#x3D; null) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			cur &#x3D; cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;查找单链表中的倒数第k个结点 【新浪面试题】</span><br><span class="line">	&#x2F;&#x2F;思路</span><br><span class="line">	&#x2F;&#x2F;1. 编写一个方法，接收head节点，同时接收一个index </span><br><span class="line">	&#x2F;&#x2F;2. index 表示是倒数第index个节点</span><br><span class="line">	&#x2F;&#x2F;3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span><br><span class="line">	&#x2F;&#x2F;4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span><br><span class="line">	&#x2F;&#x2F;5. 如果找到了，则返回该节点，否则返回null</span><br><span class="line">	public static HeroNode findLastIndexNode(HeroNode head, int index)&#123;</span><br><span class="line">		&#x2F;&#x2F;判断如果链表为空，返回null</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;第一个遍历得到链表的长度(节点个数)</span><br><span class="line">		int length &#x3D; getLength(head);</span><br><span class="line">		&#x2F;&#x2F;第二次遍历  size-index 位置，就是我们倒数的第K个节点</span><br><span class="line">		&#x2F;&#x2F;先做一个index的校验</span><br><span class="line">		if (index &lt;&#x3D; 0 || index &gt; length)&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">		for(int i &#x3D; 0; i &lt;&#x3D; length - index; i++) &#123;&#x2F;&#x2F; for(int i &#x3D;0; i&lt; size - index; i++) &#123;</span><br><span class="line">			cur &#x3D; cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return cur;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;将单链表反转</span><br><span class="line">	public static void reversetList(HeroNode head)&#123;</span><br><span class="line">		&#x2F;&#x2F;如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">		if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		HeroNode reverseHead &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span><br><span class="line">		HeroNode cur &#x3D; head.next ;</span><br><span class="line">		HeroNode next &#x3D; null;&#x2F;&#x2F; 指向当前节点[cur]的下一个节点</span><br><span class="line">		&#x2F;&#x2F;遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span><br><span class="line">		while(cur !&#x3D; null) &#123;</span><br><span class="line">			next &#x3D; cur.next;&#x2F;&#x2F;先暂时保存当前节点的下一个节点，因为后面需要使用</span><br><span class="line">			cur.next &#x3D; reverseHead.next;&#x2F;&#x2F;将cur的下一个节点指向新的链表的最前端</span><br><span class="line">			reverseHead.next &#x3D; cur;&#x2F;&#x2F;将cur 连接到新的链表上</span><br><span class="line">			cur &#x3D; next;&#x2F;&#x2F;让cur后移</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;将head.next 指向 reverseHead.next , 实现单链表的反转</span><br><span class="line">		head.next &#x3D; reverseHead.next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;方式2：</span><br><span class="line">	&#x2F;&#x2F;可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span><br><span class="line">	public static void reversePrint(HeroNode head) &#123;</span><br><span class="line">		if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return;&#x2F;&#x2F;空链表，不能打印</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;创建要给一个栈，将各个节点压入栈</span><br><span class="line">		Stack&lt;HeroNode&gt; stack &#x3D; new Stack&lt;HeroNode&gt;();</span><br><span class="line">		HeroNode cur &#x3D; head.next;</span><br><span class="line">		&#x2F;&#x2F;将链表的所有节点压入栈</span><br><span class="line">		while(cur !&#x3D; null) &#123;</span><br><span class="line">			stack.push(cur);</span><br><span class="line">			cur &#x3D; cur.next; &#x2F;&#x2F;cur后移，这样就可以压入下一个节点</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;将栈中的节点进行打印,pop 出栈</span><br><span class="line">		while (stack.size() &gt; 0) &#123;</span><br><span class="line">			System.out.println(stack.pop()); &#x2F;&#x2F;stack的特点是先进后出</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义SingleLinkedList 管理我们的英雄</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	public HeroNode getHead() &#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setHead(HeroNode head) &#123;</span><br><span class="line">		this.head &#x3D; head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">	&#x2F;&#x2F;思路，当不考虑编号顺序时</span><br><span class="line">	&#x2F;&#x2F;1. 找到当前链表的最后节点</span><br><span class="line">	&#x2F;&#x2F;2. 将最后这个节点的next 指向 新的节点</span><br><span class="line">	public void add(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		&#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			&#x2F;&#x2F;找到链表的最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;遍历结束</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;如果没有找到最后, 将将temp后移</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;当退出while循环时，temp就指向了链表的最后</span><br><span class="line">		&#x2F;&#x2F;将最后这个节点的next 指向 新的节点</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;添加成功&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span><br><span class="line">	&#x2F;&#x2F;(如果有这个排名，则添加失败，并给出提示)</span><br><span class="line">	public void addByOrder(HeroNode heroNode)&#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span><br><span class="line">		&#x2F;&#x2F;因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F; flag标志添加的编号是否存在，默认为false</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break ;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else if(temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;后移，遍历当前链表</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			System.out.printf(&quot;添加失败，排名为%d的英雄已经存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;插入到链表中, temp的后面</span><br><span class="line">			heroNode.next &#x3D; temp.next;</span><br><span class="line">			temp.next &#x3D; heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改节点的信息, 根据no编号来修改，即no编号不能改.</span><br><span class="line">	&#x2F;&#x2F;说明</span><br><span class="line">	&#x2F;&#x2F;1. 根据 newHeroNode 的 no 来修改即可</span><br><span class="line">	public void update(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;遍历</span><br><span class="line">		&#x2F;&#x2F;找到需要修改的节点, 根据no编号</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F;表示是否找到该节点</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;&#x2F;&#x2F;已经遍历完链表</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;&#x2F;&#x2F;找到</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;根据flag 判断是否找到要修改的节点</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			temp.next.name &#x3D; heroNode.name;</span><br><span class="line">			temp.next.nickName &#x3D; heroNode.nickName;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	&#x2F;&#x2F;思路</span><br><span class="line">	&#x2F;&#x2F;1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span><br><span class="line">	&#x2F;&#x2F;2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span><br><span class="line">	public void delete(int no)&#123;</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false; &#x2F;&#x2F; 标志是否找到待删除节点的</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; no)&#123;&#x2F;&#x2F;找到的待删除节点的前一个节点temp</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;temp后移，遍历</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;判断flag</span><br><span class="line">		if (flag)&#123; &#x2F;&#x2F;找到</span><br><span class="line">			temp.next &#x3D; temp.next.next;&#x2F;&#x2F;可以删除</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示链表[遍历]</span><br><span class="line">	public void list()&#123;</span><br><span class="line">		&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;链表为空，没有数据！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;输出节点的信息</span><br><span class="line">			System.out.println(temp.next);</span><br><span class="line">			&#x2F;&#x2F;将temp后移， 一定小心</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">	int no;</span><br><span class="line">	String name;</span><br><span class="line">	String nickName;</span><br><span class="line">	HeroNode next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode(int no, String name, String nickName)&#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickName &#x3D; nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickName&#x3D;&quot; + nickName  + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>单链表</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>03.数据结构-队列</title>
    <url>/2020/07/05/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列-数组实现"><a href="#队列-数组实现" class="headerlink" title="队列-数组实现"></a>队列-数组实现</h2><ol>
<li><h4 id="队列的一个使用场景"><a href="#队列的一个使用场景" class="headerlink" title="队列的一个使用场景"></a>队列的一个使用场景</h4><p> 银行排队的案例:<br> <img src="http://qd1ql2976.bkt.clouddn.com/2346" alt=""></p>
</li>
<li><h4 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h4><ol>
<li>队列是一个 有序列表，可以用 数组或是链表来实现。</li>
<li>遵循 先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li>
<li>示意图：(使用数组模拟队列示意图)<br><img src="http://qd1ql2976.bkt.clouddn.com/2361" alt=""></li>
</ol>
</li>
<li><h4 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h4><ul>
<li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中maxSize 是该队列的最大容量。</p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标，front会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示:<br><img src="http://qd1ql2976.bkt.clouddn.com/2361" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; 创建一个队列</span><br><span class="line">		ArrayQueue queue &#x3D; new ArrayQueue(3);</span><br><span class="line">		&#x2F;&#x2F; 接受用户输入</span><br><span class="line">		char key &#x3D; &#39; &#39;;</span><br><span class="line">		&#x2F;&#x2F; 创建输出</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		boolean loop &#x3D; true;</span><br><span class="line">		&#x2F;&#x2F;输出一个菜单</span><br><span class="line">		while (loop) &#123;</span><br><span class="line">			System.out.println(&quot;\t\ts(show): 显示队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\te(exit): 退出程序&quot;);</span><br><span class="line">			System.out.println(&quot;\t\ta(add): 添加数据到队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\tg(get): 从队列取出数据&quot;);</span><br><span class="line">			System.out.println(&quot;\t\th(head): 查看队列头的数据&quot;);</span><br><span class="line">			key &#x3D; sc.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">			switch (key) &#123;</span><br><span class="line">				case &#39;a&#39; : &#x2F;&#x2F; 添加数据到队列</span><br><span class="line">					System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">					int n &#x3D; sc.nextInt();</span><br><span class="line">					queue.addQueue(n);</span><br><span class="line">					break;</span><br><span class="line">				case &#39;g&#39; : &#x2F;&#x2F; 从队列取出数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;取出的数据是：%d\n&quot;,queue.getQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;s&#39; : &#x2F;&#x2F; 显示队列</span><br><span class="line">					queue.showQueue();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;h&#39; : &#x2F;&#x2F; 查看队列头的数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;队列头的数据是：%d\n&quot;,queue.headQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;e&#39; : &#x2F;&#x2F; 退出程序</span><br><span class="line">	    sc.close();</span><br><span class="line">					loop &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;程序退出~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ArrayQueue&#123;</span><br><span class="line">	private int MaxSize; &#x2F;&#x2F; 队列的最大容量</span><br><span class="line">	private int front; &#x2F;&#x2F; 队列头</span><br><span class="line">	private int rear; &#x2F;&#x2F; 队列尾</span><br><span class="line">	private int[] arr; &#x2F;&#x2F; 该数据用于存放数据, 模拟队列</span><br><span class="line">	</span><br><span class="line">	public ArrayQueue(int arrMaxSize)&#123;</span><br><span class="line">		arr &#x3D;  new int[arrMaxSize];</span><br><span class="line">		MaxSize &#x3D; arrMaxSize;</span><br><span class="line">		front &#x3D; -1; &#x2F;&#x2F; 指向队列头部，分析出front是指向队列头的前一个位置.</span><br><span class="line">		rear &#x3D; -1; &#x2F;&#x2F; 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否满</span><br><span class="line">	public boolean isFull()&#123;</span><br><span class="line">		return rear &#x3D;&#x3D; MaxSize-1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	public boolean isEmpty()&#123;</span><br><span class="line">		return front &#x3D;&#x3D; rear;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 添加数据到队列</span><br><span class="line">	public void addQueue(int n)&#123;</span><br><span class="line">		if (isFull()) &#123;</span><br><span class="line">			System.out.println(&quot;队列已满，不能添加！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		rear++; &#x2F;&#x2F; 进队列，rear后移一位</span><br><span class="line">		arr[rear] &#x3D; n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 获取队列的数据, 出队列</span><br><span class="line">	public int getQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		front++; &#x2F;&#x2F; 出队列，front后移一位</span><br><span class="line">		return arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的所有数据</span><br><span class="line">	public void showQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			System.out.println(&quot;队列空的，没有数据~~&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 遍历</span><br><span class="line">		for (int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">			System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的头数据， 注意不是取出数据</span><br><span class="line">	public int headQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[front+1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>问题分析并优化</p>
<ol>
<li>目前数组使用一次就不能用， 没有达到复用的效果</li>
<li>将这个数组使用算法，改进成一个列 环形的队列 取模：%</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h4><p> 对前面的数组模拟队列的优化，充分利用数组。 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<ul>
<li><p>分析说明</p>
<ol>
<li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front 满]</li>
<li>rear == front [空]</li>
<li>分析示意图<br><img src="http://qd1ql2976.bkt.clouddn.com/2361" alt=""></li>
<li>思路如下<ol>
<li>front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素<br>front 的初始值 = 0</li>
<li>rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.<br>rear 的初始值 = 0</li>
<li>当队列满时，条件是  (rear  + 1) % maxSize == front 【满】</li>
<li>对队列为空的条件， rear == front 【空】</li>
<li>当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize</li>
</ol>
</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试一把</span><br><span class="line">		System.out.println(&quot;测试数组模拟环形队列的案例~~~&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建一个环形队列</span><br><span class="line">		CircleArrayQueue queue &#x3D; new CircleArrayQueue(4); &#x2F;&#x2F;说明设置4, 其队列的有效数据最大是3</span><br><span class="line">		&#x2F;&#x2F; 接受用户输入</span><br><span class="line">		char key &#x3D; &#39; &#39;;</span><br><span class="line">		&#x2F;&#x2F; 创建输出</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		boolean loop &#x3D; true;</span><br><span class="line">		&#x2F;&#x2F;输出一个菜单</span><br><span class="line">		while (loop) &#123;</span><br><span class="line">			System.out.println(&quot;\t\ts(show): 显示队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\te(exit): 退出程序&quot;);</span><br><span class="line">			System.out.println(&quot;\t\ta(add): 添加数据到队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\tg(get): 从队列取出数据&quot;);</span><br><span class="line">			System.out.println(&quot;\t\th(head): 查看队列头的数据&quot;);</span><br><span class="line">			key &#x3D; sc.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">			switch (key) &#123;</span><br><span class="line">				case &#39;a&#39; : &#x2F;&#x2F; 添加数据到队列</span><br><span class="line">					System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">					int n &#x3D; sc.nextInt();</span><br><span class="line">					queue.addQueue(n);</span><br><span class="line">					break;</span><br><span class="line">				case &#39;g&#39; : &#x2F;&#x2F; 从队列取出数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;取出的数据是：%d\n&quot;,queue.getQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;s&#39; : &#x2F;&#x2F; 显示队列</span><br><span class="line">					queue.showQueue();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;h&#39; : &#x2F;&#x2F; 查看队列头的数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;队列头的数据是：%d\n&quot;,queue.headQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;e&#39; : &#x2F;&#x2F; 退出程序</span><br><span class="line">					sc.close();</span><br><span class="line">					loop &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;程序退出~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class CircleArrayQueue&#123;</span><br><span class="line">	private int MaxSize; &#x2F;&#x2F; 表示数组的最大容量</span><br><span class="line">	&#x2F;&#x2F; front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span><br><span class="line">	&#x2F;&#x2F; front 的初始值 &#x3D; 0</span><br><span class="line">	private int front; </span><br><span class="line">	&#x2F;&#x2F; rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span><br><span class="line">	&#x2F;&#x2F; rear 的初始值 &#x3D; 0</span><br><span class="line">	private int rear; &#x2F;&#x2F; 队列尾</span><br><span class="line">	private int[] arr; &#x2F;&#x2F; 该数据用于存放数据, 模拟队列</span><br><span class="line"></span><br><span class="line">	public CircleArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">		arr &#x3D; new int[arrMaxSize];</span><br><span class="line">		MaxSize &#x3D; arrMaxSize;</span><br><span class="line">		front &#x3D; 0; &#x2F;&#x2F; 指向队列头部，分析出front是指向队列头的位置</span><br><span class="line">		rear &#x3D; 0; &#x2F;&#x2F; 指向队列尾，指向队列尾的后一个位置</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 当前队列有效的数据的个数</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return ( rear + MaxSize - front ) % MaxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 判断队列是否满</span><br><span class="line">	public boolean isFull()&#123;</span><br><span class="line">		return ( rear + 1 ) % MaxSize &#x3D;&#x3D; front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	public boolean isEmpty()&#123;</span><br><span class="line">		return front &#x3D;&#x3D; rear;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 添加数据到队列</span><br><span class="line">	public void addQueue(int n)&#123;</span><br><span class="line">		if (isFull()) &#123;</span><br><span class="line">			System.out.println(&quot;队列已满，不能添加！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;直接将数据加入</span><br><span class="line">		arr[rear] &#x3D; n;</span><br><span class="line">		&#x2F;&#x2F;将 rear 后移, 这里必须考虑取模</span><br><span class="line">		rear &#x3D; ( rear + 1 ) % MaxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 获取队列的数据, 出队列</span><br><span class="line">	public int getQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 这里需要分析出 front是指向队列的第一个元素</span><br><span class="line">		&#x2F;&#x2F; 1. 先把 front 对应的值保留到一个临时变量</span><br><span class="line">		&#x2F;&#x2F; 2. 将 front 后移, 考虑取模</span><br><span class="line">		&#x2F;&#x2F; 3. 将临时保存的变量返回</span><br><span class="line">		int temp &#x3D; arr[front];</span><br><span class="line">		front &#x3D; ( front + 1 ) % MaxSize;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的所有数据</span><br><span class="line">	public void showQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			System.out.println(&quot;队列空的，没有数据~~&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 思路：从front开始遍历，遍历多少个元素</span><br><span class="line">		&#x2F;&#x2F; 动脑筋</span><br><span class="line">		for (int i &#x3D; front; i &lt; front + size(); i++)&#123;</span><br><span class="line">			System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i % MaxSize, arr[i % MaxSize]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的头数据， 注意不是取出数据</span><br><span class="line">	public int headQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，没有数据~~&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>队列</tag>
        <tag>环形队列</tag>
        <tag>数组模拟队列</tag>
        <tag>数组模拟环形队列</tag>
      </tags>
  </entry>
  <entry>
    <title>06.数据结构-双链表</title>
    <url>/2020/07/09/06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点</p>
<h4 id="单链表与双链表区别"><a href="#单链表与双链表区别" class="headerlink" title="单链表与双链表区别"></a>单链表与双链表区别</h4><p>逻辑上没有区别。他们均是完成线性表的内容。主要的区别是结构上的构造有所区别。</p>
<ul>
<li>单链表<ul>
<li>对于一个节点，有储存数据的data。和next后驱节点(指针)。也就是这个单链表想要一些遍历的操作都得通过前节点—&gt;后节点。<br><img src="http://qd1ql2976.bkt.clouddn.com/3155" alt=""></li>
</ul>
</li>
<li>双链表<ul>
<li>对于一个节点，有些和单链表一样有存储数据的data,指向后方的next（指针）。它拥有单链表的所有操作和内容。但是他还有一个前驱节点pre(指针)。<br><img src="http://qd1ql2976.bkt.clouddn.com/3157" alt=""><h4 id="双向链表应用实例"><a href="#双向链表应用实例" class="headerlink" title="双向链表应用实例"></a>双向链表应用实例</h4></li>
</ul>
</li>
</ul>
<p><strong>使用带 head 头的双向链表实现 –水浒英雄排行榜</strong></p>
<ul>
<li>管理单向链表的缺点分析: <ul>
<li>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</li>
<li>单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).</li>
</ul>
</li>
<li>双链表图解:<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3179" alt=""></li>
<li>图解思路:</li>
</ul>
<ol>
<li>遍历方发和单链表一样，只是可以向前，也可以向后查找</li>
<li>添加 (默认添加到双向链表的最后)<ol>
<li>先找到双向链表的最后这个节点</li>
<li>temp.next = heroNode</li>
<li>heroNode.pre = temp;</li>
</ol>
</li>
<li>修改思路和原来的单向链表一样.</li>
<li>删除<ol>
<li>因为是双向链表，因此，我们可以实现自我删除某个节点</li>
<li>直接找到要删除的这个节点，比如 temp</li>
<li>temp.pre.next = temp.next</li>
<li>temp.next.pre = temp.pre;</li>
</ol>
</li>
</ol>
<ul>
<li><p>代码实现:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		DoubleLinkedList doubleLinkedList &#x3D; new DoubleLinkedList();</span><br><span class="line">		HeroNode2 h1 &#x3D; new HeroNode2(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">		HeroNode2 h2 &#x3D; new HeroNode2(2,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">		HeroNode2 h3 &#x3D; new HeroNode2(3,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode2 h4 &#x3D; new HeroNode2(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">		HeroNode2 h5 &#x3D; new HeroNode2(4,&quot;张三&quot;,&quot;李四&quot;);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;顺序添加</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h1);</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h2);</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h3);</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h4);</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		doubleLinkedList.addByOrder(h3);</span><br><span class="line">		doubleLinkedList.addByOrder(h2);</span><br><span class="line">		doubleLinkedList.addByOrder(h4);</span><br><span class="line">		doubleLinkedList.addByOrder(h1);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		System.out.println(&quot;修改后的双链表&quot;);</span><br><span class="line">		doubleLinkedList.update(h5);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;删除</span><br><span class="line">		System.out.println(&quot;删除后的双链表&quot;);</span><br><span class="line">		doubleLinkedList.delete(3);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">class DoubleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode2 head &#x3D; new HeroNode2(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	public HeroNode2 getHead() &#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	public void delete(int no)&#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;双链表为空，无法删除！！！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;辅助节点</span><br><span class="line">		HeroNode2 temp &#x3D; head.next;</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		while(temp !&#x3D; null)&#123;</span><br><span class="line">			if (temp.no &#x3D;&#x3D; no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D;temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag)&#123;</span><br><span class="line">			temp.pre.next &#x3D; temp.next;</span><br><span class="line">			&#x2F;&#x2F;如果删除的节点是最后一个，不执行temp.next.pre &#x3D; temp.pre;</span><br><span class="line">			&#x2F;&#x2F; 因为temp.next &#x3D; null , temp.next.pre报空指针异常</span><br><span class="line">			if(temp.next !&#x3D; null)&#123;</span><br><span class="line">				temp.next.pre &#x3D; temp.pre;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;双链表中没有排名为%d的英雄！！！&quot;,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改节点</span><br><span class="line">	public void update(HeroNode2 heroNode)&#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;双链表为空，无法修改！！！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		while (temp.next !&#x3D; null)&#123;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			temp.next.name &#x3D; heroNode.name;</span><br><span class="line">			temp.next.nickName &#x3D; heroNode.nickName;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;双链表中没有排名为%d的英雄！！！&quot;,heroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;1.结尾添加节点</span><br><span class="line">	public void add(HeroNode2 heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head; </span><br><span class="line">		while(temp.next !&#x3D; null)&#123;</span><br><span class="line">			temp &#x3D; temp.next;&#x2F;&#x2F;后移</span><br><span class="line">		&#125;&#x2F;&#x2F;遍历结束后指向最后一个节点</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">		heroNode.pre &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;1.按英雄的排名添加节点</span><br><span class="line">	public void addByOrder(HeroNode2 heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		while (temp.next !&#x3D; null)&#123;</span><br><span class="line">			if (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;&#x2F;&#x2F;遍历结束后指向最后一个节点 或者 指向比排名大的前一个节点</span><br><span class="line">		&#x2F;&#x2F;如果查入的位置是最后一个节点，不执行 temp.next.pre &#x3D; heroNode;</span><br><span class="line">		&#x2F;&#x2F; 因为temp.next &#x3D; null , temp.next.pre报空指针异常</span><br><span class="line">		if (temp.next !&#x3D; null)&#123;</span><br><span class="line">			temp.next.pre &#x3D; heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">		heroNode.next &#x3D; temp.next;</span><br><span class="line">		heroNode.pre &#x3D; temp; </span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;遍历显示</span><br><span class="line">	public void list()&#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;双链表为空！！！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head; </span><br><span class="line">		while(temp.next !&#x3D; null)&#123;</span><br><span class="line">			System.out.println(temp.next);</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">	int no;</span><br><span class="line">	String name;</span><br><span class="line">	String nickName;</span><br><span class="line">	HeroNode2 next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">	HeroNode2 pre;&#x2F;&#x2F;指向上一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode2(int no, String name, String nickName)&#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickName &#x3D; nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickName&#x3D;&quot; + nickName  + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>双链表</tag>
      </tags>
  </entry>
  <entry>
    <title>06.Java基础知识-进制</title>
    <url>/2020/07/06/06-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<h2 id="世界上有10人种人，认识和不认识二进制的。"><a href="#世界上有10人种人，认识和不认识二进制的。" class="headerlink" title="世界上有10人种人，认识和不认识二进制的。"></a>世界上有10人种人，认识和不认识二进制的。</h2><h4 id="所有数字在计算机底层都以-二进制形式存在。"><a href="#所有数字在计算机底层都以-二进制形式存在。" class="headerlink" title="所有数字在计算机底层都以 二进制形式存在。"></a>所有数字在计算机底层都以 二进制形式存在。</h4><h4 id="对于整数，有四种表示方式："><a href="#对于整数，有四种表示方式：" class="headerlink" title="对于整数，有四种表示方式："></a>对于整数，有四种表示方式：</h4><ul>
<li>二进制(binary) ：0,1 ，满2进1.以0b或0B开头。</li>
<li>十进制(decimal) ：0-9 ，满10进1。</li>
<li>八进制(octal) ：0-7 ，满8进1. 以数字0开头表示。</li>
<li>十六进制(hex) ：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。</li>
<li>如：0x21AF +1= 0X21B0<br><img src="http://qd1ql2976.bkt.clouddn.com/2707" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2709" alt=""><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2></li>
<li>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位</li>
<li>二进制的整数有如下三种形式：<ul>
<li>原码：直接将一个数值换成二进制数。最高位是符号位</li>
<li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</li>
<li>负数的补码：其反码加1。</li>
</ul>
</li>
<li>计算机以二进制补码的形式保存所有的整数。<ul>
<li>正数的原码、反码、补码都相同</li>
<li>负数的补码是其反码+1<h2 id="为什么要使用原码、反码、补码表示形式呢？"><a href="#为什么要使用原码、反码、补码表示形式呢？" class="headerlink" title="为什么要使用原码、反码、补码表示形式呢？"></a>为什么要使用原码、反码、补码表示形式呢？</h2>计算机辨别“符号位”显然会让计算机的基础电路设计变得十分复杂! 于是<br>人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法,这样计算机运算的设计就更简单了。<br><img src="http://qd1ql2976.bkt.clouddn.com/2726" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2728" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2730" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2732" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2734" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2736" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2738" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2740" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2742" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2744" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2746" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2748" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2750" alt=""><h2 id="进制间转化"><a href="#进制间转化" class="headerlink" title="进制间转化"></a>进制间转化</h2><h4 id="进制的基本转换"><a href="#进制的基本转换" class="headerlink" title="进制的基本转换"></a>进制的基本转换</h4></li>
</ul>
</li>
<li>十进制 二进制互转<ul>
<li>二进制转成十进制  乘以2 的幂数</li>
<li>十进制转成二进制  除以2 取余数</li>
</ul>
</li>
<li>二进制 八进制互转</li>
<li>二进制 十六进制互转</li>
<li>十进制 八进制互转</li>
<li>十进制 十六进制互转<br><img src="http://qd1ql2976.bkt.clouddn.com/2776" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2778" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2780" alt=""><h2 id="进制间转化-1"><a href="#进制间转化-1" class="headerlink" title="进制间转化"></a>进制间转化</h2><h4 id="进制的基本转换-1"><a href="#进制的基本转换-1" class="headerlink" title="进制的基本转换"></a>进制的基本转换</h4></li>
<li>十进制 二进制互转<ul>
<li>二进制转成十进制  乘以2 的幂数</li>
<li>十进制转成二进制  除以2 取余数</li>
</ul>
</li>
<li>二进制 八进制互转</li>
<li>二进制 十六进制互转</li>
<li>十进制 八进制互转</li>
<li>十进制 十六进制互转<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/5EC871BA9D5D42D7B5A1CBC281ED4B1E/2776" alt=""><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/3C33F55D34E1419DA549F06B9001E058/2778" alt=""><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/E571E67C2E55469BBF3FB6451CB447FD/2780" alt=""><h2 id="求一个0-255范围内的整数的十六进制值"><a href="#求一个0-255范围内的整数的十六进制值" class="headerlink" title="求一个0~255范围内的整数的十六进制值"></a>求一个0~255范围内的整数的十六进制值</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 如何求一个0~255范围内的整数的十六进制值，例如60的十六进制表示形式3C</span><br><span class="line">		&#x2F;&#x2F; 0~255范围代表二进制控制在8位以内</span><br><span class="line">		int temp &#x3D; 60;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 方式一：自动实现</span><br><span class="line">		System.out.println(&quot;自动实现&quot;);</span><br><span class="line">		String str1 &#x3D; Integer.toBinaryString(temp);</span><br><span class="line">		System.out.println(temp+&quot;转换二进制:\t&quot; + str1);</span><br><span class="line">		</span><br><span class="line">		String str2 &#x3D; Integer.toHexString(temp);</span><br><span class="line">		System.out.println(temp+&quot;转换十六进制:\t&quot; + str2);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 方式二：自动实现</span><br><span class="line">		System.out.println(&quot;手动实现&quot;);</span><br><span class="line">		&#x2F;&#x2F; &amp;位运算符（与）：按底层二进制进行计算 相同为1，不同为0</span><br><span class="line">		&#x2F;&#x2F; 15二进制为1111 与 temp 进行&amp;运算可以求出 temp 二进制后四位的和</span><br><span class="line">		int k &#x3D; temp &amp; 15;</span><br><span class="line">		&#x2F;&#x2F; 判断是否超过9转换为（A-F）</span><br><span class="line">		char k1 &#x3D; (char)(k - 10 + 97);</span><br><span class="line">		&#x2F;&#x2F; 转换为String类型保存</span><br><span class="line">		String i &#x3D; k &gt; 9 ? k1 + &quot;&quot; : k + &quot;&quot; ;</span><br><span class="line">		&#x2F;&#x2F; &gt;&gt;位运算符（右移）：按底层二进制进行右移四位，剩余的正好是前四位</span><br><span class="line">		k &#x3D; temp &gt;&gt; 4;</span><br><span class="line">		&#x2F;&#x2F; 判断是否超过9转换为（A-F）</span><br><span class="line">		k1 &#x3D; (char)(k - 10 + 97);</span><br><span class="line">		&#x2F;&#x2F; 转换为String类型保存</span><br><span class="line">		String j &#x3D; k &gt; 9 ? k1 + &quot;&quot; : k + &quot;&quot; ;</span><br><span class="line">		</span><br><span class="line">		System.out.println(temp+&quot;转换十六进制:\t&quot; + j + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>进制</tag>
        <tag>二进制</tag>
        <tag>十进制</tag>
        <tag>八进制</tag>
        <tag>十六进制</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>09.Java基础知识-质数与优化</title>
    <url>/2020/07/10/09-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%B4%A8%E6%95%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="输出100以内的所有的质数"><a href="#输出100以内的所有的质数" class="headerlink" title="输出100以内的所有的质数"></a>输出100以内的所有的质数</h2><p>质数（素数）：只能被1和它本身整除的自然数。从2开始，到这个数减1结束为止，都不能被这个数本身整除。</p>
<h4 id="一、简单实现"><a href="#一、简单实现" class="headerlink" title="一、简单实现"></a>一、简单实现</h4><ol>
<li><p>注意boolean isFlag = true;</p>
</li>
<li><p>不要放在外层循环里边 每次声明 浪费内存</p>
</li>
<li><p>声明一次，每次外层循环重置isFlag</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	boolean isFlag &#x3D; true;&#x2F;&#x2F;标识i是否被j除尽，一旦除尽，修改其值</span><br><span class="line"></span><br><span class="line">	for(int i &#x3D; 2;i &lt;&#x3D; 100;i++)&#123;&#x2F;&#x2F;遍历100以内的自然数</span><br><span class="line">	</span><br><span class="line">		&#x2F;&#x2F;boolean isFlag &#x3D; true;放在这每次声明 浪费内存</span><br><span class="line">	</span><br><span class="line">		for(int j &#x3D; 2;j &lt; i;j++)&#123;&#x2F;&#x2F;j:被i去除</span><br><span class="line">			</span><br><span class="line">			if(i % j &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;i被j除尽</span><br><span class="line">				isFlag &#x3D; false;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		if(isFlag &#x3D;&#x3D; true)&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;重置isFlag</span><br><span class="line">		isFlag &#x3D; true;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="100000以内的所有的质数个数"><a href="#100000以内的所有的质数个数" class="headerlink" title="100000以内的所有的质数个数"></a>100000以内的所有的质数个数</h2><h4 id="二、第一次优化"><a href="#二、第一次优化" class="headerlink" title="二、第一次优化"></a>二、第一次优化</h4></li>
<li><p>i替换为根号i（Math.sqrt(i)）</p>
<p> 对本身是质数的自然数是有效的。</p>
<p> 因为 i = 根号i * 根号i（Math.sqrt(i) * Math.sqrt(i)）；</p>
</li>
<li><p>第一次确定不是质数break跳出，只对本身非质数的自然数是有效的。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	boolean isFlag &#x3D; true;&#x2F;&#x2F;标识i是否被j除尽，一旦除尽，修改其值</span><br><span class="line">	int count &#x3D; 0;&#x2F;&#x2F;记录质数的个数</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取当前时间距离1970-01-01 00:00:00 的毫秒数</span><br><span class="line">	long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	for(int i &#x3D; 2;i &lt;&#x3D; 100000;i++)&#123;&#x2F;&#x2F;遍历100000以内的自然数</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;优化1：i替换为根号i（Math.sqrt(i)），对本身是质数的自然数是有效的。因为 i &#x3D; 根号i * 根号i（Math.sqrt(i) * Math.sqrt(i)）；</span><br><span class="line">		&#x2F;&#x2F;for(int j &#x3D; 2;j &lt; i;j++)&#123;</span><br><span class="line">		for(int j &#x3D; 2;j &lt;&#x3D; Math.sqrt(i);j++)&#123;&#x2F;&#x2F;j:被i去除</span><br><span class="line">			</span><br><span class="line">			if(i % j &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;i被j除尽</span><br><span class="line">				isFlag &#x3D; false;</span><br><span class="line">				break;&#x2F;&#x2F;优化2：第一次确定不是质数break跳出，只对本身非质数的自然数是有效的。</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		if(isFlag &#x3D;&#x3D; true)&#123;</span><br><span class="line">			&#x2F;&#x2F;System.out.println(i);</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;重置isFlag</span><br><span class="line">		isFlag &#x3D; true;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取当前时间距离1970-01-01 00:00:00 的毫秒数</span><br><span class="line">	long end &#x3D; System.currentTimeMillis();</span><br><span class="line">	System.out.println(&quot;质数的个数为：&quot; + count);</span><br><span class="line">	System.out.println(&quot;所花费的时间为：&quot; + (end - start));&#x2F;&#x2F;17110 - 优化一：break:1546 - 优化二：13</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="三、第二次优化"><a href="#三、第二次优化" class="headerlink" title="三、第二次优化"></a>三、第二次优化</h4><ol>
<li><p>省去标识i是否被j除尽boolean isFlag = true;</p>
</li>
<li><p>利用continue label;实现执行到count++;的都是质数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int count &#x3D; 0;&#x2F;&#x2F;记录质数的个数</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取当前时间距离1970-01-01 00:00:00 的毫秒数</span><br><span class="line">	long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	label:for(int i &#x3D; 2;i &lt;&#x3D; 100000;i++)&#123;&#x2F;&#x2F;遍历100000以内的自然数</span><br><span class="line">		</span><br><span class="line">		for(int j &#x3D; 2;j &lt;&#x3D; Math.sqrt(i);j++)&#123;&#x2F;&#x2F;j:被i去除</span><br><span class="line">			</span><br><span class="line">			if(i % j &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;i被j除尽</span><br><span class="line">				continue label;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;能执行到此步骤的，都是质数</span><br><span class="line">		count++;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取当前时间距离1970-01-01 00:00:00 的毫秒数</span><br><span class="line">	long end &#x3D; System.currentTimeMillis();</span><br><span class="line">	System.out.println(&quot;质数的个数为：&quot; + count);</span><br><span class="line">	System.out.println(&quot;所花费的时间为：&quot; + (end - start));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>质数</tag>
        <tag>100以内质数</tag>
        <tag>求质数运算优化</tag>
      </tags>
  </entry>
  <entry>
    <title>10.Java基础知识-数组</title>
    <url>/2020/07/11/10-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="一、数组的概述"><a href="#一、数组的概述" class="headerlink" title="一、数组的概述"></a>一、数组的概述</h4><ol>
<li><p>数组的理解：数组(Array)，是多个相同类型数据按一定顺序排列<br>的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p>
</li>
<li><p>数组的常见概念</p>
<ul>
<li>数组名</li>
<li>下标(或索引)</li>
<li>元素</li>
<li>数组的长度</li>
</ul>
</li>
<li><p>数组的特点：</p>
<ul>
<li>数组是有序排列的</li>
<li>数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型</li>
<li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。</li>
<li>数组的长度一旦确定，就不能修改。</li>
<li>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。</li>
</ul>
</li>
<li><p>数组的分类：</p>
<ul>
<li>按照维度：一维数组、二维数组、三维数组、…</li>
<li>按照元素的数据类型：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)<h4 id="二、一维数组的使用"><a href="#二、一维数组的使用" class="headerlink" title="二、一维数组的使用"></a>二、一维数组的使用</h4></li>
</ul>
</li>
<li><p>一维数组的声明</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type var[]</span><br><span class="line">type[] var；</span><br></pre></td></tr></table></figure>
<p> 例如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a1[];</span><br><span class="line">int[] a;</span><br><span class="line">double[] b;</span><br><span class="line">String[] c; &#x2F;&#x2F;引用类型变量数组</span><br></pre></td></tr></table></figure>
<p> Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： int a[5]; //非法</p>
</li>
<li><p>一维数组的声明和初始化</p>
<ul>
<li><p>动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基本数据类型</span><br><span class="line">int[] arr &#x3D; new int[3];&#x2F;&#x2F;声明和初始化</span><br><span class="line">arr[0] &#x3D; 3;&#x2F;&#x2F;赋值</span><br><span class="line">arr[1] &#x3D; 9;&#x2F;&#x2F;赋值</span><br><span class="line">arr[2] &#x3D; 8;&#x2F;&#x2F;赋值</span><br><span class="line">&#x2F;&#x2F;引用数据类型</span><br><span class="line">String names[];&#x2F;&#x2F;声明</span><br><span class="line">names &#x3D; new String[3];&#x2F;&#x2F;初始化</span><br><span class="line">names[0] &#x3D; “钱学森”;&#x2F;&#x2F;赋值</span><br><span class="line">names[1] &#x3D; “邓稼先”;&#x2F;&#x2F;赋值</span><br><span class="line">names[2] &#x3D; “袁隆平”;&#x2F;&#x2F;赋值</span><br></pre></td></tr></table></figure></li>
<li><p>静态初始化：在定义数组的同时就为数组元素分配空间并赋值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基本数据类型</span><br><span class="line">int arr[] &#x3D; new int[]&#123; 3, 9, 8&#125;;&#x2F;&#x2F;1.声明和初始化并赋值</span><br><span class="line">int[] arr &#x3D; &#123;3,9,8&#125;;&#x2F;&#x2F;2.声明和初始化并赋值</span><br><span class="line">&#x2F;&#x2F;引用数据类型</span><br><span class="line">String names[] &#x3D; &#123;“李四光”,“茅以升”,“华罗庚”&#125;&#x2F;&#x2F;声明和初始化并赋值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一维数组的使用：数组元素的引用</p>
<ul>
<li>定义并用运算符new为之分配空间后，才可以引用数组中的每个元素；</li>
<li>数组元素的引用方式：数组名[数组元素下标]<ul>
<li>数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];</li>
<li>数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —&gt;n-1；如int a[]=new<br>int[3]; 可引用的数组元素为a[0]、a[1]、a[2]</li>
</ul>
</li>
<li>每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数)<ul>
<li>数组一旦初始化，其长度是不可变的</li>
</ul>
</li>
</ul>
</li>
<li><p>一维数组的使用：数组元素的默认初始化值<br> <img src="http://qd1ql2976.bkt.clouddn.com/3486" alt=""></p>
<ul>
<li>数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。</li>
<li>对于基本数据类型而言，默认初始化值各有不同</li>
<li>对于引用数据类型而言，默认初始化值为null(注意 与0不同！)</li>
</ul>
</li>
<li><p>数组的内存解析</p>
<ul>
<li><p>Java中使用关键字new来创建数组</p>
<ul>
<li><p>如下是创建基本数据类型元素的一维数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">    int[] s;&#x2F;&#x2F;①</span><br><span class="line">    s &#x3D; new int[10];&#x2F;&#x2F;②</span><br><span class="line">    &#x2F;&#x2F;int[] s&#x3D;new int[10];</span><br><span class="line">    &#x2F;&#x2F; 基本 数据类型 数组在显式赋值之前，</span><br><span class="line">    &#x2F;&#x2F;Java 会自动 给他们赋默认值。</span><br><span class="line">    for ( int i&#x3D;0; i&lt;10; i++ ) &#123;</span><br><span class="line">        s[i] &#x3D;2*i+1;&#x2F;&#x2F;③</span><br><span class="line">        System.out.println(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①<br><img src="http://qd1ql2976.bkt.clouddn.com/3489" alt=""></p>
<p>②<br><img src="http://qd1ql2976.bkt.clouddn.com/3491" alt=""></p>
<p>③<br><img src="http://qd1ql2976.bkt.clouddn.com/3493" alt=""></p>
</li>
</ul>
</li>
<li><p>内存的简化结构<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3495" alt=""><br>  <img src="http://qd1ql2976.bkt.clouddn.com/3497" alt=""><br>  <img src="http://qd1ql2976.bkt.clouddn.com/3501" alt=""></p>
</li>
</ul>
</li>
<li><p>代码示例</p>
<ol>
<li><p>题目：从键盘读入学生成绩，找出最高分，并输出学生成绩等级。</p>
<ul>
<li>成绩&gt;=最高分-10 等级为’A’</li>
<li>成绩&gt;=最高分-20 等级为’B’</li>
<li>成绩&gt;=最高分-30 等级为’C’</li>
<li>其余 等级为’D’</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	&#x2F;&#x2F;1.使用Scanner，读取学生个数</span><br><span class="line">	Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">	System.out.println(&quot;请输入学生人数：&quot;);</span><br><span class="line">	int number &#x3D; scanner.nextInt();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;2.创建数组，存储学生成绩：动态初始化</span><br><span class="line">	int[] scores &#x3D; new int[number];</span><br><span class="line">	&#x2F;&#x2F;3.给数组中的元素赋值</span><br><span class="line">	System.out.println(&quot;请输入&quot; + number + &quot;个学生成绩：&quot;);</span><br><span class="line">	int maxScore &#x3D; 0;</span><br><span class="line">	for(int i &#x3D; 0;i &lt; scores.length;i++)&#123;</span><br><span class="line">		scores[i] &#x3D; scanner.nextInt();</span><br><span class="line">		&#x2F;&#x2F;4.获取数组中的元素的最大值:最高分</span><br><span class="line">		if(maxScore &lt; scores[i])&#123;</span><br><span class="line">			maxScore &#x3D; scores[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;5.根据每个学生成绩与最高分的差值，得到每个学生的等级，并输出等级和成绩</span><br><span class="line">	char level;</span><br><span class="line">	for(int i &#x3D; 0;i &lt; scores.length;i++)&#123;</span><br><span class="line">		if(maxScore - scores[i] &lt;&#x3D; 10)&#123;</span><br><span class="line">			level &#x3D; &#39;A&#39;;</span><br><span class="line">		&#125;else if(maxScore - scores[i] &lt;&#x3D; 20)&#123;</span><br><span class="line">			level &#x3D; &#39;B&#39;;</span><br><span class="line">		&#125;else if(maxScore - scores[i] &lt;&#x3D; 30)&#123;</span><br><span class="line">			level &#x3D; &#39;C&#39;;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			level &#x3D; &#39;D&#39;;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;student &quot; + i + </span><br><span class="line">				&quot; score is &quot; + scores[i] + &quot;,grade is &quot; + level);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h4 id="三、多维数组的使用"><a href="#三、多维数组的使用" class="headerlink" title="三、多维数组的使用"></a>三、多维数组的使用</h4><ol>
<li><p>Java 语言里提供了支持多维数组的语法。</p>
<ul>
<li>如果说可以把一维数组当成几何中的线性图形，那么二维数组就相当于是一个表格，像Excel中的表格一样。</li>
<li>对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。其实，从数组底层的运行机制来看，其实没有多维数组。<br><img src="http://qd1ql2976.bkt.clouddn.com/3601" alt=""></li>
</ul>
</li>
<li><p>二维数组[][]的声明与初始化</p>
<ul>
<li><p>格式1 （动态初始化）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] arr &#x3D; new int[3][2];</span><br></pre></td></tr></table></figure>
<ul>
<li>定义了名称为arr的二维数组</li>
<li>二维数组中有3个一维数组</li>
<li>每一个一维数组中有2个元素</li>
<li>一维数组的名称分别为arr[0], arr[1], arr[2]</li>
<li>给第一个一维数组1脚标位赋值为78写法是：arr[0][1] = 78;</li>
</ul>
</li>
<li><p>格式2 （动态初始化）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] arr &#x3D; new int[3][];</span><br></pre></td></tr></table></figure>
<ul>
<li>二维数组中有3个一维数组。</li>
<li>每个一维数组都是默认初始化值null (注意：区别于格式1）</li>
<li>可以对这个三个一维数组分别进行初始化</li>
<li>arr[0] = new int[3]; arr[1] = new int[1]; arr[2] = new int[2];</li>
<li>注：int[][]arr = new int[][3]; //非法</li>
</ul>
</li>
<li><p>格式3 （静态初始化</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[][] arr &#x3D; new int[][]&#123;&#123;3,8,2&#125;,&#123;2,7&#125;,&#123;9,0,1,6&#125;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个名称为arr的二维数组，二维数组中有三个一维数组</li>
<li>每一个一维数组中具体元素也都已初始化</li>
<li>第一个一维数组 arr[0] = {3,8,2};</li>
<li>第二个一维数组 arr[1] = {2,7};</li>
<li>第三个一维数组 arr[2] = {9,0,1,6};</li>
<li>第三个一维数组的长度表示方式：arr[2].length;</li>
<li><strong>注意特殊写法情况</strong>： int[][] y ; int[] y[] ; int y[][] x是一维数组，y是二维数组。</li>
<li>Java中多维数组不必都是规则矩阵形式</li>
</ul>
</li>
</ul>
</li>
<li><p>二维数组元素的默认初始化值</p>
<ul>
<li>针对于初始化方式一：比如：int[][] arr = new int[4][3];<ul>
<li>外层元素的初始化值为：地址值</li>
<li>内层元素的初始化值为：与一维数组初始化情况相同</li>
</ul>
</li>
<li>针对于初始化方式二：比如：int[][] arr = new int[4][];<ul>
<li>外层元素的初始化值为：null</li>
<li>内层元素的初始化值为：不能调用，否则报错。</li>
</ul>
</li>
</ul>
</li>
<li><p>二维数组的内存解析<br> <img src="http://qd1ql2976.bkt.clouddn.com/3603" alt=""><br> <img src="http://qd1ql2976.bkt.clouddn.com/3605" alt=""><br> <img src="http://qd1ql2976.bkt.clouddn.com/3607" alt=""><br> <img src="http://qd1ql2976.bkt.clouddn.com/3609" alt=""></p>
</li>
<li><p>代码示例</p>
<ol>
<li><p>题目：<br><img src="http://qd1ql2976.bkt.clouddn.com/3631" alt=""></p>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	</span><br><span class="line">	int[][] arr &#x3D; new int[3][];</span><br><span class="line">	arr[0] &#x3D; new int[]&#123;3,5,8&#125;;</span><br><span class="line">	arr[1] &#x3D; new int[2];</span><br><span class="line">	arr[1][0] &#x3D; 12;</span><br><span class="line">	arr[1][1] &#x3D; 9;</span><br><span class="line">	arr[2] &#x3D; new int[]&#123;7,0,6,4&#125;;</span><br><span class="line">	</span><br><span class="line">	int sum &#x3D; 0;&#x2F;&#x2F;记录总和</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">		for(int j &#x3D; 0; j &lt; arr[i].length; j++)&#123;</span><br><span class="line">			sum +&#x3D; arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(&quot;总和为：&quot; + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h4 id="四、数组中涉及到的常见算法-排序算法"><a href="#四、数组中涉及到的常见算法-排序算法" class="headerlink" title="四、数组中涉及到的常见算法-排序算法"></a>四、数组中涉及到的常见算法-排序算法</h4><ol>
<li><p>排序：</p>
<ul>
<li>假设含有n个记录的序列为{R1，R2，…,Rn},其相应的关键字序列为{K1，K2，…,Kn}。将这些记录重新排序为{Ri1,Ri2,…,Rin},使得相应的关键字值满足条Ki1&lt;=Ki2&lt;=…&lt;=Kin,这样的一种操作称为排序。</li>
<li>通常来说，排序的目的是快速查找。</li>
</ul>
</li>
<li><p>衡量排序算法的优劣：</p>
<ol>
<li>时间复杂度：分析关键字的比较次数和记录的移动次数</li>
<li>空间复杂度：分析排序算法中需要多少辅助内存</li>
<li>稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。</li>
</ol>
</li>
<li><p>排序算法分类</p>
<ul>
<li>内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。</li>
<li>外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。</li>
</ul>
</li>
<li><p>十大内部排序（颜色为重要程度 红→黄→黑）</p>
<ol>
<li>交换排序（红）<ul>
<li>冒泡排序（红）</li>
<li>快速排序（红）</li>
</ul>
</li>
<li>选择排序（黑）<ul>
<li>直接选择排序（黑）</li>
<li>堆排序（黄）</li>
</ul>
</li>
<li>归并排序（黄）</li>
<li>插入排序（黑）<ul>
<li>直接插入排序（黑）</li>
<li>折半插入排序（黑）</li>
<li>Shell排序（黑）</li>
</ul>
</li>
<li>桶式排序（黑）</li>
<li>基数排序（黑）</li>
</ol>
</li>
<li><p>算法的5大特征</p>
<ul>
<li><strong>输入（Input）</strong>：有0个或多个输入数据，这些输入必须有清楚的描述和定义</li>
<li><strong>输出（Output）</strong>：至少有1个或多个输出结果，不可以没有输出结果</li>
<li><strong>有穷性（有限性，Finiteness）</strong>：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成</li>
<li><strong>确定性（明确性，Definiteness）</strong>：算法中的每一步都有确定的含义，不会出现二义性</li>
<li><strong>可行性（有效性，Effectiveness）</strong>：算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案</li>
<li>说明：满足确定性的算法也称为：确定性算法。现在人们也关注更广泛的概念，例如考虑各种非确定性的算法，如并行算法、概率算法等。另外，人们也关注并不要求终止的计算描述，这种描述有时被称为过程（procedure）</li>
</ul>
</li>
<li><p>冒泡排序</p>
<ul>
<li><p><strong>介绍</strong>：<br>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
</li>
<li><p><strong>排序思想</strong>：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。</li>
</ol>
</li>
<li><p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	int[] arr &#x3D; new int[]&#123;43,32,76,-98,0,64,33,-21,32,99&#125;;</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 0; i &lt; arr.length - 1;i++)&#123;</span><br><span class="line">		for(int j &#x3D; 0; j &lt; arr.length - i -1;j++)&#123;</span><br><span class="line">			if(arr[j] &gt; arr[j + 1])&#123;</span><br><span class="line">				int temp &#x3D; arr[j + 1];</span><br><span class="line">				arr[j + 1] &#x3D; arr[j];</span><br><span class="line">				arr[j] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>快速排序</p>
<ul>
<li><p><strong>介绍</strong>：<br>快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p>
<p>  快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))。</p>
</li>
<li><p><strong>排序思想</strong>：</p>
<ol>
<li>从数列中挑出一个元素，称为”基准”（pivot）。</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
<li>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li>
</ol>
</li>
<li><p><strong>图示</strong><br><img src="http://qd1ql2976.bkt.clouddn.com/3718" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/3720" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/3723" alt=""></p>
</li>
<li><p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>排序算法性能对比<br> <img src="http://qd1ql2976.bkt.clouddn.com/3725" alt=""></p>
</li>
</ol>
<ul>
<li>各种内部排序方法性能比较<ol>
<li>从平均时间而言：快速排序最佳。但在最坏情况下时间性能不如堆排序和归并排序。</li>
<li>从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。</li>
<li>从稳定性看：直接插入排序、冒泡排序和归并排序是稳定的；而直接选择排序、快速排序、Shell排序和堆排序是不稳定排序</li>
<li>从待排序的记录数n的大小看，n较小时，宜采用简单排序；而n较大时宜采用改进排序。</li>
</ol>
</li>
</ul>
<ol start="9">
<li>排序算法的选择<ol>
<li>若n较小(如n≤50)，可采用 直接插入或 直接选择排序。<ul>
<li>当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直<br>接插入，应选直接选择排序为宜。</li>
</ul>
</li>
<li>若文件初始状态基本有序(指正序)，则应选用 直接插入、冒泡或随机的 快速排序为宜；</li>
<li>若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。<h4 id="五、Arrays工具类的使用"><a href="#五、Arrays工具类的使用" class="headerlink" title="五、Arrays工具类的使用"></a>五、Arrays工具类的使用</h4></li>
</ol>
</li>
</ol>
<ul>
<li><p>java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。<br><img src="http://qd1ql2976.bkt.clouddn.com/3636" alt=""></p>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;1.boolean equals(int[] a,int[] b):判断两个数组是否相等。</span><br><span class="line">	int[] arr1 &#x3D; new int[]&#123;1,2,3,4&#125;;</span><br><span class="line">	int[] arr2 &#x3D; new int[]&#123;1,3,2,4&#125;;</span><br><span class="line">	boolean isEquals &#x3D; Arrays.equals(arr1, arr2);</span><br><span class="line">	System.out.println(isEquals);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;2.String toString(int[] a):输出数组信息。</span><br><span class="line">	System.out.println(Arrays.toString(arr1));</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	&#x2F;&#x2F;3.void fill(int[] a,int val):将指定值填充到数组之中。</span><br><span class="line">	Arrays.fill(arr1,10);</span><br><span class="line">	System.out.println(Arrays.toString(arr1));</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;4.void sort(int[] a):对数组进行排序。</span><br><span class="line">	Arrays.sort(arr2);</span><br><span class="line">	System.out.println(Arrays.toString(arr2));</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;5.int binarySearch(int[] a,int key)</span><br><span class="line">	int[] arr3 &#x3D; new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;</span><br><span class="line">	int index &#x3D; Arrays.binarySearch(arr3, 210);</span><br><span class="line">	if(index &gt;&#x3D; 0)&#123;</span><br><span class="line">		System.out.println(index);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		System.out.println(&quot;未找到&quot;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="六、数组中使用的常见异常"><a href="#六、数组中使用的常见异常" class="headerlink" title="六、数组中使用的常见异常"></a>六、数组中使用的常见异常</h4><ol>
<li><p>数组脚标越界异常(ArrayIndexOutOfBoundsException)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] arr &#x3D; new int[2];</span><br><span class="line">System.out.println(arr[2]);</span><br><span class="line">System.out.println(arr[-1]);</span><br></pre></td></tr></table></figure>
<ul>
<li>访问到了数组中的不存在的脚标时发生。</li>
</ul>
</li>
<li><p>空指针异常(NullPointerException)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] arr &#x3D; null;</span><br><span class="line">System.out.println(arr[0]);</span><br></pre></td></tr></table></figure>
<ul>
<li>arr引用没有指向实体，却在操作实体中的元素时。</li>
</ul>
</li>
<li><p>代码示例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;1. 数组角标越界的异常：ArrayIndexOutOfBoundsExcetion</span><br><span class="line">	int[] arr &#x3D; new int[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;		for(int i &#x3D; 0;i &lt;&#x3D; arr.length;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;			System.out.println(arr[i]);</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;		System.out.println(arr[-2]);</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;hello&quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;2.2. 空指针异常：NullPointerException</span><br><span class="line">	&#x2F;&#x2F;情况一：</span><br><span class="line">&#x2F;&#x2F;		int[] arr1 &#x3D; new int[]&#123;1,2,3&#125;;</span><br><span class="line">&#x2F;&#x2F;		arr1 &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(arr1[0]);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;情况二：</span><br><span class="line">&#x2F;&#x2F;		int[][] arr2 &#x3D; new int[4][];</span><br><span class="line">&#x2F;&#x2F;		System.out.println(arr2[0][0]);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;情况三：</span><br><span class="line">	String[] arr3 &#x3D; new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;;</span><br><span class="line">	arr3[0] &#x3D; null;</span><br><span class="line">	System.out.println(arr3[0].toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>一维数组</tag>
        <tag>二维数组</tag>
        <tag>排序算法</tag>
        <tag>冒泡排序</tag>
        <tag>快速排序</tag>
        <tag>排序算法性能对比</tag>
        <tag>Arrays工具类</tag>
        <tag>数组异常</tag>
        <tag>数组越界异常</tag>
        <tag>空指针异常</tag>
      </tags>
  </entry>
  <entry>
    <title>11.Java基础知识-面向对象编程（上）</title>
    <url>/2020/07/23/11-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="面向对象编程（上）"><a href="#面向对象编程（上）" class="headerlink" title="面向对象编程（上）"></a>面向对象编程（上）</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/3788" alt=""></p>
<h4 id="一、面向过程与面向对象"><a href="#一、面向过程与面向对象" class="headerlink" title="一、面向过程与面向对象"></a>一、面向过程与面向对象</h4><ol>
<li><p>何谓“面向对象”的编程思想？<br> 首先解释一下“思想”。</p>
<p> 先问你个问题：你想做个怎样的人？</p>
<p> 可能你会回答：我想做个好人，孝敬父母，尊重长辈，关爱亲朋……</p>
<p> 你看，这就是思想。这是你做人的思想，或者说，是你做人的原则。</p>
<p> 做人有做人的原则，编程也有编程的原则。这些编程的原则呢，就是编程思想。</p>
</li>
<li><p>面向过程(POP) 与 与 象 面向对象(OOP)</p>
<ul>
<li><p>面向对象：Object Oriented Programming</p>
</li>
<li><p>面向过程：Procedure Oriented Programming</p>
</li>
<li><p>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</p>
</li>
<li><p>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。</p>
</li>
<li><p>人把大象装冰箱</p>
<p><img src="http://qd1ql2976.bkt.clouddn.com/3848" alt=""></p>
</li>
</ul>
</li>
<li><p>面向对象的三大特征</p>
<ul>
<li>封装 (Encapsulation)</li>
<li>继承 (Inheritance)</li>
<li>多态 (Polymorphism)</li>
</ul>
</li>
<li><p>面向对象的思想概述</p>
<ul>
<li>程序员从面向过程的执行者转化成了面向对象的指挥者</li>
<li>面向对象分析方法分析问题的思路和步骤：<ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体。</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。</li>
<li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。<h4 id="二、Java基本元素：类和对象"><a href="#二、Java基本元素：类和对象" class="headerlink" title="二、Java基本元素：类和对象"></a>二、Java基本元素：类和对象</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象的思想概述</p>
<ul>
<li>类(Class)和对象(Object)是面向对象的核心概念。<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>
</ul>
</li>
<li>“万事万物皆对象”<br><img src="http://qd1ql2976.bkt.clouddn.com/3872" alt=""></li>
<li>可以理解为： 类  =  抽象概念的人；对象  =  实实在在的某个人</li>
<li>面向对象程序设计的重点是类的设计</li>
<li>类的设计，其实就是类的成员的设计</li>
</ul>
</li>
<li><p>Java 类及类的成员</p>
<ul>
<li>属性：对应类中的成员变量</li>
<li>行为：对应类中的成员方法</li>
<li>Field =  属性 =  成员变量</li>
<li>Method = (成员) 方法 =  函数</li>
</ul>
</li>
<li><p>类的语法格式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">修饰符 class  类名 &#123;</span><br><span class="line">    属性声明;</span><br><span class="line">    方法声明;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">public class Person&#123;</span><br><span class="line"></span><br><span class="line">    private int age ; &#x2F;&#x2F;声明私有变量age</span><br><span class="line">    </span><br><span class="line">    public void showAge(int i)&#123;&#x2F;&#x2F;声明方法showAge( )</span><br><span class="line">        age &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建Java自定义类</p>
<ul>
<li>定义类（考虑修饰符、类名）</li>
<li>编写类的属性（考虑修饰符、属性类型、属性名、初始化值）</li>
<li>编写类的方法（考虑修饰符、返回值类型、方法名、形参等）<h4 id="三、对象的创建和使用"><a href="#三、对象的创建和使用" class="headerlink" title="三、对象的创建和使用"></a>三、对象的创建和使用</h4><img src="http://qd1ql2976.bkt.clouddn.com/3907" alt=""></li>
</ul>
</li>
</ol>
<ul>
<li>创建对象语法：  类名 对象名 = new  类名();</li>
<li>使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）</li>
<li>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。<ul>
<li>如：new Person().shout();</li>
</ul>
</li>
<li>使用情况<ul>
<li>如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。</li>
<li>我们经常将匿名对象作为实参传递给一个方法调用。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    public int legs;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(“Eating.”);</span><br><span class="line">    &#125;</span><br><span class="line">    public viod move()&#123;</span><br><span class="line">        System.out.println(“Move.”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Zoo&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        &#x2F;&#x2F; 创建对象</span><br><span class="line">        Animal xb&#x3D;new Animal();</span><br><span class="line">        xb.legs&#x3D;4;&#x2F;&#x2F; 访问属性</span><br><span class="line">        System.out.println(xb.legs);</span><br><span class="line">        xb.eat();&#x2F;&#x2F; 访问方法</span><br><span class="line">        xb.move();&#x2F;&#x2F; 访问方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qd1ql2976.bkt.clouddn.com/3910" alt=""></p>
<ul>
<li>说明：如果创建了一个类的多个对象，对于类中定义的属性，每个对象都拥有各自的一套副本，且互不干扰。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Zoo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Animal xb &#x3D; new Animal();</span><br><span class="line">        Animal xh &#x3D; new Animal();</span><br><span class="line">        xb.legs &#x3D; 4;</span><br><span class="line">        xh.legs &#x3D; 0;</span><br><span class="line">        System.out.println(xb.legs); &#x2F;&#x2F; 4</span><br><span class="line">        System.out.println(xh.legs); &#x2F;&#x2F; 0</span><br><span class="line">        xb.legs &#x3D; 2;</span><br><span class="line">        System.out.println(xb.legs); &#x2F;&#x2F; 2</span><br><span class="line">        System.out.println(xh.legs); &#x2F;&#x2F; 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>提示<ul>
<li>类的访问机制：<ul>
<li>在一个类中的访问机制：类中的方法可以直接访问类中的成员变量（例外：static方法访问非static，编译不通过。）</li>
<li>在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员。</li>
</ul>
</li>
</ul>
</li>
<li>对象的产生<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3962" alt=""></li>
<li>对象的使用<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3964" alt=""></li>
<li>对象的生命周期<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3966" alt=""></li>
<li>对象的创建和使用：内存解析<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3972" alt=""><br>  <img src="http://qd1ql2976.bkt.clouddn.com/3978" alt=""><br>  <img src="http://qd1ql2976.bkt.clouddn.com/3974" alt=""><br>  <img src="http://qd1ql2976.bkt.clouddn.com/3976" alt=""><h4 id="四、类的成员之一：属性"><a href="#四、类的成员之一：属性" class="headerlink" title="四、类的成员之一：属性"></a>四、类的成员之一：属性</h4></li>
</ul>
<ol>
<li><p>语法格式：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符  数据类型  属性名 &#x3D;  初始化值;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>说明1:  修饰符</p>
<ul>
<li>常用的权限修饰符有：private、缺省、protected、public</li>
<li>其他修饰符：static、final (暂不考虑)</li>
</ul>
</li>
<li><p>说明2 ：数据类型</p>
<ul>
<li>任何基本数据类型(如int、Boolean)或任何引用数据类型。</li>
</ul>
</li>
<li><p>说明3 ：属性名</p>
<ul>
<li>属于标识符，符合命名规则和规范即可。</li>
</ul>
</li>
<li><p>举例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">private int age; &#x2F;&#x2F; 声明private变量 age</span><br><span class="line">public String name &#x3D; “Lila”; &#x2F;&#x2F;声明public变量 name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>变量的分类：成员变量与局部变量</p>
</li>
</ol>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量。<br><img src="http://qd1ql2976.bkt.clouddn.com/4015" alt=""></li>
<li>注意：二者在初始化值方面的异同:<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，均需显式初始化。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>成员变量（属性）和局部变量的区别？<br> <img src="http://qd1ql2976.bkt.clouddn.com/4017" alt=""></p>
</li>
<li><p>成员变量vs局部变量的内存位置<br> <img src="http://qd1ql2976.bkt.clouddn.com/4019" alt=""></p>
</li>
<li><p>对象属性的默认初始化赋值</p>
<ul>
<li>当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。除了基本数据类型之外的变量类型都是引用类型，如上面的Person及前面讲过的数组。<br><img src="http://qd1ql2976.bkt.clouddn.com/4021" alt=""><h4 id="五、类的成员之二：方法"><a href="#五、类的成员之二：方法" class="headerlink" title="五、类的成员之二：方法"></a>五、类的成员之二：方法</h4></li>
</ul>
</li>
<li><p>什么是方法(method 、函数):</p>
<ul>
<li>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。</li>
<li>将功能封装为方法的目的是，可以实现代码重用，简化代码</li>
<li>Java里的方法不能独立存在，所有的方法必须定义在类里。</li>
</ul>
</li>
<li><p>方法的声明格式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 形参1, 参数类型 形参2, ….）｛</span><br><span class="line">    方法体程序代码;</span><br><span class="line">    return  返回值;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<ul>
<li>修饰符：public, 缺省,private, protected等</li>
<li>返回值类型：<ul>
<li>没有返回值：void。</li>
<li>有返回值，声明出返回值的类型。与方法体中“return 返回值”</li>
</ul>
</li>
<li>方法名 ：</li>
<li>属于标识符，命名时遵循标识符命名规则和规范，“见名知意”</li>
<li>形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开</li>
<li>返回值：方法在执行完毕后返还给调用它的程序的数据。</li>
</ul>
</li>
<li><p>举例 ：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    public int getAge() &#123; &#x2F;&#x2F;声明方法getAge()</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int i) &#123; &#x2F;&#x2F;声明方法setAge</span><br><span class="line">        age &#x3D; i; &#x2F;&#x2F;将参数i的值赋给类的成员变量age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的分类：<br> <img src="http://qd1ql2976.bkt.clouddn.com/4074" alt=""></p>
</li>
<li><p>方法的调用</p>
<ul>
<li>方法通过方法名被调用，且只有被调用才会执行。</li>
<li>方法调用的过程分析<br><img src="http://qd1ql2976.bkt.clouddn.com/4076" alt=""></li>
</ul>
</li>
<li><p>注 意：</p>
</li>
</ol>
<ul>
<li>方法被调用一次，就会执行一次</li>
<li>没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可以不必使用return语句。如果使用，仅用来结束方法。</li>
<li>定义方法时，方法的结果应该返回给调用者，交由调用者处理。</li>
<li>方法中只能调用方法或属性，不可以在方法内部定义方法。<h4 id="六、再谈方法"><a href="#六、再谈方法" class="headerlink" title="六、再谈方法"></a>六、再谈方法</h4></li>
</ul>
<ol>
<li><p>方法的重载(overload)</p>
<ul>
<li><p>重载的概念:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p>
</li>
<li><p>重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</p>
</li>
<li><p>重载示例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;返回两个整数的和</span><br><span class="line">int add(int x,int y)&#123;return x+y;&#125;</span><br><span class="line">&#x2F;&#x2F;返回三个整数的和</span><br><span class="line">int add(int x,int y,int z)&#123;return x+y+z;&#125;</span><br><span class="line">&#x2F;&#x2F;返回两个小数的和</span><br><span class="line">double add(double x,double y)&#123;return x+y;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用重载方法，可以为编程带来方便。例如，System.out.println()方法就是典型的重载方法，其内部的声明形式如下 ：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void println(byte x)</span><br><span class="line">public void println(short x)</span><br><span class="line">public void println(int x)</span><br><span class="line">public void println(long x)</span><br><span class="line">public void println(float x)</span><br><span class="line">public void println(double x)</span><br><span class="line">public void println(char x)</span><br><span class="line">public void println(double x)</span><br><span class="line">public void println()</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>可变形参的方法</p>
<h6 id="JavaSE-5-0-中提供了Varargs-variable-number-of-arguments-机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。"><a href="#JavaSE-5-0-中提供了Varargs-variable-number-of-arguments-机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。" class="headerlink" title="JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。"></a>JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。</h6><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</span><br><span class="line">public static void test(int a ,String[] books);</span><br><span class="line">&#x2F;&#x2F;JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量</span><br><span class="line">public static void test(int a ,String…books);</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>说明：</p>
<ol>
<li>声明格式：方法名(参数的类型名 …参数名)</li>
<li>可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</li>
<li>可变个数形参的方法与同名的方法之间，彼此构成重载</li>
<li>可变参数方法的使用与方法参数部分使用数组是一致的</li>
<li>方法的参数部分有可变形参，需要放在形参声明的最后</li>
<li>在一个方法的形参位置，最多只能声明一个可变个数形参</li>
</ol>
</li>
<li><p>实例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test(String[] msg)&#123;</span><br><span class="line">System.out.println(“含字符串数组参数的test方法 &quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void test1(String book)&#123;</span><br><span class="line">System.out.println(“****与可变形参方法构成重载的test1方法****&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void test1(String ... books)&#123;</span><br><span class="line">System.out.println(&quot;****形参长度可变的test1方法****&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">TestOverload to &#x3D; new TestOverload();</span><br><span class="line">&#x2F;&#x2F;下面两次调用将执行第二个test方法</span><br><span class="line">to.test1();</span><br><span class="line">to.test1(&quot;aa&quot; , &quot;bb&quot;);</span><br><span class="line">&#x2F;&#x2F;下面将执行第一个test方法</span><br><span class="line">to.test(new String[]&#123;&quot;aa&quot;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方法参数的值传递机制</p>
<ul>
<li><p>方法，必须由其所在类或对象调用才有意义。若方法含有参数：</p>
<ul>
<li>形参：方法声明时的参数</li>
<li>实参：方法调用时实际传给形参的参数值</li>
</ul>
</li>
<li><p>Java的实参值如何传入方法呢？</p>
<ul>
<li>Java里方法的参数传递方式只有一种：值传递。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</li>
<li>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</li>
</ul>
</li>
</ul>
</li>
<li><p>基本数据类型的参数传递<br><img src="http://qd1ql2976.bkt.clouddn.com/4142" alt=""></p>
</li>
<li><p>引用数据类型的参数传递<br><img src="http://qd1ql2976.bkt.clouddn.com/4144" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/4146" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/4148" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/4150" alt=""></p>
</li>
<li><p>例题1：交换两个数的数值</p>
<ul>
<li><p>错误实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransferTest1 &#123;</span><br><span class="line">    public void swap(int a, int b) &#123;</span><br><span class="line">        int tmp &#x3D; a;</span><br><span class="line">        a &#x3D; b;</span><br><span class="line">        b &#x3D; tmp;</span><br><span class="line">        System.out.println(&quot;swap方法里，a的值是&quot; + a + &quot;；b的值是&quot; + b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TransferTest1 test &#x3D; new TransferTest1();</span><br><span class="line">        int a &#x3D; 5;</span><br><span class="line">        int b &#x3D; 10;</span><br><span class="line">        test.swap(a, b);</span><br><span class="line">        System.out.println(&quot;交换结束后，变量a的值是&quot; + a + &quot;；变量b的值是&quot; + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>参数类型为：基本数据类型<br><img src="http://qd1ql2976.bkt.clouddn.com/4183" alt=""></p>
</li>
<li><p>正确实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class DataSwap &#123;</span><br><span class="line">    public int a;</span><br><span class="line">    public int b;</span><br><span class="line">&#125;</span><br><span class="line">public class TransferTest2 &#123;</span><br><span class="line">    public static void swap(DataSwap ds) &#123;</span><br><span class="line">        int temp &#x3D; ds.a;</span><br><span class="line">        ds.a &#x3D; ds.b;</span><br><span class="line">        ds.b &#x3D; temp;</span><br><span class="line">        System.out.println(&quot;swap方法里，a Field的值是&quot; + ds.a + &quot;;b Field的值是&quot; + ds.b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DataSwap ds &#x3D; new DataSwap();</span><br><span class="line">        ds.a &#x3D; 5;</span><br><span class="line">        ds.b &#x3D; 10;</span><br><span class="line">        swap(ds);</span><br><span class="line">        System.out.println(&quot;交换结束后，a Field的值是&quot; + ds.a + &quot;;b Field的值是&quot; + ds.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>参数类型为：引用数据类型<br><img src="http://qd1ql2976.bkt.clouddn.com/4185" alt=""></p>
</li>
</ul>
</li>
<li><p>例题二：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransferTest3 &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        TransferTest3 test &#x3D; new TransferTest3();</span><br><span class="line">        test.first();</span><br><span class="line">    &#125;</span><br><span class="line">    public void first() &#123;</span><br><span class="line">        int i &#x3D; 5;</span><br><span class="line">        Value v &#x3D; new Value();</span><br><span class="line">        v.i &#x3D; 25;</span><br><span class="line">        second(v, i);</span><br><span class="line">        System.out.println(v.i);</span><br><span class="line">    &#125;</span><br><span class="line">    public void second(Value v, int i) &#123;</span><br><span class="line">        i &#x3D; 0;</span><br><span class="line">        v.i &#x3D; 20;</span><br><span class="line">        Value val &#x3D; new Value();</span><br><span class="line">        v &#x3D; val;</span><br><span class="line">        System.out.println(v.i + &quot; &quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Value &#123;</span><br><span class="line">    int i &#x3D; 15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li>方法的参数传递图示<br><img src="http://qd1ql2976.bkt.clouddn.com/4187" alt=""></li>
</ul>
</li>
<li><p>面试题<br><img src="http://qd1ql2976.bkt.clouddn.com/4189" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       int a &#x3D; 10;</span><br><span class="line">       int b &#x3D; 20;</span><br><span class="line">        </span><br><span class="line">       method(a, b);</span><br><span class="line">        </span><br><span class="line">       System.out.println(&quot;a&#x3D;&quot;+a);</span><br><span class="line">       System.out.println(&quot;b&#x3D;&quot;+b);</span><br><span class="line">       tes();</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;方法1-终止JVM</span><br><span class="line">   public static void method(int a,int b) &#123;</span><br><span class="line">       System.out.print(&quot;a&#x3D;100 b&#x3D;200&quot;);</span><br><span class="line">       System.exit(0);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;方法2-另一种是改变打印输出流</span><br><span class="line">   public static void method(final int a,final int b) &#123;</span><br><span class="line">       PrintStream stream &#x3D; new PrintStream(System.out)&#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void print(String s) &#123;</span><br><span class="line">               super.print(s.replace(a+&quot;&quot;, a*10+&quot;&quot;).replace(b+&quot;&quot;, b*10+&quot;&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       System.setOut(stream);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>  <img src="http://qd1ql2976.bkt.clouddn.com/4191" alt=""></p>
</li>
</ul>
</li>
<li><p>递归(recursion) 方法</p>
<ul>
<li><p>递归方法：一个方法体内调用它自身。</p>
</li>
<li><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</p>
</li>
<li><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;计算1-100之间所有自然数的和</span><br><span class="line">public int sum(int num)&#123;</span><br><span class="line">    if(num &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return num + sum(num - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>拓展<br><img src="http://qd1ql2976.bkt.clouddn.com/4211" alt=""><br>双重递归是以指数级增长的<br><img src="http://qd1ql2976.bkt.clouddn.com/4213" alt=""></p>
<h4 id="七、OOP特征一：封装与隐藏"><a href="#七、OOP特征一：封装与隐藏" class="headerlink" title="七、OOP特征一：封装与隐藏"></a>七、OOP特征一：封装与隐藏</h4></li>
</ul>
</li>
<li><p>为什么需要封装？封装的作用和含义？</p>
<ul>
<li>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？</li>
<li>我要开车，…</li>
</ul>
</li>
<li><p>我们程序设计追求“高内聚，低耦合”。</p>
<ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>低耦合 ：仅对外暴露少量的方法用于使用。</li>
</ul>
</li>
<li><p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p>
</li>
<li><p>问题引入</p>
<ul>
<li><p>使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或 安全性</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public int legs;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">       System.out.println(&quot;Eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        System.out.println(&quot;Moving.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Zoo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Animal xb &#x3D; new Animal();</span><br><span class="line">        xb.legs &#x3D; 4;</span><br><span class="line">        System.out.println(xb.legs);</span><br><span class="line">        xb.eat();</span><br><span class="line">        xb.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题：xb.legs = -1000;</p>
</li>
<li><p>应该将legs 属性保护起来，防止乱用。</p>
</li>
<li><p>保护的方式：信息隐藏</p>
</li>
</ul>
</li>
<li><p>信息的封装和隐藏</p>
<ul>
<li><p>Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：</p>
</li>
<li><p>隐藏一个类中不需要对外提供的实现细节；</p>
</li>
<li><p>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；</p>
</li>
<li><p>便于修改，增强代码的可维护性；</p>
</li>
<li><p>举例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private int legs;&#x2F;&#x2F; 将属性legs定义为private，只能被Animal类内部访问</span><br><span class="line">    public void setLegs(int i) &#123; &#x2F;&#x2F; 在这里定义方法 eat() 和 move()</span><br><span class="line">        if (i !&#x3D; 0 &amp;&amp; i !&#x3D; 2 &amp;&amp; i !&#x3D; 4) &#123;</span><br><span class="line">        System.out.println(&quot;Wrong number of legs!&quot;);</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line">        legs &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getLegs() &#123;</span><br><span class="line">        return legs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Zoo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Animal xb &#x3D; new Animal();</span><br><span class="line">        xb.setLegs(4); &#x2F;&#x2F; xb.setLegs(-1000);</span><br><span class="line">        &#x2F;&#x2F;xb.legs &#x3D; -1000; &#x2F;&#x2F; 非法</span><br><span class="line">        System.out.println(xb.getLegs());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>四种访问权限修饰符</p>
<ul>
<li>Java权限修饰符public、protected、(缺省)、private置于 类的成员定义前，用来限定对象对该类成员的访问权限。<br><img src="http://qd1ql2976.bkt.clouddn.com/4261" alt=""></li>
<li>对于class的权限修饰只可以用public和default(缺省)。<ul>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。<br><img src="http://qd1ql2976.bkt.clouddn.com/4263" alt=""><h4 id="八、类的成员之三：构造器"><a href="#八、类的成员之三：构造器" class="headerlink" title="八、类的成员之三：构造器"></a>八、类的成员之三：构造器</h4></li>
</ul>
</li>
</ul>
</li>
<li><p>构造器的特征</p>
<ul>
<li>它具有与类相同的名称</li>
<li>它不声明返回值类型。（与声明为void不同）</li>
<li>不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值</li>
</ul>
</li>
<li><p>构造器的作用：</p>
<ul>
<li>如：Order o = new Order(); Person p = new Person(“Peter”,15);</li>
<li>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。</li>
</ul>
</li>
<li><p>格式</p>
<ul>
<li><p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 类名 (参数列表) &#123;</span><br><span class="line">    初始化语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>举例：创建Animal 类的实例：Animal a = new Animal();调用构造器，将legs初始化为4。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    private int legs;</span><br><span class="line">    &#x2F;&#x2F; 构造器</span><br><span class="line">    public Animal() &#123;</span><br><span class="line">        legs &#x3D; 4;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLegs(int i) &#123;</span><br><span class="line">        legs &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getLegs() &#123;</span><br><span class="line">        return legs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>根据参数不同，构造器可以分为如下两类：<ul>
<li>隐式无参构造器（系统默认提供）</li>
<li>显式定义一个或多个</li>
</ul>
</li>
<li>注 意：<ul>
<li>Java 语言中，每个类都至少有一个构造器</li>
<li>默认构造器的修饰符与所属类的修饰符一致</li>
<li>一旦显式定义了构造器，则系统不再提供默认构造</li>
<li>一个类可以创建多个重载的构造器</li>
<li>父类的构造器不可被子类继承</li>
</ul>
</li>
</ul>
</li>
<li><p>构造器重载</p>
<ul>
<li><p>构造器一般用来创建对象的同时初始化对象。如</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Person(String n , int a)&#123; </span><br><span class="line">        name&#x3D;n;</span><br><span class="line">        age&#x3D;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    public Person(String name, int age, Date d) &#123;this(name,age);…&#125;</span><br><span class="line">    public Person(String name, int age) &#123;…&#125;</span><br><span class="line">    public Person(String name, Date d) &#123;…&#125;</span><br><span class="line">    public Person()&#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器重载，参数列表必须不同</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Date birthDate;</span><br><span class="line">    public Person(String n, int a, Date d) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">        age &#x3D; a;</span><br><span class="line">        birthDate &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String n, int a) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">        age &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String n, Date d) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">        birthDate &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String n) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">        age &#x3D; 30;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>总结：属性赋值过程</p>
<ul>
<li>截止到目前，我们讲到了很多位置都可以对类的属性赋值。现总结这几个位置，并指明赋值的先后顺序。</li>
<li>赋值的位置：<ul>
<li>①默认初始化</li>
<li>②显式初始化</li>
<li>③构造器中初始化</li>
<li>④通过“对象.属性“或“对象.方法”的方式赋值</li>
</ul>
</li>
<li>赋值的先后顺序：<ul>
<li>① - ② - ③ - ④</li>
</ul>
</li>
</ul>
</li>
<li><p>拓展知识：JavaBean</p>
<ul>
<li><p>JavaBean是一种Java语言写成的可重用组件。</p>
</li>
<li><p>所谓javaBean，是指符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
</li>
<li><p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</p>
</li>
<li><p>JavaBean示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class JavaBean &#123;</span><br><span class="line">    private String name; &#x2F;&#x2F; 属性一般定义为private</span><br><span class="line">    private int age;</span><br><span class="line">    public JavaBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int a) &#123;</span><br><span class="line">        age &#x3D; a;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String n) &#123;</span><br><span class="line">        name &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>拓展知识：UML类图<br> <img src="http://qd1ql2976.bkt.clouddn.com/4373" alt=""></p>
<h4 id="九、关键字：this"><a href="#九、关键字：this" class="headerlink" title="九、关键字：this"></a>九、关键字：this</h4></li>
<li><p>this 是什么？</p>
<ul>
<li>在Java中，this关键字比较难理解，它的作用和其词义很接近。<ul>
<li>它在方法内部使用，即这个方法所属对象的引用；</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
</ul>
</li>
<li>this 可以调用类的属性、方法和构造器</li>
<li>什么时候使用this关键字呢？<ul>
<li>当在方法内需要用到调用该方法的对象时，就用this。</li>
<li>具体的：我们可以用this来区分属性和局部变量。</li>
<li>比如：this.name = name;</li>
</ul>
</li>
</ul>
</li>
<li><p>使用规则</p>
<ul>
<li>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性。不过，通常我们都习惯省略this。</li>
<li>当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量</li>
<li>使用this访问属性和方法时，如果在本类中未找到，会从父类中查找</li>
<li>this可以作为一个类中构造器相互调用的特殊格式</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！</li>
<li>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器</li>
<li>如果一个类中声明了n个构造器，则最多有n-1个构造器中使用了”this(形参列表)”</li>
<li>“this(形参列表)”必须声明在类的构造器的首行！</li>
<li>在类的一个构造器中，最多只能声明一个”this(形参列表)”</li>
</ul>
</li>
<li><p>使用this，调用属性、方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123; &#x2F;&#x2F; 定义Person类</span><br><span class="line">    private String name ;</span><br><span class="line">    private int age ;</span><br><span class="line">    public Person(String name,int age)&#123;</span><br><span class="line">        this.name &#x3D; name ;</span><br><span class="line">        this.age &#x3D; age ; </span><br><span class="line">    &#125;</span><br><span class="line">    public void getInfo()&#123;</span><br><span class="line">        System.out.println(&quot;姓名：&quot; + name) ;</span><br><span class="line">        this.speak();</span><br><span class="line">    &#125;</span><br><span class="line">    public void speak()&#123;</span><br><span class="line">        System.out.println(“年龄：” + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>当前正在操作本方法的对象称为当前对象。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123; &#x2F;&#x2F; 定义Person类</span><br><span class="line">    String name;</span><br><span class="line">    Person(String name)&#123;</span><br><span class="line">        this.name &#x3D; name;&#125;</span><br><span class="line">        public void getInfo()&#123;</span><br><span class="line">        System.out.println(&quot;Person类 --&gt; &quot; + this.name) ;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean compare(Person p)&#123;</span><br><span class="line">        return this.name&#x3D;&#x3D;p.name;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">public class PersonTest&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Person per1 &#x3D; new Person(&quot;张三&quot;) ;</span><br><span class="line">        Person per2 &#x3D; new Person(&quot;李四&quot;) ;</span><br><span class="line">        per1.getInfo() ; &#x2F;&#x2F; 当前调用getInfo()方法的对象是per1</span><br><span class="line">        per2.getInfo() ; &#x2F;&#x2F; 当前调用getInfo()方法的对象是per2</span><br><span class="line">        boolean b &#x3D; per1.compare(per2);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用this调用本类的构造器</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person&#123; &#x2F;&#x2F; 定义Person类</span><br><span class="line">    private String name ;</span><br><span class="line">    private int age ;</span><br><span class="line">    public Person()&#123; &#x2F;&#x2F; 无参构造器</span><br><span class="line">    System.out.println(&quot;新对象实例化&quot;) ;</span><br><span class="line">&#125;</span><br><span class="line">public Person(String name)&#123;</span><br><span class="line">        this(); &#x2F;&#x2F; 调用本类中的无参构造器</span><br><span class="line">        this.name &#x3D; name ;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name,int age)&#123;</span><br><span class="line">        this(name) ; &#x2F;&#x2F; 调用有一个参数的构造器</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getInfo()&#123;</span><br><span class="line">        return &quot;姓名：&quot; + name + &quot;，年龄：&quot; + age ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="十、关键字：package、import"><a href="#十、关键字：package、import" class="headerlink" title="十、关键字：package、import"></a>十、关键字：package、import</h4><ol>
<li><p>关键字—package</p>
<ul>
<li>包的作用：<ul>
<li>包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式</li>
<li>包可以包含类和子包，划分项目层次，便于管理</li>
<li>解决类命名冲突的问题</li>
<li>控制访问权限</li>
</ul>
</li>
</ul>
</li>
<li><p>MVC设计模式</p>
<ul>
<li>MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。<br><img src="http://qd1ql2976.bkt.clouddn.com/4499" alt=""></li>
<li>模型层 model 主要处理数据<ul>
<li>数据对象封装 model.bean/domain</li>
<li>数据库操作类 model.dao</li>
<li>数据库 model.db</li>
</ul>
</li>
<li>视图层 view  显示数据<ul>
<li>相关工具类 view.utils</li>
<li>自定义view view.ui</li>
</ul>
</li>
<li>控制层 controller  处理业务逻辑<ul>
<li>应用界面相关 controller.activity</li>
<li>存放fragment controller.fragment</li>
<li>显示列表的适配器 controller.adapter</li>
<li>服务相关的 controller.service</li>
<li>抽取的基类 controller.base</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK 中主要的包介绍</p>
<ul>
<li>java.lang—-包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能</li>
<li>java.net—-包含执行与网络相关的操作的类和接口。</li>
<li>java.io —-包含能提供多种输入/输出功能的类</li>
<li>java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</li>
<li>java.text—-包含了一些java格式化相关的类</li>
<li>java.sql—-包含了java进行JDBC数据库编程的相关类/接口</li>
<li>java.awt—-包含了构成抽象窗口工具集（abstract windowtoolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。(C/S)</li>
</ul>
</li>
<li><p>关键字—import</p>
<ul>
<li><p>为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类(.*)。import语句告诉编译器到哪里去寻找类。</p>
</li>
<li><p>语法格式:     <code>import 包名. 类名</code>;</p>
</li>
<li><p>应用举例：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pack1.pack2.Test; &#x2F;&#x2F;import pack1.pack2.*; 表示引入pack1.pack2包中的所有结构</span><br><span class="line">public class PackTest&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Test t &#x3D; new Test(); &#x2F;&#x2F;Test类在在pack1.pack2包 包 中定义</span><br><span class="line">        t.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li>在源文件中使用import显式的导入指定包下的类或接口</li>
<li>声明在包的声明和类的声明之间</li>
<li>如果需要导入多个类或接口，那么就并列显式多个import语句即可</li>
<li>举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</li>
<li>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</li>
<li>如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。</li>
<li>如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。</li>
<li>import static组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>面向过程</tag>
        <tag>类和对象</tag>
        <tag>类的成员变量</tag>
        <tag>类的方法</tag>
        <tag>方法重载</tag>
        <tag>类的封装</tag>
        <tag>构造器</tag>
        <tag>关键字this</tag>
        <tag>关键字import</tag>
        <tag>关键字package</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub&amp;Git基础</title>
    <url>/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-概述与目的"><a href="#1-概述与目的" class="headerlink" title="1.概述与目的"></a>1.概述与目的</h2><ol>
<li><h5 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h5>Git是一个免费、开源的版本控制软件</li>
<li><h5 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h5>版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。（记录文件的所有历史变化、随时可恢复到任何一个历史状态、多人协作开发或修改错误恢复）</li>
<li><h5 id="什么是Github"><a href="#什么是Github" class="headerlink" title="什么是Github"></a>什么是Github</h5>Github是全球最大的社交编程及代码托管网站（<a href="https://github.com/）。" target="_blank" rel="noopener">https://github.com/）。</a><br>Github可以托管各种git库，并提供一个web界面（用户名.github.io/仓库名）</li>
<li><h5 id="Github和Git是什么关系"><a href="#Github和Git是什么关系" class="headerlink" title="Github和Git是什么关系"></a>Github和Git是什么关系</h5>Git是版本控制软件<br>Github是项目代码托管的平台，借助Git来管理项目代码</li>
<li><h5 id="为什么学习github"><a href="#为什么学习github" class="headerlink" title="为什么学习github"></a>为什么学习github</h5>学习优秀的开源项目<br>关注行业前辈了解最新的行业动态<br>借助github托管项目代码</li>
<li><h5 id="简单介绍Git"><a href="#简单介绍Git" class="headerlink" title="简单介绍Git"></a>简单介绍Git</h5>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢?比如说自己在电脑上改了文件A,其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/1.png" class="">
借助Github托管项目代码。<h2 id="2-GitHub基本概念"><a href="#2-GitHub基本概念" class="headerlink" title="2.GitHub基本概念"></a>2.GitHub基本概念</h2></li>
<li><h5 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h5>仓库用来存放项目代码，每个项目对应一个仓库(Repository)，多个开源项目则有多个仓库（Repositories）。</li>
<li><h5 id="复制克隆项目（fork）"><a href="#复制克隆项目（fork）" class="headerlink" title="复制克隆项目（fork）"></a>复制克隆项目（fork）</h5>完全复制别人的项目到自己的GitHub,丝毫不会影响原有项目的代码与结构。fork的项目是独立存在的！</li>
<li><h5 id="发起请求-Pull-Request"><a href="#发起请求-Pull-Request" class="headerlink" title="发起请求(Pull Request)"></a>发起请求(Pull Request)</h5>发起请求，这个其实是基于Fork的。如果你fork了别人的项目并且在其基础上做了改进，后来觉得改进的很不错，应该要把这些改进让更多的人收益，于是就想把自己的改进合并到原有项目里，这个时候你就可以发起一个PullRequest(简称PR)，原有项目创建人就可以收到这个请求，这个时候你会仔细查看他的代码，并且测试觉得ok了，就会接受他的PR,这个时候他做的改进原有项目就会拥有了。</li>
<li><h5 id="事务卡片-Issue"><a href="#事务卡片-Issue" class="headerlink" title="事务卡片(Issue)"></a>事务卡片(Issue)</h5>发现代码BUG，但是目前没有成型代码，需要讨论时用。</li>
</ol>
<p>举个例子，就是你开源了一个项目，别人发现你的项目中有bug,或者哪些地方做的不够好，他就可以给你提个Issue,即问题，提的问题多了，也就是Issues，然后你.看到了这些问题就可以去逐个修复，修复ok了就可以一个个的Close掉。</p>
<h2 id="3-GitHub上创建仓库"><a href="#3-GitHub上创建仓库" class="headerlink" title="3.GitHub上创建仓库"></a>3.GitHub上创建仓库</h2><p>一个git库（仓库）对应一个开源项目</p>
<p>通过git管理git库</p>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/3.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/4.png" class="">
<h2 id="4-GitHub上管理仓库"><a href="#4-GitHub上管理仓库" class="headerlink" title="4.GitHub上管理仓库"></a>4.GitHub上管理仓库</h2><ol>
<li><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/5.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/6.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/7.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/8.png" class=""></li>
<li><h5 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h5><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/9.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/10.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/11.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/12.png" class=""></li>
<li><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5>可在commits按钮查看删除信息<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/9.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/13.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/14.png" class="">
<h2 id="5-在本地使用Git"><a href="#5-在本地使用Git" class="headerlink" title="5.在本地使用Git"></a>5.在本地使用Git</h2><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/15.png" class="">
工作流程：</li>
<li>从远程仓库中克隆 Git 资源作为本地仓库。</li>
<li>从本地仓库中checkout代码然后进行代码修改</li>
<li>在提交前先将代码提交到暂存区。</li>
<li>提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。</li>
<li>在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。</li>
</ol>
<p>下图展示了 Git 的工作流程：</p>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/2.png" class="">
<h5 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Programmingmakesmebald&quot; #名称</span><br><span class="line">git config --global user.email &quot;1731082812@qq.com&quot;   #邮箱</span><br></pre></td></tr></table></figure>
<h5 id="SSH设置"><a href="#SSH设置" class="headerlink" title="SSH设置"></a>SSH设置</h5><p>现在本地生成ssh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 1701082812@qq.com</span><br></pre></td></tr></table></figure>
<p> 一直回车</p>
<p>GitHub上配置：<br>①github②settings③SSH and …④New SSH⑤ title任意⑥key中输入 刚才在本地生成的ssh（<br>将本地刚才生成的id_rsa.pub内容复制到远程的Key中）</p>
<p>测试连通性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果本地和远程成功通信，则可以在 /.ssh目录中 发现known_hosts文件如果失败：多尝试几次、检查回车符</p>
<h5 id="本地仓库初始化代码"><a href="#本地仓库初始化代码" class="headerlink" title="本地仓库初始化代码"></a>本地仓库初始化代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h5 id="在远程建立git项目"><a href="#在远程建立git项目" class="headerlink" title="在远程建立git项目"></a>在远程建立git项目</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①new②建立项目③ 生成  https:&#x2F;&#x2F;github.com&#x2F;Programmingmakesmebald&#x2F;First-GitHub.git</span><br></pre></td></tr></table></figure>

<h5 id="本地项目-远程项目关联"><a href="#本地项目-远程项目关联" class="headerlink" title="本地项目-远程项目关联"></a>本地项目-远程项目关联</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:yanqun&#x2F;mygitremote.git</span><br></pre></td></tr></table></figure>

<h5 id="工作区域（上传文件到Github）"><a href="#工作区域（上传文件到Github）" class="headerlink" title="工作区域（上传文件到Github）"></a>工作区域（上传文件到Github）</h5><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看工作区状态：git status</span><br><span class="line">添加到暂存区  ：git add 文件名.后缀名</span><br><span class="line">提交到本地仓库：git commit -m “提交描述”</span><br><span class="line">上传到远程仓库：git push</span><br></pre></td></tr></table></figure>
<p>第一次发布项目（本地-远程）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .    &#x2F;&#x2F;文件-暂存区.&quot;代表当前目录所有文件</span><br><span class="line">git commit -m “提交描述” &#x2F;&#x2F;暂存区在本地分支（默认master）</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>第一次下载项目（远程-本地）</p>
<p>下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Programmingmakesmebald&#x2F;First-GitHub.git</span><br></pre></td></tr></table></figure>
<p>提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “提交到分支描述”</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>更新（远程-本地）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/16.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/17.png" class="">
<h2 id="6-问题"><a href="#6-问题" class="headerlink" title="6.问题"></a>6.问题</h2><ol>
<li><h5 id="上传时要输入账号密码（私有项目，没有权限）"><a href="#上传时要输入账号密码（私有项目，没有权限）" class="headerlink" title="上传时要输入账号密码（私有项目，没有权限）"></a>上传时要输入账号密码（私有项目，没有权限）</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①在 .git文件 里面找到config 打开</span><br></pre></td></tr></table></figure>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/18.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/19.png" class="">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">②将 [remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;仓库名.git</span><br><span class="line">改为</span><br><span class="line">[remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;用户名:密码@github.com&#x2F;用户名&#x2F;仓库名.git</span><br><span class="line">列</span><br><span class="line">[remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;Rodma1:chenyun123@github.com&#x2F;Rodma1&#x2F;test.git</span><br><span class="line">保存就解决了</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="上传错误-（git-push）"><a href="#上传错误-（git-push）" class="headerlink" title="上传错误 （git push）"></a>上传错误 （git push）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：git pull --rebase origin master</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Git GitHub</category>
      </categories>
      <tags>
        <tag>Git GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>08.Java基础知识-程序流程控制</title>
    <url>/2020/07/10/08-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h2><ul>
<li><p>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。</p>
</li>
<li><p>其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：</p>
<ul>
<li>顺序结构</li>
<li>分支结构</li>
<li>循环结构<h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4></li>
</ul>
</li>
<li><p>程序从上到下逐行地执行，中间没有任何判断和跳转。<br><img src="http://qd1ql2976.bkt.clouddn.com/3002" alt=""></p>
</li>
<li><p>Java中定义成员变量时采用合法的前向引用。如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正确形式：</span><br><span class="line">public class Test&#123;</span><br><span class="line">    int num1 &#x3D; 12;</span><br><span class="line">    int num2 &#x3D; num1 + 2;</span><br><span class="line">&#125;</span><br><span class="line">错误形式：</span><br><span class="line">public class Test&#123;</span><br><span class="line">    int num2 &#x3D; num1 + 2；</span><br><span class="line">    int num1 &#x3D; 12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>根据条件，选择性地执行某段代码。</p>
<ul>
<li><h5 id="if…else语句。"><a href="#if…else语句。" class="headerlink" title="if…else语句。"></a>if…else语句。</h5><ul>
<li>条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量</li>
<li>语句块只有一条执行语句时，一对{}可以省略，但建议保留</li>
<li>if-else语句结构，根据需要可以嵌套使用</li>
<li>当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略</li>
<li>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓</li>
<li>当多个条件是“包含”关系时，“小上大下 / 子上父下”</li>
<li>三种格式：</li>
</ul>
<p>  1.<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3004" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if( 条件表达式)&#123;</span><br><span class="line">    执行代码块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  2.<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3006" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if( 条件表达式)&#123;</span><br><span class="line">    执行代码块1;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    执行代码块2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  3.<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3008" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if( 条件表达式1)&#123;</span><br><span class="line">    执行 代码块1;</span><br><span class="line">&#125;</span><br><span class="line">else if ( 条件表达式2)&#123;</span><br><span class="line">    执行 代码块2;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">else&#123;</span><br><span class="line">    执行 代码块n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>彩票游戏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">假设你想开发一个玩彩票的游戏，程序随机地产生一个两位数的彩票，提示用户输入一个两位数，然后按照下面的规则判定用户是否能赢。</span><br><span class="line">1)如果用户输入的数匹配彩票的实际顺序，奖金10 000美元。</span><br><span class="line">2)如果用户输入的所有数字匹配彩票的所有数字，但顺序不一致，奖金 3 000美元。</span><br><span class="line">3)如果用户输入的一个数字仅满足顺序情况下匹配彩票的一个数字，奖金1 000美元。</span><br><span class="line">4)如果用户输入的一个数字仅满足非顺序情况下匹配彩票的一个数字，奖金500美元。</span><br><span class="line">5)如果用户输入的数字没有匹配任何一个数字，则彩票作废。</span><br><span class="line">提示：使用Math.random()产生随机数Math.random() 产生[0,1)范围的随机值Math.random() * 90：[0,90) </span><br><span class="line">Math.random() * 90 + 10：[10,100) 即得到  [10,99]</span><br><span class="line"></span><br><span class="line">使用(int)(Math.random() * 90  + 10)产生一个两位数的随机数。</span><br><span class="line">*&#x2F;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class TestCaiPiao&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		&#x2F;&#x2F;1、随机产生一个两位数</span><br><span class="line">		&#x2F;&#x2F;System.out.println(Math.random());&#x2F;&#x2F;产生[0,1)</span><br><span class="line">		int number &#x3D; (int)(Math.random()*90 + 10);&#x2F;&#x2F;得到[10,99]，即[10,100)</span><br><span class="line">		&#x2F;&#x2F;System.out.println(number);</span><br><span class="line">		</span><br><span class="line">		int numberShi &#x3D; number&#x2F;10;</span><br><span class="line">		int numberGe &#x3D; number%10;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2、用户输入一个两位数</span><br><span class="line">		Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">		System.out.print(&quot;请输入一个两位数：&quot;);</span><br><span class="line">		int guess &#x3D; input.nextInt();</span><br><span class="line">		</span><br><span class="line">		int guessShi &#x3D; guess&#x2F;10;</span><br><span class="line">		int guessGe &#x3D; guess%10;</span><br><span class="line">		</span><br><span class="line">		if(number &#x3D;&#x3D; guess)&#123;</span><br><span class="line">			System.out.println(&quot;奖金10 000美元&quot;);</span><br><span class="line">		&#125;else if(numberShi &#x3D;&#x3D; guessGe &amp;&amp; numberGe &#x3D;&#x3D; guessShi)&#123;</span><br><span class="line">			System.out.println(&quot;奖金3 000美元&quot;);</span><br><span class="line">		&#125;else if(numberShi&#x3D;&#x3D;guessShi || numberGe &#x3D;&#x3D; guessGe)&#123;</span><br><span class="line">			System.out.println(&quot;奖金1 000美元&quot;);</span><br><span class="line">		&#125;else if(numberShi&#x3D;&#x3D;guessGe || numberGe &#x3D;&#x3D; guessShi)&#123;</span><br><span class="line">			System.out.println(&quot;奖金500美元&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;没中奖&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;中奖号码是：&quot; + number);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><h5 id="switch-case语句。"><a href="#switch-case语句。" class="headerlink" title="switch-case语句。"></a>switch-case语句。</h5><ul>
<li><p>switch(表达式)中表达式的值必须是下述几种类型之一：byte ，short，char ，int，枚举 (jdk 5.0) ，String (jdk 7.0)；</p>
</li>
<li><p>case子句中的值必须是常量，不能是变量名或不确定的表达式值；</p>
</li>
<li><p>同一个switch语句，所有case子句中的常量值互不相同；</p>
</li>
<li><p>break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有break，程序会顺序执行到switch结尾</p>
</li>
<li><p>default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时，执行default</p>
</li>
<li><p>格式:<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3010" alt=""></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch( 表达式)&#123;</span><br><span class="line">    case 常量1:</span><br><span class="line">    语句1;</span><br><span class="line">    &#x2F;&#x2F; break;</span><br><span class="line">    case 常量2:</span><br><span class="line">    语句2;</span><br><span class="line">    &#x2F;&#x2F; break;</span><br><span class="line">    … …</span><br><span class="line">    case 常量N:</span><br><span class="line">    语句N;</span><br><span class="line">    &#x2F;&#x2F; break;</span><br><span class="line">    default:</span><br><span class="line">    语句;</span><br><span class="line">    &#x2F;&#x2F; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>求输入的日期是当年的第几天</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">class TestDaysOfYear&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;年：&quot;);</span><br><span class="line">		int year &#x3D; input.nextInt();</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;月：&quot;);</span><br><span class="line">		int month &#x3D; input.nextInt();</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;日：&quot;);</span><br><span class="line">		int day &#x3D; input.nextInt();</span><br><span class="line">		</span><br><span class="line">		int days &#x3D; day;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;加前面几个月的满月天数</span><br><span class="line">		switch(month)&#123;</span><br><span class="line">			case 12:</span><br><span class="line">				&#x2F;&#x2F;前面11个月的总天数</span><br><span class="line">				&#x2F;&#x2F;days +&#x3D; 第11月的天数;</span><br><span class="line">				days +&#x3D; 30;</span><br><span class="line">			case 11:</span><br><span class="line">				&#x2F;&#x2F;前面10个月的总天数</span><br><span class="line">				&#x2F;&#x2F;days +&#x3D; 第10月的天数;</span><br><span class="line">				days +&#x3D; 31;</span><br><span class="line">			case 10:</span><br><span class="line">				days +&#x3D; 30;&#x2F;&#x2F;九月</span><br><span class="line">			case 9:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;八月</span><br><span class="line">			case 8:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;七月</span><br><span class="line">			case 7:</span><br><span class="line">				days +&#x3D; 30;&#x2F;&#x2F;六月</span><br><span class="line">			case 6:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;五月</span><br><span class="line">			case 5:</span><br><span class="line">				days +&#x3D; 30;&#x2F;&#x2F;四月</span><br><span class="line">			case 4:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;三月</span><br><span class="line">			case 3:</span><br><span class="line">				days +&#x3D; 28;&#x2F;&#x2F;二月</span><br><span class="line">				&#x2F;*if(闰年)&#123;</span><br><span class="line">					days++;</span><br><span class="line">				&#125;</span><br><span class="line">				*&#x2F;</span><br><span class="line">				if(year % 4 &#x3D;&#x3D;0 &amp;&amp; year % 100 !&#x3D; 0 || year%400&#x3D;&#x3D;0)&#123;</span><br><span class="line">					days++;</span><br><span class="line">				&#125;</span><br><span class="line">			case 2:</span><br><span class="line">				days +&#x3D; 31;&#x2F;&#x2F;一月</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日是这一年的第&quot; + days + &quot;天&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="switch-和if语句的对比"><a href="#switch-和if语句的对比" class="headerlink" title="switch 和if语句的对比"></a>switch 和if语句的对比</h5><p>if和switch语句很像，具体什么场景下，应用哪个语句呢？</p>
</li>
<li><p>如果判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几种类型。虽然两个语句都可以使用，建议使用swtich语句。因为效率稍高。</p>
</li>
<li><p>其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。也就是说，使用switch-case的，都可以改写为if-else。反之不成立。</p>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4></li>
<li><p>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。</p>
</li>
<li><h5 id="循环结构-1"><a href="#循环结构-1" class="headerlink" title="循环结构"></a>循环结构</h5><ul>
<li>根据循环条件，重复性的执行某段代码。</li>
</ul>
</li>
<li><h5 id="循环语句分类"><a href="#循环语句分类" class="headerlink" title="循环语句分类"></a>循环语句分类</h5><ul>
<li>while</li>
<li>do…while</li>
<li>for</li>
</ul>
</li>
<li><h5 id="循环语句的四个组成部分"><a href="#循环语句的四个组成部分" class="headerlink" title="循环语句的四个组成部分"></a>循环语句的四个组成部分</h5><ul>
<li>初始化部分(init_statement)</li>
<li>循环条件部分(test_exp)</li>
<li>循环体部分(body_statement)</li>
<li>迭代部分(alter_statement)<br><img src="http://qd1ql2976.bkt.clouddn.com/3108" alt=""></li>
</ul>
</li>
<li><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><ul>
<li><p>语法格式</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (①初始化部分;②循环条件部分;④迭代部分)｛</span><br><span class="line">    ③ 循环体部分;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></li>
<li><p>执行过程：</p>
<p>  <img src="http://qd1ql2976.bkt.clouddn.com/3110" alt=""></p>
</li>
<li><p>说明：</p>
<ul>
<li>②循环条件部分为boolean类型表达式，当值为false时，退出循环</li>
<li>①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</li>
<li>④可以有多个变量更新，用逗号分隔</li>
</ul>
</li>
<li><p>for循环执行演示：<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3112" alt=""></p>
</li>
<li><p>输入两个正整数m和n，求其最大公约数和最小公倍数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int m &#x3D; 12, n &#x3D; 28;</span><br><span class="line">&#x2F;&#x2F;获取m和n的较大值</span><br><span class="line">int max &#x3D; (m &gt; n)? m : n;</span><br><span class="line">&#x2F;&#x2F;获取m和n的较小值</span><br><span class="line">int min &#x3D; (m &lt; n)? m : n;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;求m和n的最大公约数</span><br><span class="line">for(int i &#x3D; min;i &gt;&#x3D; 1;i--)&#123;</span><br><span class="line">    if( m % i &#x3D;&#x3D; 0 &amp;&amp; n % i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        System.out.println(&quot;m和n的最大公约数是：&quot; + i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;求m和n的最小公倍数</span><br><span class="line">for(int i &#x3D; max;i &lt;&#x3D; m * n;i++)&#123;</span><br><span class="line">    if( i % m &#x3D;&#x3D; 0 &amp;&amp; i % n &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        System.out.println(&quot;m和n的最小公倍数是：&quot; + i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><ul>
<li><p>语法格式</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">① 初始化部分</span><br><span class="line">while(②循环条件部分)｛</span><br><span class="line">    ③循环体部分;</span><br><span class="line">    ④迭代部分;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行过程：</p>
<p>  <img src="http://qd1ql2976.bkt.clouddn.com/3114" alt=""></p>
</li>
<li><p>说明：</p>
<ul>
<li>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</li>
<li>for循环和while循环可以相互转换<br>区别：for循环和while循环的初始化条件部分的作用范围不同。</li>
</ul>
</li>
<li><p>遍历100以内的所有偶数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;遍历100以内的所有偶数</span><br><span class="line">	int i &#x3D; 1;</span><br><span class="line">	while(i &lt;&#x3D; 100)&#123;</span><br><span class="line">		</span><br><span class="line">		if(i % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;出了while循环以后，i仍可以调用。</span><br><span class="line">	System.out.println(i);&#x2F;&#x2F;101</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h5 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h5><ul>
<li><p>语法格式</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①初始化部分;</span><br><span class="line">do&#123;</span><br><span class="line">    ③ 循环体部分</span><br><span class="line">    ④ 迭代部分</span><br><span class="line">&#125;while(②循环条件部分);</span><br></pre></td></tr></table></figure></li>
<li><p>执行过程：</p>
<p>  <img src="http://qd1ql2976.bkt.clouddn.com/3116" alt=""></p>
</li>
<li><p>说明：</p>
<ul>
<li>do-while 循环至少执行一次循环体 。</li>
<li>开发中，使用for和while更多一些。较少使用do-while</li>
</ul>
</li>
<li><p>遍历100以内的偶数,并计算所有偶数的和及偶数的个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;遍历100以内的偶数,并计算所有偶数的和及偶数的个数</span><br><span class="line">	int num &#x3D; 1;</span><br><span class="line">	int sum &#x3D; 0;&#x2F;&#x2F;记录总和</span><br><span class="line">	int count &#x3D; 0;&#x2F;&#x2F;记录个数</span><br><span class="line">	do&#123;</span><br><span class="line">		</span><br><span class="line">		if(num % 2 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			System.out.println(num);</span><br><span class="line">			sum +&#x3D; num;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">	&#125;while(num &lt;&#x3D; 100);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;总和为：&quot; + sum);</span><br><span class="line">	System.out.println(&quot;个数为：&quot; + count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h5 id="“无限”循环："><a href="#“无限”循环：" class="headerlink" title="“无限”循环："></a>“无限”循环：</h5><ul>
<li><p>最简单“无限”循环：格式： while(true)、for(;;)  无限循环存在的原因是并不知道循环多少次，需要根据循环体内部某些条件，来控制循环的结束。</p>
</li>
<li><p>结束循环有几种方式？</p>
<ol>
<li>方式一：循环条件部分返回false</li>
<li>方式二：在循环体中，执行break</li>
</ol>
</li>
<li><p>题目：<br>从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。</p>
</li>
<li><p>说明：</p>
<ol>
<li>不在循环条件部分限制次数的结构：for(;;) 或 while(true)</li>
</ol>
</li>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">	</span><br><span class="line">	int positiveNumber &#x3D; 0;&#x2F;&#x2F;记录正数的个数</span><br><span class="line">	int negativeNumber &#x3D; 0;&#x2F;&#x2F;记录负数的个数</span><br><span class="line"></span><br><span class="line">	for(;;)&#123;&#x2F;&#x2F;while(true)&#123;</span><br><span class="line">		</span><br><span class="line">		int number &#x3D; scan.nextInt();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;判断number的正负情况</span><br><span class="line">		if(number &gt; 0)&#123;</span><br><span class="line">			positiveNumber++;</span><br><span class="line">		&#125;else if(number &lt; 0)&#123;</span><br><span class="line">			negativeNumber++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;一旦执行break，跳出循环</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(&quot;输入的正数个数为：&quot; + positiveNumber);</span><br><span class="line">	System.out.println(&quot;输入的负数个数为：&quot; + negativeNumber);</span><br><span class="line">	</span><br><span class="line">	while(true)&#123;</span><br><span class="line">		</span><br><span class="line">		int number &#x3D; scan.nextInt();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;判断number的正负情况</span><br><span class="line">		if(number &gt; 0)&#123;</span><br><span class="line">			positiveNumber++;</span><br><span class="line">		&#125;else if(number &lt; 0)&#123;</span><br><span class="line">			negativeNumber++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;一旦执行break，跳出循环</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;输入的正数个数为：&quot; + positiveNumber);</span><br><span class="line">	System.out.println(&quot;输入的负数个数为：&quot; + negativeNumber);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4></li>
</ul>
</li>
<li><p>将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do…while均可以作为外层循环或内层循环。</p>
</li>
<li><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。</p>
</li>
<li><p>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次。</p>
</li>
<li><p>九九乘法表</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; 9;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		for(int j &#x3D; 1;j &lt;&#x3D; i;j++)&#123;</span><br><span class="line">			System.out.print(i + &quot; * &quot; + j + &quot; &#x3D; &quot; + (i * j) + &quot;  &quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="特殊关键字的使用：break、continue"><a href="#特殊关键字的使用：break、continue" class="headerlink" title="特殊关键字的使用：break、continue"></a>特殊关键字的使用：break、continue</h4><table>
<thead>
<tr>
<th>关键字</th>
<th>使用范围</th>
<th>循环中使用的作用(不同点)</th>
<th>相同点</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>switch-case与循环结构中</td>
<td>结束当前循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
<tr>
<td>continue</td>
<td>循环结构中</td>
<td>结束当次循环</td>
<td>关键字后面不能声明执行语句</td>
</tr>
</tbody></table>
<ul>
<li><h5 id="break"><a href="#break" class="headerlink" title="break"></a>break</h5></li>
<li><p>break语句用于终止某个语句块的执行</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    break;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是<br>哪一层语句块</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label1: &#123; </span><br><span class="line">    ……</span><br><span class="line">    label2: &#123; </span><br><span class="line">        ……</span><br><span class="line">        label3: &#123; </span><br><span class="line">            ……</span><br><span class="line">            break label2;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h5></li>
<li><p>continue 语句</p>
<ul>
<li>continue只能使用在循环结构中</li>
<li>continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环</li>
<li>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</li>
</ul>
</li>
<li><p>continue 语句用法举例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">        if (i%10&#x3D;&#x3D;0)</span><br><span class="line">        continue;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="return-特殊的流程控制语句"><a href="#return-特殊的流程控制语句" class="headerlink" title="return 特殊的流程控制语句"></a>return 特殊的流程控制语句</h5></li>
<li><p>return：并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个return语句时，这个方法将被结束。</p>
</li>
<li><p>与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内</p>
</li>
<li><h5 id="特殊流程控制语句说明"><a href="#特殊流程控制语句说明" class="headerlink" title="特殊流程控制语句说明"></a>特殊流程控制语句说明</h5><ul>
<li>break只能用于switch语句和循环语句中。</li>
<li>continue只能用于循环语句中。</li>
<li>二者功能类似，但continue是终止本次循环，break是终止本层循环。</li>
<li>break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。</li>
<li>标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。</li>
<li>很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同于goto的。</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">	for(int i &#x3D; 1;i &lt;&#x3D; 10;i++)&#123;</span><br><span class="line">	</span><br><span class="line">		if(i % 4 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			break;&#x2F;&#x2F;123</span><br><span class="line">			&#x2F;&#x2F;continue;&#x2F;&#x2F;123567910</span><br><span class="line">			&#x2F;&#x2F;System.out.println(&quot;今晚迪丽热巴要约我！！！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;\n&quot;);</span><br><span class="line">	&#x2F;&#x2F;******************************</span><br><span class="line">	</span><br><span class="line">	label:for(int i &#x3D; 1;i &lt;&#x3D; 4;i++)&#123;</span><br><span class="line">	</span><br><span class="line">		for(int j &#x3D; 1;j &lt;&#x3D; 10;j++)&#123;</span><br><span class="line">			</span><br><span class="line">			if(j % 4 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">				&#x2F;&#x2F;break;&#x2F;&#x2F;默认跳出包裹此关键字最近的一层循环。</span><br><span class="line">				&#x2F;&#x2F;continue;</span><br><span class="line"></span><br><span class="line">				&#x2F;&#x2F;break label;&#x2F;&#x2F;结束指定标识的一层循环结构</span><br><span class="line">				continue label;&#x2F;&#x2F;结束指定标识的一层循环结构当次循环</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.print(j);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>程序流程控制</tag>
        <tag>顺序结构</tag>
        <tag>分支结构</tag>
        <tag>循环结构</tag>
        <tag>if…else</tag>
        <tag>彩票游戏</tag>
        <tag>switch-case</tag>
        <tag>switch 和if语句的对比</tag>
        <tag>while</tag>
        <tag>do…while</tag>
        <tag>for</tag>
        <tag>“无限”循环</tag>
        <tag>嵌套循环</tag>
        <tag>break</tag>
        <tag>continue</tag>
        <tag>return</tag>
      </tags>
  </entry>
  <entry>
    <title>07.Java基础知识-运算符</title>
    <url>/2020/07/06/07-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p>
<h2 id="一、算术运算符"><a href="#一、算术运算符" class="headerlink" title="一、算术运算符"></a>一、算术运算符</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2792" alt=""><br>算术运算符的注意问题</p>
<ul>
<li>如果对负数取模，可以把模数负号忽略不记，如：5%-2=1。 但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。</li>
<li>对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。 例如：int x=3510;x=x/1000*1000; x的结果是？</li>
<li>“+”除字符串相加功能外，还能把非字符串转换成字符串.例如：System.out.println(“5+5=”+5+5);//打印结果是？ 5+5=55 ?</li>
<li>示例  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之一：算术运算符</span><br><span class="line">+ - + - * &#x2F; % (前)++ (后)++ (前)-- (后)-- +</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">class AriTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;除号：&#x2F;</span><br><span class="line">		int num1 &#x3D; 12;</span><br><span class="line">		int num2 &#x3D; 5;</span><br><span class="line">		int result1 &#x3D; num1 &#x2F; num2;</span><br><span class="line">		System.out.println(result1);&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">		int result2 &#x3D; num1 &#x2F; num2 * num2;</span><br><span class="line">		System.out.println(result2);&#x2F;&#x2F;10</span><br><span class="line"></span><br><span class="line">		double result3 &#x3D; num1 &#x2F; num2;</span><br><span class="line">		System.out.println(result3);&#x2F;&#x2F;2.0</span><br><span class="line"></span><br><span class="line">		double result4 &#x3D; num1 &#x2F; num2 + 0.0;&#x2F;&#x2F;2.0</span><br><span class="line">		double result5 &#x3D; num1 &#x2F; (num2 + 0.0);&#x2F;&#x2F;2.4</span><br><span class="line">		double result6 &#x3D; (double)num1 &#x2F; num2;&#x2F;&#x2F;2.4</span><br><span class="line">		double result7 &#x3D; (double)(num1 &#x2F; num2);&#x2F;&#x2F;2.0</span><br><span class="line">		System.out.println(result5);</span><br><span class="line">		System.out.println(result6);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; %:取余运算</span><br><span class="line">		&#x2F;&#x2F;结果的符号与被模数的符号相同</span><br><span class="line">		&#x2F;&#x2F;开发中，经常使用%来判断能否被除尽的情况。</span><br><span class="line">		int m1 &#x3D; 12;</span><br><span class="line">		int n1 &#x3D; 5;</span><br><span class="line">		System.out.println(&quot;m1 % n1 &#x3D; &quot; + m1 % n1);</span><br><span class="line"></span><br><span class="line">		int m2 &#x3D; -12;</span><br><span class="line">		int n2 &#x3D; 5;</span><br><span class="line">		System.out.println(&quot;m2 % n2 &#x3D; &quot; + m2 % n2);</span><br><span class="line"></span><br><span class="line">		int m3 &#x3D; 12;</span><br><span class="line">		int n3 &#x3D; -5;</span><br><span class="line">		System.out.println(&quot;m3 % n3 &#x3D; &quot; + m3 % n3);</span><br><span class="line"></span><br><span class="line">		int m4 &#x3D; -12;</span><br><span class="line">		int n4 &#x3D; -5;</span><br><span class="line">		System.out.println(&quot;m4 % n4 &#x3D; &quot; + m4 % n4);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;(前)++ :先自增1，后运算</span><br><span class="line">		&#x2F;&#x2F;(后)++ :先运算，后自增1</span><br><span class="line">		int a1 &#x3D; 10;</span><br><span class="line">		int b1 &#x3D; ++a1;</span><br><span class="line">		System.out.println(&quot;a1 &#x3D; &quot; + a1 + &quot;,b1 &#x3D; &quot; + b1);</span><br><span class="line">		</span><br><span class="line">		int a2 &#x3D; 10;</span><br><span class="line">		int b2 &#x3D; a2++;</span><br><span class="line">		System.out.println(&quot;a2 &#x3D; &quot; + a2 + &quot;,b2 &#x3D; &quot; + b2);</span><br><span class="line">		</span><br><span class="line">		int a3 &#x3D; 10;</span><br><span class="line">		++a3;&#x2F;&#x2F;a3++;</span><br><span class="line">		int b3 &#x3D; a3;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;注意点：</span><br><span class="line">		short s1 &#x3D; 10;</span><br><span class="line">		&#x2F;&#x2F;s1 &#x3D; s1 + 1;&#x2F;&#x2F;编译失败</span><br><span class="line">		&#x2F;&#x2F;s1 &#x3D; (short)(s1 + 1);&#x2F;&#x2F;正确的</span><br><span class="line">		s1++;&#x2F;&#x2F;自增1不会改变本身变量的数据类型</span><br><span class="line">		System.out.println(s1);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;问题：</span><br><span class="line">		byte bb1 &#x3D;127;</span><br><span class="line">		bb1++;</span><br><span class="line">		System.out.println(&quot;bb1 &#x3D; &quot; + bb1);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;(前)-- :先自减1，后运算</span><br><span class="line">		&#x2F;&#x2F;(后)-- :先运算，后自减1</span><br><span class="line">		</span><br><span class="line">		int a4 &#x3D; 10;</span><br><span class="line">		int b4 &#x3D; a4--;&#x2F;&#x2F;int b4 &#x3D; --a4;</span><br><span class="line">		System.out.println(&quot;a4 &#x3D; &quot; + a4 + &quot;,b4 &#x3D; &quot; + b4);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二、赋值运算符"><a href="#二、赋值运算符" class="headerlink" title="二、赋值运算符"></a>二、赋值运算符</h2><ul>
<li>符号：=<ul>
<li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。</li>
<li>支持连续赋值。</li>
</ul>
</li>
<li>扩展赋值运算符： +=, -=, *=, /=, %=</li>
<li>示例  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之二：赋值运算符</span><br><span class="line">&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;  &#x2F;&#x3D;  %&#x3D; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">class SetValueTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;赋值符号：&#x3D;</span><br><span class="line">		int i1 &#x3D; 10;</span><br><span class="line">		int j1 &#x3D; 10;</span><br><span class="line"></span><br><span class="line">		int i2,j2;</span><br><span class="line">		&#x2F;&#x2F;连续赋值</span><br><span class="line">		i2 &#x3D; j2 &#x3D; 10;</span><br><span class="line"></span><br><span class="line">		int i3 &#x3D; 10,j3 &#x3D; 20;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;*********************</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		num1 +&#x3D; 2;&#x2F;&#x2F;num1 &#x3D; num1 + 2;</span><br><span class="line">		System.out.println(num1);&#x2F;&#x2F;12</span><br><span class="line"></span><br><span class="line">		int num2 &#x3D; 12;</span><br><span class="line">		num2 %&#x3D; 5;&#x2F;&#x2F;num2 &#x3D; num2 % 5;</span><br><span class="line">		System.out.println(num2);</span><br><span class="line"></span><br><span class="line">		short s1 &#x3D; 10;</span><br><span class="line">		&#x2F;&#x2F;s1 &#x3D; s1 + 2;&#x2F;&#x2F;编译失败</span><br><span class="line">		s1 +&#x3D; 2;&#x2F;&#x2F;结论：不会改变变量本身的数据类型</span><br><span class="line">		System.out.println(s1);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num &#x3D; 10;)</span><br><span class="line">		&#x2F;&#x2F;方式一：num &#x3D; num + 2;</span><br><span class="line">		&#x2F;&#x2F;方式二：num +&#x3D; 2; (推荐)</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num &#x3D; 10;)</span><br><span class="line">		&#x2F;&#x2F;方式一：num &#x3D; num + 1;</span><br><span class="line">		&#x2F;&#x2F;方式二：num +&#x3D; 1; </span><br><span class="line">		&#x2F;&#x2F;方式三：num++; (推荐)</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;练习1</span><br><span class="line">		int i &#x3D; 1;</span><br><span class="line">		i *&#x3D; 0.1;</span><br><span class="line">		System.out.println(i);&#x2F;&#x2F;0</span><br><span class="line">		i++;</span><br><span class="line">		System.out.println(i);&#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;练习2</span><br><span class="line">		int m &#x3D; 2;</span><br><span class="line">		int n &#x3D; 3;</span><br><span class="line">		n *&#x3D; m++; &#x2F;&#x2F;n &#x3D; n * m++;	</span><br><span class="line">		System.out.println(&quot;m&#x3D;&quot; + m);&#x2F;&#x2F;3</span><br><span class="line">		System.out.println(&quot;n&#x3D;&quot; + n);&#x2F;&#x2F;6</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;练习3</span><br><span class="line">		int n1 &#x3D; 10;</span><br><span class="line">		n1 +&#x3D; (n1++) + (++n1);&#x2F;&#x2F;n1 &#x3D; n1 + (n1++) + (++n1);</span><br><span class="line">		System.out.println(n1);&#x2F;&#x2F;32</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="三、比较运算符（关系运算符）"><a href="#三、比较运算符（关系运算符）" class="headerlink" title="三、比较运算符（关系运算符）"></a>三、比较运算符（关系运算符）</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2809" alt=""></p>
<ul>
<li><p>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</p>
</li>
<li><p>比较运算符“==” 不能误写成“=” 。</p>
</li>
<li><p>区分好==和=的区别。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean b1 &#x3D; false;</span><br><span class="line">if(b1&#x3D;&#x3D;true)</span><br><span class="line">System.out.println(&quot;结果为真&quot;);</span><br><span class="line">else</span><br><span class="line">System.out.println(&quot;结果为假&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之三：比较运算符</span><br><span class="line">&#x3D;&#x3D;  !&#x3D;  &gt;  &lt;  &gt;&#x3D; &lt;&#x3D;  instanceof</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">1.比较运算符的结果是boolean类型</span><br><span class="line">2.区分 &#x3D;&#x3D;  和  &#x3D; </span><br><span class="line">*&#x2F;</span><br><span class="line">class CompareTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 10;</span><br><span class="line">		int j &#x3D; 20;</span><br><span class="line"></span><br><span class="line">		System.out.println(i &#x3D;&#x3D; j);&#x2F;&#x2F;false</span><br><span class="line">		System.out.println(i &#x3D; j);&#x2F;&#x2F;20</span><br><span class="line"></span><br><span class="line">		boolean b1 &#x3D; true;</span><br><span class="line">		boolean b2 &#x3D; false;</span><br><span class="line">		System.out.println(b2 &#x3D;&#x3D; b1);&#x2F;&#x2F;false</span><br><span class="line">		System.out.println(b2 &#x3D; b1);&#x2F;&#x2F;true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="四、逻辑运算符"><a href="#四、逻辑运算符" class="headerlink" title="四、逻辑运算符"></a>四、逻辑运算符</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2811" alt=""></p>
<ul>
<li><p>逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。</p>
</li>
<li><p>“&amp;”和“&amp;&amp;”的区别：</p>
<ul>
<li>单&amp;时，左边无论真假，右边都进行运算；</li>
<li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</li>
</ul>
</li>
<li><p>“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</p>
</li>
<li><p>异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。</p>
<ul>
<li>理解：异或，追求的是“异”!</li>
</ul>
</li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之四：逻辑运算符</span><br><span class="line"></span><br><span class="line">&amp;  &amp;&amp; |  || ! ^</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">1.逻辑运算符操作的都是boolean类型的变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">class LogicTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;区分&amp; 与 &amp;&amp;</span><br><span class="line">		&#x2F;&#x2F;相同点1：&amp; 与  &amp;&amp; 的运算结果相同</span><br><span class="line">		&#x2F;&#x2F;相同点2：当符号左边是true时，二者都会执行符号右边的运算</span><br><span class="line">		&#x2F;&#x2F;不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</span><br><span class="line">		&#x2F;&#x2F;开发中，推荐使用&amp;&amp;</span><br><span class="line">		boolean b1 &#x3D; true;</span><br><span class="line">		b1 &#x3D; false;</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		if(b1 &amp; (num1++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;num1 &#x3D; &quot; + num1);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		boolean b2 &#x3D; true;</span><br><span class="line">		b2 &#x3D; false;</span><br><span class="line">		int num2 &#x3D; 10;</span><br><span class="line">		if(b2 &amp;&amp; (num2++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;num2 &#x3D; &quot; + num2);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 区分：| 与 || </span><br><span class="line">		&#x2F;&#x2F;相同点1：| 与  || 的运算结果相同</span><br><span class="line">		&#x2F;&#x2F;相同点2：当符号左边是false时，二者都会执行符号右边的运算</span><br><span class="line">		&#x2F;&#x2F;不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</span><br><span class="line">		&#x2F;&#x2F;开发中，推荐使用||</span><br><span class="line">		boolean b3 &#x3D; false;</span><br><span class="line">		b3 &#x3D; true;</span><br><span class="line">		int num3 &#x3D; 10;</span><br><span class="line">		if(b3 | (num3++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;num3 &#x3D; &quot; + num3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		boolean b4 &#x3D; false;</span><br><span class="line">		b4 &#x3D; true;</span><br><span class="line">		int num4 &#x3D; 10;</span><br><span class="line">		if(b4 || (num4++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;num4 &#x3D; &quot; + num4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="五、位运算符"><a href="#五、位运算符" class="headerlink" title="五、位运算符"></a>五、位运算符</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2813" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2817" alt=""></p>
<ul>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之五：位运算符 （了解）</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">1. 位运算符操作的都是整型的数据</span><br><span class="line">2. &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2</span><br><span class="line">   &gt;&gt; :在一定范围内，每向右移1位，相当于 &#x2F; 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">面试题：最高效方式的计算2 * 8 ？  2 &lt;&lt; 3  或 8 &lt;&lt; 1</span><br><span class="line">*&#x2F;</span><br><span class="line">class BitTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 21;</span><br><span class="line">		i &#x3D; -21;</span><br><span class="line">		System.out.println(&quot;i &lt;&lt; 2 :&quot; + (i &lt;&lt; 2));</span><br><span class="line">		System.out.println(&quot;i &lt;&lt; 3 :&quot; + (i &lt;&lt; 3));</span><br><span class="line">		System.out.println(&quot;i &lt;&lt; 27 :&quot; + (i &lt;&lt; 27));</span><br><span class="line"></span><br><span class="line">		int m &#x3D; 12;</span><br><span class="line">		int n &#x3D; 5;</span><br><span class="line">		System.out.println(&quot;m &amp; n :&quot; + (m &amp; n));</span><br><span class="line">		System.out.println(&quot;m | n :&quot; + (m | n));</span><br><span class="line">		System.out.println(&quot;m ^ n :&quot; + (m ^ n));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;练习：交换两个变量的值</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		int num2 &#x3D; 20;</span><br><span class="line">		System.out.println(&quot;num1 &#x3D; &quot; + num1 + &quot;,num2 &#x3D; &quot; + num2);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方式一：定义临时变量的方式</span><br><span class="line">		&#x2F;&#x2F;推荐的方式</span><br><span class="line">		int temp &#x3D; num1;</span><br><span class="line">		num1 &#x3D; num2;</span><br><span class="line">		num2 &#x3D; temp;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方式二：好处：不用定义临时变量  </span><br><span class="line">		&#x2F;&#x2F;弊端：① 相加操作可能超出存储范围 ② 有局限性：只能适用于数值类型</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 + num2;</span><br><span class="line">		&#x2F;&#x2F;num2 &#x3D; num1 - num2;</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 - num2;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方式三：使用位运算符</span><br><span class="line">		&#x2F;&#x2F;有局限性：只能适用于数值类型</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 ^ num2;</span><br><span class="line">		&#x2F;&#x2F;num2 &#x3D; num1 ^ num2;</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 ^ num2;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;num1 &#x3D; &quot; + num1 + &quot;,num2 &#x3D; &quot; + num2);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图解<br><img src="http://qd1ql2976.bkt.clouddn.com/2815" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2848" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2850" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2852" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2854" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2856" alt=""></p>
</li>
</ul>
<h2 id="六、三元运算符"><a href="#六、三元运算符" class="headerlink" title="六、三元运算符"></a>六、三元运算符</h2><ul>
<li><p>格式:</p>
<ul>
<li>(条件表达式)? 表达式1 ：表达式2；<ul>
<li>条件表达式为true ，运算后的结果是表达式1；</li>
<li>条件表达式为false ，运算后的结果是表达式2；</li>
</ul>
</li>
<li>表达式1和表达式2为同种类型</li>
<li>三元运算符与if-else的联系与区别：<ol>
<li>三元运算符可简化if-else语句</li>
<li>三元运算符要求必须返回一个结果。</li>
<li>if后的代码块可有多个语句</li>
</ol>
</li>
</ul>
</li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之六：三元运算符</span><br><span class="line">1.结构：(条件表达式)? 表达式1 : 表达式2</span><br><span class="line">2. 说明</span><br><span class="line">① 条件表达式的结果为boolean类型</span><br><span class="line">② 根据条件表达式真或假，决定执行表达式1，还是表达式2.</span><br><span class="line">  如果表达式为true，则执行表达式1。</span><br><span class="line">  如果表达式为false，则执行表达式2。</span><br><span class="line">③ 表达式1 和表达式2要求是一致的。</span><br><span class="line">④ 三元运算符可以嵌套使用</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">凡是可以使用三元运算符的地方，都可以改写为if-else</span><br><span class="line">反之，不成立。</span><br><span class="line"></span><br><span class="line">4. 如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。</span><br><span class="line">*&#x2F;</span><br><span class="line">class SanYuanTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;获取两个整数的较大值</span><br><span class="line">		int m &#x3D; 12;</span><br><span class="line">		int n &#x3D; 5;</span><br><span class="line"></span><br><span class="line">		int max &#x3D; (m &gt; n)? m : n;</span><br><span class="line">		System.out.println(max);</span><br><span class="line"></span><br><span class="line">		double num &#x3D; (m &gt; n)? 2 : 1.0;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;(m &gt; n)? 2 : &quot;n大&quot;;&#x2F;&#x2F;编译错误</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;**************************</span><br><span class="line">		n &#x3D; 12;</span><br><span class="line">		String maxStr &#x3D; (m &gt; n)? &quot;m大&quot; : ((m &#x3D;&#x3D; n)? &quot;m和n相等&quot; : &quot;n大&quot;);</span><br><span class="line">		System.out.println(maxStr);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;*****************************</span><br><span class="line">		&#x2F;&#x2F;获取三个数的最大值</span><br><span class="line">		int n1 &#x3D; 12;</span><br><span class="line">		int n2 &#x3D; 30;</span><br><span class="line">		int n3 &#x3D; -43;</span><br><span class="line">		</span><br><span class="line">		int max1 &#x3D; (n1 &gt; n2)? n1 : n2;</span><br><span class="line">		int max2 &#x3D; (max1 &gt; n3)? max1 : n3;</span><br><span class="line">		System.out.println(&quot;三个数中的最大值为：&quot; + max2);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;不建议</span><br><span class="line">		&#x2F;&#x2F;int max3 &#x3D; (((n1 &gt; n2)? n1 : n2) &gt; n3)? ((n1 &gt; n2)? n1 : n2) : n3;</span><br><span class="line">		System.out.println(&quot;三个数中的最大值为：&quot; + max3);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;该写成if-else:</span><br><span class="line">		if(m &gt; n)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、运算符的优先级"><a href="#七、运算符的优先级" class="headerlink" title="七、运算符的优先级"></a>七、运算符的优先级</h2></li>
<li><p>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。</p>
</li>
<li><p>只有单目运算符、三元运算符、赋值运算符是从右向左运算的。<br><img src="http://qd1ql2976.bkt.clouddn.com/2872" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>运算符</tag>
        <tag>算数运算符</tag>
        <tag>赋值运算符</tag>
        <tag>比较运算符</tag>
        <tag>关系运算符</tag>
        <tag>逻辑运算符</tag>
        <tag>位运算符</tag>
        <tag>三目运算符</tag>
        <tag>三元运算符</tag>
        <tag>运算符的优先级</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM文件上传</title>
    <url>/2020/07/01/SSM%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="SSM–文件上传"><a href="#SSM–文件上传" class="headerlink" title="SSM–文件上传"></a>SSM–文件上传</h1><h3 id="1-配置（applicationContext-Controller-xml）"><a href="#1-配置（applicationContext-Controller-xml）" class="headerlink" title="1.配置（applicationContext-Controller.xml）"></a>1.配置（applicationContext-Controller.xml）</h3><p>在SpringMVC中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传的配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 上传单个文件的最大值，单位Byte，-1表示无限制 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"104857600"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-编写控制器（Controller）"><a href="#2-编写控制器（Controller）" class="headerlink" title="2.编写控制器（Controller）"></a>2.编写控制器（Controller）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testUpload"</span>)</span><br><span class="line">    <span class="function">String <span class="title">testUpload</span><span class="params">(@RequestParam(<span class="string">"miaoshu"</span>)</span> String desc,@<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"文件描述信息:%s"</span>,desc));</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        InputStream input = file.getInputStream();</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        OutputStream out=<span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1atupian\\"</span>+fileName);</span><br><span class="line">        <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = input.read(bs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.print(String.format(<span class="string">"上传成功!"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-前台上传框（jsp）"><a href="#3-前台上传框（jsp）" class="headerlink" title="3.前台上传框（jsp）"></a>3.前台上传框（jsp）</h3><p>form表单中需要注意的是上传的方式必须为Post  method=”post”</p>
<p>必须加上enctype=”multipart/form-data”属性   enctype=”multipart/form-data”</p>
<p>get的方式地址栏改变将显示文件的内容，若文件过大时地址栏的大小不能够放下该文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文件上传：</span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"controller/testUpload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">                请选择文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line">                文件的描述：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"miaoshu"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>SSM文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客及使用</title>
    <url>/2020/07/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h3><h5 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;blogname&quot;</span><br></pre></td></tr></table></figure>
<h5 id="2-清除"><a href="#2-清除" class="headerlink" title="2. 清除"></a>2. 清除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<h5 id="3-生成"><a href="#3-生成" class="headerlink" title="3. 生成"></a>3. 生成</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h5 id="4-部署"><a href="#4-部署" class="headerlink" title="4. 部署"></a>4. 部署</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><h5 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1. 安装node.js"></a>1. 安装node.js</h5><h5 id="2-安装淘宝的cnpm-管理器"><a href="#2-安装淘宝的cnpm-管理器" class="headerlink" title="2. 安装淘宝的cnpm 管理器"></a>2. 安装淘宝的cnpm 管理器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h5 id="3-安装hexo框架"><a href="#3-安装hexo框架" class="headerlink" title="3. 安装hexo框架"></a>3. 安装hexo框架</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h5 id="4-生成博客-初始化博客"><a href="#4-生成博客-初始化博客" class="headerlink" title="4. 生成博客 初始化博客"></a>4. 生成博客 初始化博客</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h5 id="5-启动本地博客服务"><a href="#5-启动本地博客服务" class="headerlink" title="5. 启动本地博客服务"></a>5. 启动本地博客服务</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h5 id="6-本地访问地址"><a href="#6-本地访问地址" class="headerlink" title="6. 本地访问地址"></a>6. 本地访问地址</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h5 id="1-新建文章-1"><a href="#1-新建文章-1" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;文章名&quot; &#x2F;&#x2F;new</span><br></pre></td></tr></table></figure>
<h5 id="2-新建页面"><a href="#2-新建页面" class="headerlink" title="2. 新建页面"></a>2. 新建页面</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-本地运行-预览"><a href="#3-本地运行-预览" class="headerlink" title="3. 本地运行(预览)"></a>3. 本地运行(预览)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s &#x2F;&#x2F;sever</span><br></pre></td></tr></table></figure>
<h5 id="4-清除缓存"><a href="#4-清除缓存" class="headerlink" title="4. 清除缓存"></a>4. 清除缓存</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo c &#x2F;&#x2F;clean</span><br></pre></td></tr></table></figure>
<h5 id="5-生成"><a href="#5-生成" class="headerlink" title="5. 生成"></a>5. 生成</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &#x2F;&#x2F;generate</span><br></pre></td></tr></table></figure>

<h5 id="6-部署到github"><a href="#6-部署到github" class="headerlink" title="6. 部署到github"></a>6. 部署到github</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d &#x2F;&#x2F;deploy</span><br></pre></td></tr></table></figure>

<h5 id="7-推送到分支"><a href="#7-推送到分支" class="headerlink" title="7. 推送到分支"></a>7. 推送到分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<h3 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h3><h5 id="1-配置-config-yml"><a href="#1-配置-config-yml" class="headerlink" title="1. 配置_config.yml"></a>1. 配置_config.yml</h5><p><img src="http://qd1ql2976.bkt.clouddn.com/1687" alt=""></p>
<h5 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2.更换主题"></a>2.更换主题</h5><p><img src="http://qd1ql2976.bkt.clouddn.com/1717" alt=""></p>
<h5 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h5><p>解决代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="http://qd1ql2976.bkt.clouddn.com/1700" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/1702" alt=""></p>
<h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><h5 id="hexo主题网站"><a href="#hexo主题网站" class="headerlink" title="hexo主题网站"></a><a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题网站</a></h5><h6 id="进入主题文件"><a href="#进入主题文件" class="headerlink" title="进入主题文件"></a>进入主题文件</h6><p><img src="http://qd1ql2976.bkt.clouddn.com/1713" alt=""></p>
<h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Fechin&#x2F;hexo-theme-diaspora.git</span><br></pre></td></tr></table></figure>
<p><img src="http://qd1ql2976.bkt.clouddn.com/1726" alt=""></p>
]]></content>
      <categories>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
</search>
