<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01.数据结构</title>
    <url>/2020/07/04/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构包括：线性结构和非线性结构。</p>
<ul>
<li><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</li>
<li>线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。</li>
<li>顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。</li>
<li>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</li>
<li>线性结构常见的有：数组、队列、链表和栈。</li>
</ol>
</li>
<li><h4 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h4><ol>
<li>二维数组</li>
<li>多维数组</li>
<li>广义表</li>
<li>树结构</li>
<li>图结构</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>线性结构</tag>
        <tag>非线性结构</tag>
        <tag>顺序存储结构</tag>
        <tag>链式存储结构</tag>
      </tags>
  </entry>
  <entry>
    <title>02.Java基础知识-文档及规范</title>
    <url>/2020/07/03/02-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%96%87%E6%A1%A3%E5%8F%8A%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="一、Java-API文档"><a href="#一、Java-API文档" class="headerlink" title="一、Java API文档"></a>一、Java API文档</h2><ul>
<li>API (Application Programming Interface,应用程序编程接口)是Java提供的基本编程接口。</li>
<li>Java语言提供了大量的基础类，因此Oracle也为这些基础类提供了相应的API文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。</li>
<li>下载API: <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br><img src="http://qd1ql2976.bkt.clouddn.com/2119" alt=""><h2 id="二、良好的编程风格"><a href="#二、良好的编程风格" class="headerlink" title="二、良好的编程风格"></a>二、良好的编程风格</h2></li>
<li><h4 id="正确的注释和注释风格"><a href="#正确的注释和注释风格" class="headerlink" title="正确的注释和注释风格"></a>正确的注释和注释风格</h4><ul>
<li>使用文档注释来注释整个类或整个方法。</li>
<li>如果注释方法中的某一一个步骤，使用单行或多行注释。</li>
</ul>
</li>
<li><h4 id="正确的缩进和空白"><a href="#正确的缩进和空白" class="headerlink" title="正确的缩进和空白"></a>正确的缩进和空白</h4><ul>
<li>使用一次tab操作，实现缩进</li>
<li>运算符两边习惯性各加一一个空格。比如: 2+4* 5。</li>
</ul>
</li>
<li><h4 id="块的风格"><a href="#块的风格" class="headerlink" title="块的风格"></a>块的风格</h4><ul>
<li>JavaAPI源代码选择了行尾风格<br><img src="http://qd1ql2976.bkt.clouddn.com/2135" alt=""><h2 id="三、注释"><a href="#三、注释" class="headerlink" title="三、注释"></a>三、注释</h2></li>
</ul>
</li>
<li>用于注解说明解释程序的文字就是注释。</li>
<li>Java中的注释类型:<ul>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释(java特有)</li>
</ul>
</li>
<li>提高了代码的阅读性;调试程序的重要方法。</li>
<li>注释是一个程序员必须要具有的良好编程习惯。</li>
<li>将自己的思想通过注释先整理出来，再用代码去体现</li>
<li><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式: &#x2F;&#x2F;注释文字</span><br></pre></td></tr></table></figure></li>
<li><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式: &#x2F;*注释文字*&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="注"><a href="#注" class="headerlink" title="注:"></a>注:</h4><ul>
<li>对于单行和多行注释，被注释的文字，不会被JVM (java虚拟机)解释执行。</li>
<li>多行注释里面不允许有多行注释嵌套。</li>
</ul>
</li>
<li><h4 id="文档注释-Java特有"><a href="#文档注释-Java特有" class="headerlink" title="文档注释(Java特有)"></a>文档注释(Java特有)</h4>  格式:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">@author指定java程序的作者</span><br><span class="line">@version指定源文件的版本</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="javadoc解析"><a href="#javadoc解析" class="headerlink" title="javadoc解析"></a>javadoc解析</h4><ul>
<li>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。<br><img src="http://qd1ql2976.bkt.clouddn.com/2176" alt=""><h2 id="四、注释示例"><a href="#四、注释示例" class="headerlink" title="四、注释示例"></a>四、注释示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">1. java规范的三种注释方式：</span><br><span class="line">单行注释</span><br><span class="line">多行注释</span><br><span class="line">文档注释(java特有)</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">单行注释和多行注释的作用：</span><br><span class="line">① 对所写的程序进行解释说明，增强可读性。方便自己，方便别人</span><br><span class="line">② 调试所写的代码</span><br><span class="line"></span><br><span class="line">3. 特点：单行注释和多行注释，注释了的内容不参与编译。</span><br><span class="line">         换句话说，编译以后生成的.class结尾的字节码文件中不包含注释掉的信息</span><br><span class="line"></span><br><span class="line">4. 文档注释的使用：</span><br><span class="line">    注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</span><br><span class="line"></span><br><span class="line">5. 多行注释不可以嵌套使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">文档注释</span><br><span class="line">@author shkstart</span><br><span class="line">@version v1.0</span><br><span class="line">这是我的第一个java程序！非常的开森！</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">public class HelloJava&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	多行注释：</span><br><span class="line">	如下的main方法是程序的入口！</span><br><span class="line">	main的格式是固定的！</span><br><span class="line">	*&#x2F;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	如下的方式是main()，作用：程序的入口。</span><br><span class="line">	*&#x2F;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		&#x2F;&#x2F;单行注释：如下的语句表示输出到控制台</span><br><span class="line">		&#x2F;&#x2F;System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>01.Java语言概述</title>
    <url>/2020/07/03/01-Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一、Java基础知识图解"><a href="#一、Java基础知识图解" class="headerlink" title="一、Java基础知识图解"></a>一、Java基础知识图解</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/1753" alt=""></p>
<h2 id="二、Windows操作cmd"><a href="#二、Windows操作cmd" class="headerlink" title="二、Windows操作cmd"></a>二、Windows操作cmd</h2><h4 id="1-常用DOS命令"><a href="#1-常用DOS命令" class="headerlink" title="1. 常用DOS命令"></a>1. 常用DOS命令</h4><ul>
<li>dir：列出当前目录下的文件及文件夹</li>
<li>md：创建目录</li>
<li>rd：删除目录</li>
<li>d：进入D盘</li>
<li>cd：进入到指定目录</li>
<li>cd..：返回上级目录</li>
<li>cd\：退回到根目录</li>
<li>echo&gt;xxx.xxx：创建xxx.xxx文件</li>
<li>echo xxx &gt;xxx.xxx：创建xxx.xxx文件并写入xxx</li>
<li>echo &gt;xxx.xxx xxx：创建xxx.xxx文件并写入xxx</li>
<li>del：删除文件</li>
<li>exit：退出dos命令行即退出cmd<h4 id="2-常用快捷键"><a href="#2-常用快捷键" class="headerlink" title="2. 常用快捷键"></a>2. 常用快捷键</h4></li>
<li>← →：移动光标</li>
<li>↑ ↓：调阅历史操作命令</li>
<li>Delete Backspace：删除字符<h2 id="三、Java语言"><a href="#三、Java语言" class="headerlink" title="三、Java语言"></a>三、Java语言</h2><h4 id="1-来源"><a href="#1-来源" class="headerlink" title="1. 来源"></a>1. 来源</h4>Java语言是SUN(Stanford University Network,斯坦福大学网络公司) 1995年推出的一门高级编程语言。<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4>Java语言是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序(applet)。applet使用现代的图形用户界面与Web用户进行交互。applet内嵌在HTML代码中。<h4 id="3-现状"><a href="#3-现状" class="headerlink" title="3. 现状"></a>3. 现状</h4>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。<h4 id="4-简史"><a href="#4-简史" class="headerlink" title="4. 简史"></a>4. 简史</h4></li>
<li>1991年Green项目，开发语言最初命名为Oak (橡树)</li>
<li>1994年，开发组意识到Oak非常适合于互联网</li>
<li>1996年，发布JDK 1.0，约8.3万 个网页应用Java技术来制作</li>
<li>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最</li>
<li>1998年，发布JDK 1.2，同年发布企业平台J2EE</li>
<li>1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技 术诞生</li>
<li>2004年，发布里程碑式版本: JDK 1.5，为突出此版本的重要性，更名为JDK 5.0</li>
<li>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE, J2ME -&gt; JavaME</li>
<li>2009年，Oracle公司收购SUN，交易价格74亿美元</li>
<li>2011年，发布JDK 7.0</li>
<li>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本</li>
<li>2017年，发布JDK 9.0，最大限度实现模块化</li>
<li>2018年3月，发布JDK 10.0，版本号也称为18.3</li>
<li>2018年9月，发布JDK 11.0，版本号也称为18.9<h4 id="5-Java语言的诞生"><a href="#5-Java语言的诞生" class="headerlink" title="5. Java语言的诞生"></a>5. Java语言的诞生</h4></li>
<li>java之父James Gosl ing团队在开发”Green”项目时，发现c缺少垃圾回收系统，还有可移植的安全性、分布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。</li>
<li>Java确实是从c语言和C++语言继承了许多成份，甚至可以将Java看成是类c语言发展和衍生的产物。比如Java语言的变量声明，操作符形式，参数传递，流程控制等方面和C语言、C++语言完全相同。但同时，Java是一个纯粹的面向对象的程序设计语言，它继承了C++语言面向对象技术的核心。Java舍弃了c语言中容易引起错误的指针(以引用取代)、运算符重载(operator overloading)、多重继承<br>(以接口取代)等特性，增加了垃圾回收器功能用于回收不再被引用的对象所占据的内存空间。JDK1.5又引入了泛型编程(GenericProgramming)、类型安全的枚举、不定长参数和自动装/拆箱<h4 id="6-Java的主要特性"><a href="#6-Java的主要特性" class="headerlink" title="6. Java的主要特性"></a>6. Java的主要特性</h4></li>
<li><h5 id="Java语言是易学的"><a href="#Java语言是易学的" class="headerlink" title="Java语言是易学的"></a>Java语言是易学的</h5>  Java语言的语法与c语言和C++语言很接近，使得大多数程序员很容易学习和使用Java。</li>
<li><h5 id="Java语言是强制面向对象的"><a href="#Java语言是强制面向对象的" class="headerlink" title="Java语言是强制面向对象的"></a>Java语言是强制面向对象的</h5>  Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制<br>(关键字为implements)。</li>
<li><h5 id="Java语言是分布式的"><a href="#Java语言是分布式的" class="headerlink" title="Java语言是分布式的"></a>Java语言是分布式的</h5>  Java语 言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口(java net) ，它提供了用于网络应用编程的类<br>库，包括URL、URLConnection、 Socket、 ServerSocket等。 Java 的RMI (远程<br>方法激活)机制也是开发分布式应用的重要手段。</li>
<li><h5 id="Java语言是健壮的"><a href="#Java语言是健壮的" class="headerlink" title="Java语言是健壮的"></a>Java语言是健壮的</h5>  Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。</li>
<li><h5 id="Java语言是安全的"><a href="#Java语言是安全的" class="headerlink" title="Java语言是安全的"></a>Java语言是安全的</h5>  Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如:安全防范机制(类ClassLoader)，如分配不同的名字空间以防替代本地的同名类、字节代码检查。</li>
<li><h5 id="Java语言是体系结构中立的"><a href="#Java语言是体系结构中立的" class="headerlink" title="Java语言是体系结构中立的"></a>Java语言是体系结构中立的</h5>  Java程序(后缀为java的文件)在Java平台上被<br>编译为体系结构中立的字节码格式(后缀为class的文件)，然后可以在实现这个</li>
<li><h5 id="Java平台的任何系统中运行"><a href="#Java平台的任何系统中运行" class="headerlink" title="Java平台的任何系统中运行"></a>Java平台的任何系统中运行</h5>  Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统的解释器中运行。</li>
<li><h5 id="Java是性能略高的"><a href="#Java是性能略高的" class="headerlink" title="Java是性能略高的"></a>Java是性能略高的</h5>  与那些解释型的高级脚本语言相比，Java的性能还是较优的。</li>
<li><h5 id="Java语言是原生支持多线程的"><a href="#Java语言是原生支持多线程的" class="headerlink" title="Java语言是原生支持多线程的"></a>Java语言是原生支持多线程的</h5>  在Java语言中，线程是一-种特殊的对象，它必须<br>由Thread类或其子(孙)类来创建。</li>
</ul>
<h4 id="7-Java技术平台"><a href="#7-Java技术平台" class="headerlink" title="7. Java技术平台"></a>7. Java技术平台</h4><ul>
<li><h5 id="Java-SE-Java-Standard-Edition-标准版"><a href="#Java-SE-Java-Standard-Edition-标准版" class="headerlink" title="Java SE(Java Standard Edition)标准版"></a>Java SE(Java Standard Edition)标准版</h5>  支持面向桌面级应用(如Windows’下的应用程序)的Java平台，提供了完整的Java核心API，此版本以前称为J2SE</li>
<li><h5 id="Java-EE-Java-Enterprise-Edition-企业版"><a href="#Java-EE-Java-Enterprise-Edition-企业版" class="headerlink" title="Java EE(Java Enterprise Edition)企业版"></a>Java EE(Java Enterprise Edition)企业版</h5>  是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等 ,主要针对于Web应用程序开发。版本以前称为J2EE<h4 id="8-Java应用领域"><a href="#8-Java应用领域" class="headerlink" title="8.Java应用领域"></a>8.Java应用领域</h4>从Java的应用领域来分，Java语言的应用方向主要表现在以下几个方面:</li>
<li><h5 id="企业级应用"><a href="#企业级应用" class="headerlink" title="企业级应用"></a>企业级应用</h5>  主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</li>
<li><h5 id="Android平台应用"><a href="#Android平台应用" class="headerlink" title="Android平台应用"></a>Android平台应用</h5>  Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实。</li>
<li><h5 id="大数据平台开发"><a href="#大数据平台开发" class="headerlink" title="大数据平台开发"></a>大数据平台开发</h5>  各类框架有Hadoop, spark, storm,flink等，就这类技术生态圈来讲，还有各种中间件如flume, kafka, sqoop等等 ，这些框架以及工具大多数是用Java编写而成，但提供诸如Java, sscala,Python,R等各种语言API供编程。</li>
<li><h5 id="移动领域应用"><a href="#移动领域应用" class="headerlink" title="移动领域应用"></a>移动领域应用</h5>  主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。<h2 id="四、Java语言运行机制及运行过程"><a href="#四、Java语言运行机制及运行过程" class="headerlink" title="四、Java语言运行机制及运行过程"></a>四、Java语言运行机制及运行过程</h2></li>
</ul>
<ol>
<li><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ol>
<li><h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多肽</li>
</ul>
</li>
<li><h5 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h5><ul>
<li>吸收了C/C++语言的优点，但是去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供一个相对安全的内存管理和访问机制</li>
</ul>
</li>
<li><h5 id="跨平台性"><a href="#跨平台性" class="headerlink" title="跨平台性"></a>跨平台性</h5><ul>
<li>跨平台性：通过Java语言编程的应用程序在不同平台上都可以运行。“Write once，Run Anywhere”</li>
<li>原理:只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。<br><img src="http://qd1ql2976.bkt.clouddn.com/2003" alt=""></li>
</ul>
</li>
</ol>
</li>
<li><h4 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h4></li>
</ol>
<ul>
<li>Java虚拟机（Java Virtual Machine）</li>
<li>垃圾收集机制（Garbage Collection）</li>
</ul>
<ol start="3">
<li><h4 id="核心机制——Java虚拟机"><a href="#核心机制——Java虚拟机" class="headerlink" title="核心机制——Java虚拟机"></a>核心机制——Java虚拟机</h4></li>
</ol>
<ul>
<li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。<br><img src="http://qd1ql2976.bkt.clouddn.com/2047" alt=""></li>
<li>对于不同的平台，有不同的虚拟机。</li>
<li>只有某平台提供了对应的java虚拟机，java程序才可在此平台运行</li>
<li>Java虛拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”<br><img src="http://qd1ql2976.bkt.clouddn.com/2049" alt=""></li>
</ul>
<ol start="4">
<li><h4 id="核心机制——垃圾回收"><a href="#核心机制——垃圾回收" class="headerlink" title="核心机制——垃圾回收"></a>核心机制——垃圾回收</h4></li>
</ol>
<ul>
<li><p>不再使用的内存空间应回收一垃圾回收。</p>
<ul>
<li>在C/C++等语言中，由程序员负责回收无用内存。</li>
<li>Java语言消除了程序员回收无用内存空间的责任:它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。</li>
</ul>
</li>
<li><p>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</p>
</li>
<li><p>Java程序还会出现内存泄漏和内存溢出问题吗?会!</p>
<h2 id="五、Java语言的环境搭建"><a href="#五、Java语言的环境搭建" class="headerlink" title="五、Java语言的环境搭建"></a>五、Java语言的环境搭建</h2></li>
<li><h4 id="JDK-Java-Development-Kit-Java开发工具包"><a href="#JDK-Java-Development-Kit-Java开发工具包" class="headerlink" title="JDK(Java Development Kit Java开发工具包)"></a>JDK(Java Development Kit Java开发工具包)</h4><p>  JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。</p>
<h5 id="其中的开发工具"><a href="#其中的开发工具" class="headerlink" title="其中的开发工具:"></a>其中的开发工具:</h5><ul>
<li>译工具(javac.exe)</li>
<li>打包工具(jar.exe)等</li>
</ul>
</li>
<li><h4 id="JRE-Java-Runtime-Environment-Java运-行环境"><a href="#JRE-Java-Runtime-Environment-Java运-行环境" class="headerlink" title="JRE(Java Runtime Environment Java运 行环境)"></a>JRE(Java Runtime Environment Java运 行环境)</h4><p>  包括Java虛拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
</li>
<li><h4 id="JDK、JRE、JVM的关系"><a href="#JDK、JRE、JVM的关系" class="headerlink" title="JDK、JRE、JVM的关系"></a>JDK、JRE、JVM的关系</h4><p>  <img src="http://qd1ql2976.bkt.clouddn.com/2085" alt=""><br>  <img src="http://qd1ql2976.bkt.clouddn.com/2087" alt=""></p>
</li>
<li><h4 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h4><p>  <img src="http://qd1ql2976.bkt.clouddn.com/2095" alt=""><br>  <img src="http://qd1ql2976.bkt.clouddn.com/2097" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>04.Java基础知识-关键字、保留字与标识符</title>
    <url>/2020/07/05/04-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h2><ul>
<li><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul>
<li><strong>定义</strong>：被Java 语言赋予了特殊含义，用做专门用途的字符串（单词）</li>
<li><strong>特点</strong>：关键字中所有字母都为小写</li>
<li><strong>官方地址</strong>： <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a><br><img src="http://qd1ql2976.bkt.clouddn.com/2416" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2419" alt=""></li>
<li><strong>注</strong>：true、false、null虽然不是关键字，但是命名时不可用。</li>
</ul>
</li>
<li><h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><ul>
<li><strong>Java保留字</strong>：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字goto 、const<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2></li>
</ul>
</li>
<li><h4 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h4><ul>
<li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li>
<li><strong>技巧</strong>：凡是自己可以起名字的地方都叫标识符。</li>
</ul>
</li>
<li><h4 id="定义合法标识符规则"><a href="#定义合法标识符规则" class="headerlink" title="定义合法标识符规则"></a>定义合法标识符规则</h4><ul>
<li>由26 个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格</li>
</ul>
</li>
<li><h4 id="Java中的名称命名规范"><a href="#Java中的名称命名规范" class="headerlink" title="Java中的名称命名规范"></a>Java中的名称命名规范</h4><ul>
<li><strong>包名</strong>：多单词组成时所有字母都小写：xxxyyyzzz</li>
<li><strong>类名、接口名</strong>：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
<li><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li>
<li><strong>常量名</strong>：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
</ul>
</li>
<li><strong>注意1</strong>：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</li>
<li><strong>注意2</strong>：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>关键字</tag>
        <tag>保留字</tag>
        <tag>标识符</tag>
      </tags>
  </entry>
  <entry>
    <title>03.数据结构-队列</title>
    <url>/2020/07/05/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列-数组实现"><a href="#队列-数组实现" class="headerlink" title="队列-数组实现"></a>队列-数组实现</h2><ol>
<li><h4 id="队列的一个使用场景"><a href="#队列的一个使用场景" class="headerlink" title="队列的一个使用场景"></a>队列的一个使用场景</h4><p> 银行排队的案例:<br> <img src="http://qd1ql2976.bkt.clouddn.com/2346" alt=""></p>
</li>
<li><h4 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h4><ol>
<li>队列是一个 有序列表，可以用 数组或是链表来实现。</li>
<li>遵循 先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li>
<li>示意图：(使用数组模拟队列示意图)<br><img src="http://qd1ql2976.bkt.clouddn.com/2361" alt=""></li>
</ol>
</li>
<li><h4 id="数组模拟队列思路"><a href="#数组模拟队列思路" class="headerlink" title="数组模拟队列思路"></a>数组模拟队列思路</h4><ul>
<li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中maxSize 是该队列的最大容量。</p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标，front会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示:<br><img src="http://qd1ql2976.bkt.clouddn.com/2361" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; 创建一个队列</span><br><span class="line">		ArrayQueue queue &#x3D; new ArrayQueue(3);</span><br><span class="line">		&#x2F;&#x2F; 接受用户输入</span><br><span class="line">		char key &#x3D; &#39; &#39;;</span><br><span class="line">		&#x2F;&#x2F; 创建输出</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		boolean loop &#x3D; true;</span><br><span class="line">		&#x2F;&#x2F;输出一个菜单</span><br><span class="line">		while (loop) &#123;</span><br><span class="line">			System.out.println(&quot;\t\ts(show): 显示队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\te(exit): 退出程序&quot;);</span><br><span class="line">			System.out.println(&quot;\t\ta(add): 添加数据到队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\tg(get): 从队列取出数据&quot;);</span><br><span class="line">			System.out.println(&quot;\t\th(head): 查看队列头的数据&quot;);</span><br><span class="line">			key &#x3D; sc.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">			switch (key) &#123;</span><br><span class="line">				case &#39;a&#39; : &#x2F;&#x2F; 添加数据到队列</span><br><span class="line">					System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">					int n &#x3D; sc.nextInt();</span><br><span class="line">					queue.addQueue(n);</span><br><span class="line">					break;</span><br><span class="line">				case &#39;g&#39; : &#x2F;&#x2F; 从队列取出数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;取出的数据是：%d\n&quot;,queue.getQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;s&#39; : &#x2F;&#x2F; 显示队列</span><br><span class="line">					queue.showQueue();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;h&#39; : &#x2F;&#x2F; 查看队列头的数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;队列头的数据是：%d\n&quot;,queue.headQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;e&#39; : &#x2F;&#x2F; 退出程序</span><br><span class="line">	    sc.close();</span><br><span class="line">					loop &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;程序退出~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ArrayQueue&#123;</span><br><span class="line">	private int MaxSize; &#x2F;&#x2F; 队列的最大容量</span><br><span class="line">	private int front; &#x2F;&#x2F; 队列头</span><br><span class="line">	private int rear; &#x2F;&#x2F; 队列尾</span><br><span class="line">	private int[] arr; &#x2F;&#x2F; 该数据用于存放数据, 模拟队列</span><br><span class="line">	</span><br><span class="line">	public ArrayQueue(int arrMaxSize)&#123;</span><br><span class="line">		arr &#x3D;  new int[arrMaxSize];</span><br><span class="line">		MaxSize &#x3D; arrMaxSize;</span><br><span class="line">		front &#x3D; -1; &#x2F;&#x2F; 指向队列头部，分析出front是指向队列头的前一个位置.</span><br><span class="line">		rear &#x3D; -1; &#x2F;&#x2F; 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否满</span><br><span class="line">	public boolean isFull()&#123;</span><br><span class="line">		return rear &#x3D;&#x3D; MaxSize-1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	public boolean isEmpty()&#123;</span><br><span class="line">		return front &#x3D;&#x3D; rear;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 添加数据到队列</span><br><span class="line">	public void addQueue(int n)&#123;</span><br><span class="line">		if (isFull()) &#123;</span><br><span class="line">			System.out.println(&quot;队列已满，不能添加！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		rear++; &#x2F;&#x2F; 进队列，rear后移一位</span><br><span class="line">		arr[rear] &#x3D; n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 获取队列的数据, 出队列</span><br><span class="line">	public int getQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		front++; &#x2F;&#x2F; 出队列，front后移一位</span><br><span class="line">		return arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的所有数据</span><br><span class="line">	public void showQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			System.out.println(&quot;队列空的，没有数据~~&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 遍历</span><br><span class="line">		for (int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">			System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的头数据， 注意不是取出数据</span><br><span class="line">	public int headQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[front+1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>问题分析并优化</p>
<ol>
<li>目前数组使用一次就不能用， 没有达到复用的效果</li>
<li>将这个数组使用算法，改进成一个列 环形的队列 取模：%</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h4><p> 对前面的数组模拟队列的优化，充分利用数组。 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<ul>
<li><p>分析说明</p>
<ol>
<li>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front 满]</li>
<li>rear == front [空]</li>
<li>分析示意图<br><img src="http://qd1ql2976.bkt.clouddn.com/2361" alt=""></li>
<li>思路如下<ol>
<li>front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素<br>front 的初始值 = 0</li>
<li>rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.<br>rear 的初始值 = 0</li>
<li>当队列满时，条件是  (rear  + 1) % maxSize == front 【满】</li>
<li>对队列为空的条件， rear == front 【空】</li>
<li>当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize</li>
</ol>
</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;测试一把</span><br><span class="line">		System.out.println(&quot;测试数组模拟环形队列的案例~~~&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建一个环形队列</span><br><span class="line">		CircleArrayQueue queue &#x3D; new CircleArrayQueue(4); &#x2F;&#x2F;说明设置4, 其队列的有效数据最大是3</span><br><span class="line">		&#x2F;&#x2F; 接受用户输入</span><br><span class="line">		char key &#x3D; &#39; &#39;;</span><br><span class="line">		&#x2F;&#x2F; 创建输出</span><br><span class="line">		Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">		boolean loop &#x3D; true;</span><br><span class="line">		&#x2F;&#x2F;输出一个菜单</span><br><span class="line">		while (loop) &#123;</span><br><span class="line">			System.out.println(&quot;\t\ts(show): 显示队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\te(exit): 退出程序&quot;);</span><br><span class="line">			System.out.println(&quot;\t\ta(add): 添加数据到队列&quot;);</span><br><span class="line">			System.out.println(&quot;\t\tg(get): 从队列取出数据&quot;);</span><br><span class="line">			System.out.println(&quot;\t\th(head): 查看队列头的数据&quot;);</span><br><span class="line">			key &#x3D; sc.next().charAt(0);&#x2F;&#x2F;接收一个字符</span><br><span class="line">			switch (key) &#123;</span><br><span class="line">				case &#39;a&#39; : &#x2F;&#x2F; 添加数据到队列</span><br><span class="line">					System.out.println(&quot;请输入一个数据&quot;);</span><br><span class="line">					int n &#x3D; sc.nextInt();</span><br><span class="line">					queue.addQueue(n);</span><br><span class="line">					break;</span><br><span class="line">				case &#39;g&#39; : &#x2F;&#x2F; 从队列取出数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;取出的数据是：%d\n&quot;,queue.getQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;s&#39; : &#x2F;&#x2F; 显示队列</span><br><span class="line">					queue.showQueue();</span><br><span class="line">					break;</span><br><span class="line">				case &#39;h&#39; : &#x2F;&#x2F; 查看队列头的数据</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.printf(&quot;队列头的数据是：%d\n&quot;,queue.headQueue());</span><br><span class="line">					&#125; catch (Exception e) &#123;</span><br><span class="line">						&#x2F;&#x2F; TODO: handle exception</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					break;</span><br><span class="line">				case &#39;e&#39; : &#x2F;&#x2F; 退出程序</span><br><span class="line">					sc.close();</span><br><span class="line">					loop &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				default:</span><br><span class="line">					break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;程序退出~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class CircleArrayQueue&#123;</span><br><span class="line">	private int MaxSize; &#x2F;&#x2F; 表示数组的最大容量</span><br><span class="line">	&#x2F;&#x2F; front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span><br><span class="line">	&#x2F;&#x2F; front 的初始值 &#x3D; 0</span><br><span class="line">	private int front; </span><br><span class="line">	&#x2F;&#x2F; rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span><br><span class="line">	&#x2F;&#x2F; rear 的初始值 &#x3D; 0</span><br><span class="line">	private int rear; &#x2F;&#x2F; 队列尾</span><br><span class="line">	private int[] arr; &#x2F;&#x2F; 该数据用于存放数据, 模拟队列</span><br><span class="line"></span><br><span class="line">	public CircleArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">		arr &#x3D; new int[arrMaxSize];</span><br><span class="line">		MaxSize &#x3D; arrMaxSize;</span><br><span class="line">		front &#x3D; 0; &#x2F;&#x2F; 指向队列头部，分析出front是指向队列头的位置</span><br><span class="line">		rear &#x3D; 0; &#x2F;&#x2F; 指向队列尾，指向队列尾的后一个位置</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 当前队列有效的数据的个数</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return ( rear + MaxSize - front ) % MaxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 判断队列是否满</span><br><span class="line">	public boolean isFull()&#123;</span><br><span class="line">		return ( rear + 1 ) % MaxSize &#x3D;&#x3D; front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 判断队列是否为空</span><br><span class="line">	public boolean isEmpty()&#123;</span><br><span class="line">		return front &#x3D;&#x3D; rear;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 添加数据到队列</span><br><span class="line">	public void addQueue(int n)&#123;</span><br><span class="line">		if (isFull()) &#123;</span><br><span class="line">			System.out.println(&quot;队列已满，不能添加！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;直接将数据加入</span><br><span class="line">		arr[rear] &#x3D; n;</span><br><span class="line">		&#x2F;&#x2F;将 rear 后移, 这里必须考虑取模</span><br><span class="line">		rear &#x3D; ( rear + 1 ) % MaxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 获取队列的数据, 出队列</span><br><span class="line">	public int getQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，不能取数据&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 这里需要分析出 front是指向队列的第一个元素</span><br><span class="line">		&#x2F;&#x2F; 1. 先把 front 对应的值保留到一个临时变量</span><br><span class="line">		&#x2F;&#x2F; 2. 将 front 后移, 考虑取模</span><br><span class="line">		&#x2F;&#x2F; 3. 将临时保存的变量返回</span><br><span class="line">		int temp &#x3D; arr[front];</span><br><span class="line">		front &#x3D; ( front + 1 ) % MaxSize;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的所有数据</span><br><span class="line">	public void showQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			System.out.println(&quot;队列空的，没有数据~~&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 思路：从front开始遍历，遍历多少个元素</span><br><span class="line">		&#x2F;&#x2F; 动脑筋</span><br><span class="line">		for (int i &#x3D; front; i &lt; front + size(); i++)&#123;</span><br><span class="line">			System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i % MaxSize, arr[i % MaxSize]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 显示队列的头数据， 注意不是取出数据</span><br><span class="line">	public int headQueue()&#123;</span><br><span class="line">		if (isEmpty()) &#123;</span><br><span class="line">			&#x2F;&#x2F; 通过抛出异常</span><br><span class="line">			throw new RuntimeException(&quot;队列空，没有数据~~&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>队列</tag>
        <tag>环形队列</tag>
        <tag>数组模拟队列</tag>
        <tag>数组模拟环形队列</tag>
      </tags>
  </entry>
  <entry>
    <title>02.数据结构-稀疏sparsearray数组</title>
    <url>/2020/07/04/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8Fsparsearray%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="稀疏sparsearray数组"><a href="#稀疏sparsearray数组" class="headerlink" title="稀疏sparsearray数组"></a>稀疏sparsearray数组</h2><ol>
<li><h4 id="先看一个实际的需求"><a href="#先看一个实际的需求" class="headerlink" title="先看一个实际的需求"></a>先看一个实际的需求</h4><ul>
<li>编写的五子棋程序中，有存盘退出和续上盘的功能。<br><img src="http://qd1ql2976.bkt.clouddn.com/2296" alt=""></li>
<li>分析问题: 因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据→稀疏数组。</li>
</ul>
</li>
<li><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p> 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<h5 id="稀疏数组的处理方法是"><a href="#稀疏数组的处理方法是" class="headerlink" title="稀疏数组的处理方法是:"></a>稀疏数组的处理方法是:</h5><ol>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模<h5 id="稀疏数组举例说明"><a href="#稀疏数组举例说明" class="headerlink" title="稀疏数组举例说明"></a>稀疏数组举例说明</h5><img src="http://qd1ql2976.bkt.clouddn.com/2307" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2309" alt=""></li>
</ol>
</li>
<li><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><ul>
<li><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</p>
</li>
<li><p>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</p>
</li>
<li><p>整体思路分析<br><img src="http://qd1ql2976.bkt.clouddn.com/2326" alt=""></p>
</li>
<li><p>二维数组 转 稀疏数组的思路</p>
<ol>
<li>遍历  原始的二维数组，得到有效数据的个数 sum</li>
<li>根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]</li>
<li>将二维数组的有效数据数据存入到 稀疏数组</li>
</ol>
</li>
<li><p>稀疏数组转原始的二维数组的思路</p>
<ol>
<li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</li>
<li>在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</li>
</ol>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.sparsearray;</span><br><span class="line"></span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; 创建11*11的二维数组</span><br><span class="line">		int[][] chessArr1&#x3D;new int[11][11];</span><br><span class="line">		&#x2F;&#x2F; 0代表没有棋子，1代表黑子，2代表蓝子</span><br><span class="line">		chessArr1[1][2]&#x3D;1;</span><br><span class="line">		chessArr1[2][3]&#x3D;2;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出原始二维数组chessArr1</span><br><span class="line">		System.out.println(&quot;输出原始的二维数组chessArr1&quot;);</span><br><span class="line">		for (int[] row : chessArr1)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 将二维数组 转 稀疏数组</span><br><span class="line">		&#x2F;&#x2F; 遍历chessArr1  非0数据的个数计为sum</span><br><span class="line">		int sum&#x3D;0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; chessArr1.length; i++)&#123;</span><br><span class="line">			for(int j &#x3D; 0;j &lt; chessArr1.length; j++)&#123;</span><br><span class="line">				if(chessArr1[i][j] !&#x3D; 0)&#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 输出sum</span><br><span class="line">		System.out.println(&quot;sum&#x3D;&quot;+sum);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建稀疏数组</span><br><span class="line">		int[][] sparseArr &#x3D; new int[sum+1][3];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 给稀疏数组赋值</span><br><span class="line">		sparseArr[0][0] &#x3D; 11;</span><br><span class="line">		sparseArr[0][1] &#x3D; 11;</span><br><span class="line">		sparseArr[0][2] &#x3D; sum;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 遍历原始二维数组，将非0的值存放到 sparseArr中</span><br><span class="line">		int count &#x3D; 0; &#x2F;&#x2F;count 用于记录是第几个非0数据</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 11; i++)&#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 11; j++)&#123;</span><br><span class="line">				if (chessArr1[i][j] !&#x3D;0 )&#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][0] &#x3D; i;</span><br><span class="line">					sparseArr[count][1] &#x3D; j;</span><br><span class="line">					sparseArr[count][2] &#x3D; chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出稀疏数组</span><br><span class="line">		System.out.println(&quot;得到稀疏数组为~~~~&quot;);</span><br><span class="line">		for (int[] row : sparseArr)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 将稀疏数组 --》 恢复成 原始的二维数组</span><br><span class="line">		&#x2F;*</span><br><span class="line">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 &#x3D; int [11][11]</span><br><span class="line">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span><br><span class="line">		int[][] chessArr2 &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span><br><span class="line">		for (int i &#x3D; 1; i &lt; sparseArr.length; i++)&#123;</span><br><span class="line">			chessArr2[sparseArr[1][0]][sparseArr[i][1]] &#x3D; sparseArr[i][2];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 输出原始二维数组chessArr2</span><br><span class="line">		System.out.println(&quot;恢复后的二维数组chessArr2&quot;);</span><br><span class="line">		for (int[] row : chessArr2)&#123;</span><br><span class="line">			for (int data : row)&#123;</span><br><span class="line">				System.out.printf(&quot;%d\t&quot;, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>稀疏数组</tag>
        <tag>sparsearray</tag>
      </tags>
  </entry>
  <entry>
    <title>05.数据结构-单链表面试题</title>
    <url>/2020/07/08/05-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="单链表的常见面试题有如下"><a href="#单链表的常见面试题有如下" class="headerlink" title="单链表的常见面试题有如下:"></a>单链表的常见面试题有如下:</h2><ul>
<li><p>求单链表中有效节点的个数</p>
<ul>
<li><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span><br><span class="line">public static int getLength(HeroNode head) &#123;</span><br><span class="line">	if (head.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;空链表</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int length &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助的变量, 这里我们没有统计头节点</span><br><span class="line">	HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">	while (cur.next !&#x3D; null) &#123; &#x2F;&#x2F; while(cur !&#x3D; null) &#123;</span><br><span class="line">		length++;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查找单链表中的倒数第k个结点 【新浪面试题】</p>
<ul>
<li><p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;查找单链表中的倒数第k个结点 【新浪面试题】</span><br><span class="line">&#x2F;&#x2F;思路</span><br><span class="line">&#x2F;&#x2F;1. 编写一个方法，接收head节点，同时接收一个index </span><br><span class="line">&#x2F;&#x2F;2. index 表示是倒数第index个节点</span><br><span class="line">&#x2F;&#x2F;3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span><br><span class="line">&#x2F;&#x2F;4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span><br><span class="line">&#x2F;&#x2F;5. 如果找到了，则返回该节点，否则返回nulll</span><br><span class="line">public static HeroNode findLastIndexNode(HeroNode head, int index)&#123;</span><br><span class="line">	&#x2F;&#x2F;判断如果链表为空，返回null</span><br><span class="line">	if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;第一个遍历得到链表的长度(节点个数)</span><br><span class="line">	int length &#x3D; getLength(head);</span><br><span class="line">	&#x2F;&#x2F;第二次遍历  size-index 位置，就是我们倒数的第K个节点</span><br><span class="line">	&#x2F;&#x2F;先做一个index的校验</span><br><span class="line">	if (index &lt;&#x3D; 0 || index &gt; length)&#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">	for(int i &#x3D; 0; i &lt;&#x3D; length - index; i++) &#123;&#x2F;&#x2F; for(int i &#x3D;0; i&lt; size - index; i++) &#123;</span><br><span class="line">		cur &#x3D; cur.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>单链表的反转【腾讯面试题，有点难度】</p>
<ul>
<li><p>图解思路</p>
<ol>
<li>先定义一个节点 reverseHead = new HeroNode();</li>
<li>从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端.</li>
<li>原来的链表的head.next = reverseHead.next</li>
</ol>
<p><img src="http://qd1ql2976.bkt.clouddn.com/2970" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2973" alt=""></p>
</li>
<li><p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将单链表反转</span><br><span class="line">public static void reversetList(HeroNode head)&#123;</span><br><span class="line">	&#x2F;&#x2F;如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">	if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	HeroNode reverseHead &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	&#x2F;&#x2F;定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span><br><span class="line">	HeroNode cur &#x3D; head.next ;</span><br><span class="line">	HeroNode next &#x3D; null;&#x2F;&#x2F; 指向当前节点[cur]的下一个节点</span><br><span class="line">	&#x2F;&#x2F;遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span><br><span class="line">	while(cur !&#x3D; null) &#123;</span><br><span class="line">		next &#x3D; cur.next;&#x2F;&#x2F;先暂时保存当前节点的下一个节点，因为后面需要使用</span><br><span class="line">		cur.next &#x3D; reverseHead.next;&#x2F;&#x2F;将cur的下一个节点指向新的链表的最前端</span><br><span class="line">		reverseHead.next &#x3D; cur;&#x2F;&#x2F;将cur 连接到新的链表上</span><br><span class="line">		cur &#x3D; next;&#x2F;&#x2F;让cur后移</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将head.next 指向 reverseHead.next , 实现单链表的反转</span><br><span class="line">	head.next &#x3D; reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】</p>
<ul>
<li><p>图解思路</p>
<p><img src="http://qd1ql2976.bkt.clouddn.com/2975" alt=""></p>
</li>
<li><p>代码实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;方式2：</span><br><span class="line">&#x2F;&#x2F;可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span><br><span class="line">public static void reversePrint(HeroNode head) &#123;</span><br><span class="line">	if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">		return;&#x2F;&#x2F;空链表，不能打印</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;创建要给一个栈，将各个节点压入栈</span><br><span class="line">	Stack&lt;HeroNode&gt; stack &#x3D; new Stack&lt;HeroNode&gt;();</span><br><span class="line">	HeroNode cur &#x3D; head.next;</span><br><span class="line">	&#x2F;&#x2F;将链表的所有节点压入栈</span><br><span class="line">	while(cur !&#x3D; null) &#123;</span><br><span class="line">		stack.push(cur);</span><br><span class="line">		cur &#x3D; cur.next; &#x2F;&#x2F;cur后移，这样就可以压入下一个节点</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;将栈中的节点进行打印,pop 出栈</span><br><span class="line">	while (stack.size() &gt; 0) &#123;</span><br><span class="line">		System.out.println(stack.pop()); &#x2F;&#x2F;stack的特点是先进后出</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>合并两个有序的单链表，合并之后的链表依然有序</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.linkedlist;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个链表</span><br><span class="line">		SingleLinkedList singlelinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode h1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">		HeroNode h2 &#x3D; new HeroNode(2,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">		HeroNode h3 &#x3D; new HeroNode(3,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode h4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		singlelinkedList.addByOrder(h3);</span><br><span class="line">		singlelinkedList.addByOrder(h2);</span><br><span class="line">		singlelinkedList.addByOrder(h4);</span><br><span class="line">		singlelinkedList.addByOrder(h1);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;创建第二个链表</span><br><span class="line">		SingleLinkedList singlelinkedList1 &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode h11 &#x3D; new HeroNode(10,&quot;张三&quot;,&quot;张三&quot;);</span><br><span class="line">		HeroNode h22 &#x3D; new HeroNode(21,&quot;李四&quot;,&quot;李四&quot;);</span><br><span class="line">		HeroNode h33 &#x3D; new HeroNode(13,&quot;王五&quot;,&quot;王五&quot;);</span><br><span class="line">		HeroNode h44 &#x3D; new HeroNode(45,&quot;刘六&quot;,&quot;刘六&quot;);</span><br><span class="line">		singlelinkedList1.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		singlelinkedList1.addByOrder(h11);</span><br><span class="line">		singlelinkedList1.addByOrder(h22);</span><br><span class="line">		singlelinkedList1.addByOrder(h33);</span><br><span class="line">		singlelinkedList1.addByOrder(h44);</span><br><span class="line">		singlelinkedList1.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;直接添加无排序</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h11);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h22);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h33);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h44);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList1.list();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;合并两个有序的单链表，合并之后的链表依然有序</span><br><span class="line">		System.out.println(&quot;合并两个有序的单链表，合并之后的链表依然有序&quot;);</span><br><span class="line">		singlelinkedListTwo(singlelinkedList1.getHead(),singlelinkedList.getHead());</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;获取有效节点的个数</span><br><span class="line">		&#x2F;*System.out.println(&quot;有效节点个数：&quot;+getLength(singlelinkedList.getHead()));*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;倒数第k个节点</span><br><span class="line">		&#x2F;*System.out.println(&quot;倒数第k个节点：&quot;+findLastIndexNode(singlelinkedList.getHead(),1));*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;翻转</span><br><span class="line">		&#x2F;*System.out.println(&quot;反转&quot;);</span><br><span class="line">		reversetList(singlelinkedList.getHead());</span><br><span class="line">		singlelinkedList.list();*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;逆序打印</span><br><span class="line">		&#x2F;*System.out.println(&quot;反转&quot;);</span><br><span class="line">		reversePrint(singlelinkedList.getHead());*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		&#x2F;*System.out.println(&quot;修改豹子头林冲&quot;);</span><br><span class="line">		HeroNode h5 &#x3D; new HeroNode(4,&quot;林冲~~~&quot;,&quot;豹子头~~~&quot;);</span><br><span class="line">		singlelinkedList.update(h5);</span><br><span class="line">		singlelinkedList.list();*&#x2F;</span><br><span class="line">		&#x2F;&#x2F;删除</span><br><span class="line">		&#x2F;*System.out.println(&quot;删除豹子头林冲&quot;);</span><br><span class="line">		singlelinkedList.delete(1);</span><br><span class="line">		singlelinkedList.delete(2);</span><br><span class="line">		singlelinkedList.delete(3);</span><br><span class="line">		singlelinkedList.delete(4);</span><br><span class="line">		singlelinkedList.list();*&#x2F;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;合并两个有序的单链表，合并之后的链表依然有序</span><br><span class="line">	public static void singlelinkedListTwo(HeroNode head1 , HeroNode head2)&#123;</span><br><span class="line">		SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode  head&#x3D; singleLinkedList.getHead();</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">		HeroNode cur &#x3D; head;</span><br><span class="line">		HeroNode cur1 &#x3D; head1.next;</span><br><span class="line">		HeroNode cur2 &#x3D; head2.next;</span><br><span class="line">		while (cur1 !&#x3D; null &amp;&amp; cur2 !&#x3D; null) &#123;</span><br><span class="line">            if (cur1.no &lt;&#x3D; cur2.no) &#123;</span><br><span class="line">            	cur.next &#x3D; cur1;</span><br><span class="line">            	cur &#x3D; cur.next;</span><br><span class="line">                cur1 &#x3D; cur1.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	cur.next &#x3D; cur2;</span><br><span class="line">            	cur &#x3D; cur.next;</span><br><span class="line">                cur2 &#x3D; cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (cur1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            while (cur2 !&#x3D; null) &#123;</span><br><span class="line">            	cur.next &#x3D; cur2;</span><br><span class="line">                cur &#x3D; cur.next;</span><br><span class="line">                cur2 &#x3D; cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (cur1 !&#x3D; null) &#123;</span><br><span class="line">            	cur.next &#x3D; cur1;</span><br><span class="line">            	cur &#x3D; cur.next;</span><br><span class="line">                cur1 &#x3D; cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span><br><span class="line">	public static int getLength(HeroNode head) &#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;空链表</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		int length &#x3D; 0;</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助的变量, 这里我们没有统计头节点</span><br><span class="line">		HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">		while (cur.next !&#x3D; null) &#123; &#x2F;&#x2F; while(cur !&#x3D; null) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			cur &#x3D; cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;查找单链表中的倒数第k个结点 【新浪面试题】</span><br><span class="line">	&#x2F;&#x2F;思路</span><br><span class="line">	&#x2F;&#x2F;1. 编写一个方法，接收head节点，同时接收一个index </span><br><span class="line">	&#x2F;&#x2F;2. index 表示是倒数第index个节点</span><br><span class="line">	&#x2F;&#x2F;3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span><br><span class="line">	&#x2F;&#x2F;4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span><br><span class="line">	&#x2F;&#x2F;5. 如果找到了，则返回该节点，否则返回null</span><br><span class="line">	public static HeroNode findLastIndexNode(HeroNode head, int index)&#123;</span><br><span class="line">		&#x2F;&#x2F;判断如果链表为空，返回null</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;第一个遍历得到链表的长度(节点个数)</span><br><span class="line">		int length &#x3D; getLength(head);</span><br><span class="line">		&#x2F;&#x2F;第二次遍历  size-index 位置，就是我们倒数的第K个节点</span><br><span class="line">		&#x2F;&#x2F;先做一个index的校验</span><br><span class="line">		if (index &lt;&#x3D; 0 || index &gt; length)&#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		HeroNode cur &#x3D; head; &#x2F;&#x2F; HeroNode cur &#x3D; head.next;</span><br><span class="line">		for(int i &#x3D; 0; i &lt;&#x3D; length - index; i++) &#123;&#x2F;&#x2F; for(int i &#x3D;0; i&lt; size - index; i++) &#123;</span><br><span class="line">			cur &#x3D; cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return cur;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;将单链表反转</span><br><span class="line">	public static void reversetList(HeroNode head)&#123;</span><br><span class="line">		&#x2F;&#x2F;如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">		if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		HeroNode reverseHead &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span><br><span class="line">		HeroNode cur &#x3D; head.next ;</span><br><span class="line">		HeroNode next &#x3D; null;&#x2F;&#x2F; 指向当前节点[cur]的下一个节点</span><br><span class="line">		&#x2F;&#x2F;遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span><br><span class="line">		while(cur !&#x3D; null) &#123;</span><br><span class="line">			next &#x3D; cur.next;&#x2F;&#x2F;先暂时保存当前节点的下一个节点，因为后面需要使用</span><br><span class="line">			cur.next &#x3D; reverseHead.next;&#x2F;&#x2F;将cur的下一个节点指向新的链表的最前端</span><br><span class="line">			reverseHead.next &#x3D; cur;&#x2F;&#x2F;将cur 连接到新的链表上</span><br><span class="line">			cur &#x3D; next;&#x2F;&#x2F;让cur后移</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;将head.next 指向 reverseHead.next , 实现单链表的反转</span><br><span class="line">		head.next &#x3D; reverseHead.next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;方式2：</span><br><span class="line">	&#x2F;&#x2F;可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span><br><span class="line">	public static void reversePrint(HeroNode head) &#123;</span><br><span class="line">		if(head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return;&#x2F;&#x2F;空链表，不能打印</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;创建要给一个栈，将各个节点压入栈</span><br><span class="line">		Stack&lt;HeroNode&gt; stack &#x3D; new Stack&lt;HeroNode&gt;();</span><br><span class="line">		HeroNode cur &#x3D; head.next;</span><br><span class="line">		&#x2F;&#x2F;将链表的所有节点压入栈</span><br><span class="line">		while(cur !&#x3D; null) &#123;</span><br><span class="line">			stack.push(cur);</span><br><span class="line">			cur &#x3D; cur.next; &#x2F;&#x2F;cur后移，这样就可以压入下一个节点</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;将栈中的节点进行打印,pop 出栈</span><br><span class="line">		while (stack.size() &gt; 0) &#123;</span><br><span class="line">			System.out.println(stack.pop()); &#x2F;&#x2F;stack的特点是先进后出</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义SingleLinkedList 管理我们的英雄</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	public HeroNode getHead() &#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setHead(HeroNode head) &#123;</span><br><span class="line">		this.head &#x3D; head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">	&#x2F;&#x2F;思路，当不考虑编号顺序时</span><br><span class="line">	&#x2F;&#x2F;1. 找到当前链表的最后节点</span><br><span class="line">	&#x2F;&#x2F;2. 将最后这个节点的next 指向 新的节点</span><br><span class="line">	public void add(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		&#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			&#x2F;&#x2F;找到链表的最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;遍历结束</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;如果没有找到最后, 将将temp后移</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;当退出while循环时，temp就指向了链表的最后</span><br><span class="line">		&#x2F;&#x2F;将最后这个节点的next 指向 新的节点</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;添加成功&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span><br><span class="line">	&#x2F;&#x2F;(如果有这个排名，则添加失败，并给出提示)</span><br><span class="line">	public void addByOrder(HeroNode heroNode)&#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span><br><span class="line">		&#x2F;&#x2F;因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F; flag标志添加的编号是否存在，默认为false</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break ;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else if(temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;后移，遍历当前链表</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			System.out.printf(&quot;添加失败，排名为%d的英雄已经存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;插入到链表中, temp的后面</span><br><span class="line">			heroNode.next &#x3D; temp.next;</span><br><span class="line">			temp.next &#x3D; heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改节点的信息, 根据no编号来修改，即no编号不能改.</span><br><span class="line">	&#x2F;&#x2F;说明</span><br><span class="line">	&#x2F;&#x2F;1. 根据 newHeroNode 的 no 来修改即可</span><br><span class="line">	public void update(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;遍历</span><br><span class="line">		&#x2F;&#x2F;找到需要修改的节点, 根据no编号</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F;表示是否找到该节点</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;&#x2F;&#x2F;已经遍历完链表</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;&#x2F;&#x2F;找到</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;根据flag 判断是否找到要修改的节点</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			temp.next.name &#x3D; heroNode.name;</span><br><span class="line">			temp.next.nickName &#x3D; heroNode.nickName;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	&#x2F;&#x2F;思路</span><br><span class="line">	&#x2F;&#x2F;1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span><br><span class="line">	&#x2F;&#x2F;2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span><br><span class="line">	public void delete(int no)&#123;</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false; &#x2F;&#x2F; 标志是否找到待删除节点的</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; no)&#123;&#x2F;&#x2F;找到的待删除节点的前一个节点temp</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;temp后移，遍历</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;判断flag</span><br><span class="line">		if (flag)&#123; &#x2F;&#x2F;找到</span><br><span class="line">			temp.next &#x3D; temp.next.next;&#x2F;&#x2F;可以删除</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示链表[遍历]</span><br><span class="line">	public void list()&#123;</span><br><span class="line">		&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;链表为空，没有数据！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;输出节点的信息</span><br><span class="line">			System.out.println(temp.next);</span><br><span class="line">			&#x2F;&#x2F;将temp后移， 一定小心</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">	int no;</span><br><span class="line">	String name;</span><br><span class="line">	String nickName;</span><br><span class="line">	HeroNode next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode(int no, String name, String nickName)&#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickName &#x3D; nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickName&#x3D;&quot; + nickName  + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>单链表</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>04.数据结构-链表</title>
    <url>/2020/07/06/04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一、链表-Linked-List-介绍"><a href="#一、链表-Linked-List-介绍" class="headerlink" title="一、链表(Linked List)介绍"></a>一、链表(Linked List)介绍</h2><p>链表是有序的列表，但是它在内存中是存储如下</p>
<p><img src="http://qd1ql2976.bkt.clouddn.com/2630" alt=""></p>
<p><strong>上图小结:</strong></p>
<ul>
<li>链表是以节点的方式来存储,是链式存储</li>
<li>每个节点包含 data 域， next 域：指向下一个节点.</li>
<li>如图：发现链表的各个节点不一定是连续存储.</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定<ul>
<li>单链表(带头结点) 逻辑结构示意图如下<br><img src="http://qd1ql2976.bkt.clouddn.com/2633" alt=""><h2 id="二、单链表的应用实例"><a href="#二、单链表的应用实例" class="headerlink" title="二、单链表的应用实例"></a>二、单链表的应用实例</h2>使用带 head 头的单向链表实现–水浒英雄排行榜管理完成对英雄人物的增删改查操作。<br><img src="http://qd1ql2976.bkt.clouddn.com/2635" alt=""></li>
</ul>
</li>
</ul>
<ol>
<li><p>第一种方法在添加英雄时，直接添加到链表的尾部<br>思路分析示意图:<br><img src="http://qd1ql2976.bkt.clouddn.com/2637" alt=""></p>
</li>
<li><p>第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)<br>思路的分析示意图:<br><img src="http://qd1ql2976.bkt.clouddn.com/2639" alt=""></p>
</li>
<li><p>修改节点功能<br>思路<br>先找到该节点，通过遍历</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.name &#x3D; newHeroNode.name ;</span><br><span class="line">temp.nickname&#x3D; newHeroNode.nickname</span><br></pre></td></tr></table></figure></li>
<li><p>删除节点<br>思路分析的示意图:<br><img src="http://qd1ql2976.bkt.clouddn.com/2641" alt=""></p>
</li>
<li><p>代码演示:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.linkedlist;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建一个链表</span><br><span class="line">		SingleLinkedList singlelinkedList &#x3D; new SingleLinkedList();</span><br><span class="line">		HeroNode h1 &#x3D; new HeroNode(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">		HeroNode h2 &#x3D; new HeroNode(2,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">		HeroNode h3 &#x3D; new HeroNode(3,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode h4 &#x3D; new HeroNode(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		&#x2F;&#x2F;直接添加无排序</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h1);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h2);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h3);</span><br><span class="line">&#x2F;&#x2F;		singlelinkedList.add(h4);</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		singlelinkedList.addByOrder(h3);</span><br><span class="line">		singlelinkedList.addByOrder(h2);</span><br><span class="line">		singlelinkedList.addByOrder(h4);</span><br><span class="line">		singlelinkedList.addByOrder(h1);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		System.out.println(&quot;修改豹子头林冲&quot;);</span><br><span class="line">		HeroNode h5 &#x3D; new HeroNode(4,&quot;林冲~~~&quot;,&quot;豹子头~~~&quot;);</span><br><span class="line">		singlelinkedList.update(h5);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">		&#x2F;&#x2F;删除</span><br><span class="line">		System.out.println(&quot;删除豹子头林冲&quot;);</span><br><span class="line">		singlelinkedList.delete(1);</span><br><span class="line">		singlelinkedList.delete(2);</span><br><span class="line">		singlelinkedList.delete(3);</span><br><span class="line">		singlelinkedList.delete(4);</span><br><span class="line">		singlelinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义SingleLinkedList 管理我们的英雄</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">	&#x2F;&#x2F;思路，当不考虑编号顺序时</span><br><span class="line">	&#x2F;&#x2F;1. 找到当前链表的最后节点</span><br><span class="line">	&#x2F;&#x2F;2. 将最后这个节点的next 指向 新的节点</span><br><span class="line">	public void add(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		&#x2F;&#x2F;遍历链表，找到最后</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			&#x2F;&#x2F;找到链表的最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;遍历结束</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;如果没有找到最后, 将将temp后移</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;当退出while循环时，temp就指向了链表的最后</span><br><span class="line">		&#x2F;&#x2F;将最后这个节点的next 指向 新的节点</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;添加成功&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span><br><span class="line">	&#x2F;&#x2F;(如果有这个排名，则添加失败，并给出提示)</span><br><span class="line">	public void addByOrder(HeroNode heroNode)&#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span><br><span class="line">		&#x2F;&#x2F;因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F; flag标志添加的编号是否存在，默认为false</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break ;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;else if(temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;后移，遍历当前链表</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			System.out.printf(&quot;添加失败，排名为%d的英雄已经存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F;插入到链表中, temp的后面</span><br><span class="line">			heroNode.next &#x3D; temp.next;</span><br><span class="line">			temp.next &#x3D; heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改节点的信息, 根据no编号来修改，即no编号不能改.</span><br><span class="line">	&#x2F;&#x2F;说明</span><br><span class="line">	&#x2F;&#x2F;1. 根据 newHeroNode 的 no 来修改即可</span><br><span class="line">	public void update(HeroNode heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;遍历</span><br><span class="line">		&#x2F;&#x2F;找到需要修改的节点, 根据no编号</span><br><span class="line">		&#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;&#x2F;&#x2F;表示是否找到该节点</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;&#x2F;&#x2F;已经遍历完链表</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;&#x2F;&#x2F;找到</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;根据flag 判断是否找到要修改的节点</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			temp.next.name &#x3D; heroNode.name;</span><br><span class="line">			temp.next.nickName &#x3D; heroNode.nickName;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,heroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	&#x2F;&#x2F;思路</span><br><span class="line">	&#x2F;&#x2F;1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span><br><span class="line">	&#x2F;&#x2F;2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span><br><span class="line">	public void delete(int no)&#123;</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false; &#x2F;&#x2F; 标志是否找到待删除节点的</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123; &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; no)&#123;&#x2F;&#x2F;找到的待删除节点的前一个节点temp</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next; &#x2F;&#x2F;temp后移，遍历</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;判断flag</span><br><span class="line">		if (flag)&#123; &#x2F;&#x2F;找到</span><br><span class="line">			temp.next &#x3D; temp.next.next;&#x2F;&#x2F;可以删除</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;修改失败，排名为%d的不存在！\n&quot;,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示链表[遍历]</span><br><span class="line">	public void list()&#123;</span><br><span class="line">		&#x2F;&#x2F;判断链表是否为空</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;链表为空，没有数据！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">		HeroNode temp &#x3D; head;</span><br><span class="line">		while (true)&#123;</span><br><span class="line">			&#x2F;&#x2F;判断是否到链表最后</span><br><span class="line">			if (temp.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;输出节点的信息</span><br><span class="line">			System.out.println(temp.next);</span><br><span class="line">			&#x2F;&#x2F;将temp后移， 一定小心</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">	int no;</span><br><span class="line">	String name;</span><br><span class="line">	String nickName;</span><br><span class="line">	HeroNode next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode(int no, String name, String nickName)&#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickName &#x3D; nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickName&#x3D;&quot; + nickName  + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>单链表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>06.数据结构-双链表</title>
    <url>/2020/07/09/06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点</p>
<h4 id="单链表与双链表区别"><a href="#单链表与双链表区别" class="headerlink" title="单链表与双链表区别"></a>单链表与双链表区别</h4><p>逻辑上没有区别。他们均是完成线性表的内容。主要的区别是结构上的构造有所区别。</p>
<ul>
<li>单链表<ul>
<li>对于一个节点，有储存数据的data。和next后驱节点(指针)。也就是这个单链表想要一些遍历的操作都得通过前节点—&gt;后节点。<br><img src="http://qd1ql2976.bkt.clouddn.com/3155" alt=""></li>
</ul>
</li>
<li>双链表<ul>
<li>对于一个节点，有些和单链表一样有存储数据的data,指向后方的next（指针）。它拥有单链表的所有操作和内容。但是他还有一个前驱节点pre(指针)。<br><img src="http://qd1ql2976.bkt.clouddn.com/3157" alt=""><h4 id="双向链表应用实例"><a href="#双向链表应用实例" class="headerlink" title="双向链表应用实例"></a>双向链表应用实例</h4></li>
</ul>
</li>
</ul>
<p><strong>使用带 head 头的双向链表实现 –水浒英雄排行榜</strong></p>
<ul>
<li>管理单向链表的缺点分析: <ul>
<li>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。</li>
<li>单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).</li>
</ul>
</li>
<li>双链表图解:<br>  <img src="http://qd1ql2976.bkt.clouddn.com/3179" alt=""></li>
<li>图解思路:</li>
</ul>
<ol>
<li>遍历方发和单链表一样，只是可以向前，也可以向后查找</li>
<li>添加 (默认添加到双向链表的最后)<ol>
<li>先找到双向链表的最后这个节点</li>
<li>temp.next = heroNode</li>
<li>heroNode.pre = temp;</li>
</ol>
</li>
<li>修改思路和原来的单向链表一样.</li>
<li>删除<ol>
<li>因为是双向链表，因此，我们可以实现自我删除某个节点</li>
<li>直接找到要删除的这个节点，比如 temp</li>
<li>temp.pre.next = temp.next</li>
<li>temp.next.pre = temp.pre;</li>
</ol>
</li>
</ol>
<ul>
<li><p>代码实现:</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.wzx.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		DoubleLinkedList doubleLinkedList &#x3D; new DoubleLinkedList();</span><br><span class="line">		HeroNode2 h1 &#x3D; new HeroNode2(1,&quot;宋江&quot;,&quot;及时雨&quot;);</span><br><span class="line">		HeroNode2 h2 &#x3D; new HeroNode2(2,&quot;吴用&quot;,&quot;智多星&quot;);</span><br><span class="line">		HeroNode2 h3 &#x3D; new HeroNode2(3,&quot;卢俊义&quot;,&quot;玉麒麟&quot;);</span><br><span class="line">		HeroNode2 h4 &#x3D; new HeroNode2(4,&quot;林冲&quot;,&quot;豹子头&quot;);</span><br><span class="line">		HeroNode2 h5 &#x3D; new HeroNode2(4,&quot;张三&quot;,&quot;李四&quot;);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;顺序添加</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h1);</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h2);</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h3);</span><br><span class="line">&#x2F;&#x2F;		doubleLinkedList.add(h4);</span><br><span class="line">		&#x2F;&#x2F;按排名添加</span><br><span class="line">		doubleLinkedList.addByOrder(h3);</span><br><span class="line">		doubleLinkedList.addByOrder(h2);</span><br><span class="line">		doubleLinkedList.addByOrder(h4);</span><br><span class="line">		doubleLinkedList.addByOrder(h1);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;修改</span><br><span class="line">		System.out.println(&quot;修改后的双链表&quot;);</span><br><span class="line">		doubleLinkedList.update(h5);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;删除</span><br><span class="line">		System.out.println(&quot;删除后的双链表&quot;);</span><br><span class="line">		doubleLinkedList.delete(3);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">class DoubleLinkedList&#123;</span><br><span class="line">	&#x2F;&#x2F;先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">	private HeroNode2 head &#x3D; new HeroNode2(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">	</span><br><span class="line">	public HeroNode2 getHead() &#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;删除节点</span><br><span class="line">	public void delete(int no)&#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;双链表为空，无法删除！！！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;辅助节点</span><br><span class="line">		HeroNode2 temp &#x3D; head.next;</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		while(temp !&#x3D; null)&#123;</span><br><span class="line">			if (temp.no &#x3D;&#x3D; no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D;temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag)&#123;</span><br><span class="line">			temp.pre.next &#x3D; temp.next;</span><br><span class="line">			&#x2F;&#x2F;如果删除的节点是最后一个，不执行temp.next.pre &#x3D; temp.pre;</span><br><span class="line">			&#x2F;&#x2F; 因为temp.next &#x3D; null , temp.next.pre报空指针异常</span><br><span class="line">			if(temp.next !&#x3D; null)&#123;</span><br><span class="line">				temp.next.pre &#x3D; temp.pre;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;双链表中没有排名为%d的英雄！！！&quot;,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改节点</span><br><span class="line">	public void update(HeroNode2 heroNode)&#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;双链表为空，无法修改！！！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		while (temp.next !&#x3D; null)&#123;</span><br><span class="line">			if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag)&#123;</span><br><span class="line">			temp.next.name &#x3D; heroNode.name;</span><br><span class="line">			temp.next.nickName &#x3D; heroNode.nickName;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.printf(&quot;双链表中没有排名为%d的英雄！！！&quot;,heroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;1.结尾添加节点</span><br><span class="line">	public void add(HeroNode2 heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head; </span><br><span class="line">		while(temp.next !&#x3D; null)&#123;</span><br><span class="line">			temp &#x3D; temp.next;&#x2F;&#x2F;后移</span><br><span class="line">		&#125;&#x2F;&#x2F;遍历结束后指向最后一个节点</span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">		heroNode.pre &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;1.按英雄的排名添加节点</span><br><span class="line">	public void addByOrder(HeroNode2 heroNode)&#123;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head;</span><br><span class="line">		boolean flag &#x3D; false;</span><br><span class="line">		while (temp.next !&#x3D; null)&#123;</span><br><span class="line">			if (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;&#x2F;&#x2F;遍历结束后指向最后一个节点 或者 指向比排名大的前一个节点</span><br><span class="line">		&#x2F;&#x2F;如果查入的位置是最后一个节点，不执行 temp.next.pre &#x3D; heroNode;</span><br><span class="line">		&#x2F;&#x2F; 因为temp.next &#x3D; null , temp.next.pre报空指针异常</span><br><span class="line">		if (temp.next !&#x3D; null)&#123;</span><br><span class="line">			temp.next.pre &#x3D; heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">		heroNode.next &#x3D; temp.next;</span><br><span class="line">		heroNode.pre &#x3D; temp; </span><br><span class="line">		temp.next &#x3D; heroNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;遍历显示</span><br><span class="line">	public void list()&#123;</span><br><span class="line">		if (head.next &#x3D;&#x3D; null)&#123;</span><br><span class="line">			System.out.println(&quot;双链表为空！！！&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;辅助变量</span><br><span class="line">		HeroNode2 temp &#x3D; head; </span><br><span class="line">		while(temp.next !&#x3D; null)&#123;</span><br><span class="line">			System.out.println(temp.next);</span><br><span class="line">			temp &#x3D; temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">	int no;</span><br><span class="line">	String name;</span><br><span class="line">	String nickName;</span><br><span class="line">	HeroNode2 next;&#x2F;&#x2F;指向下一个节点</span><br><span class="line">	HeroNode2 pre;&#x2F;&#x2F;指向上一个节点</span><br><span class="line">	&#x2F;&#x2F;构造器</span><br><span class="line">	public HeroNode2(int no, String name, String nickName)&#123;</span><br><span class="line">		this.no &#x3D; no;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.nickName &#x3D; nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;为了显示方法，我们重新toString</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;HeroNode [no&#x3D;&quot; + no + &quot;, name&#x3D;&quot; + name + &quot;, nickName&#x3D;&quot; + nickName  + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>双链表</tag>
      </tags>
  </entry>
  <entry>
    <title>03.Java基础知识-HelloWorld</title>
    <url>/2020/07/03/03-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-HelloWorld/</url>
    <content><![CDATA[<h2 id="一、开发步骤"><a href="#一、开发步骤" class="headerlink" title="一、开发步骤"></a>一、开发步骤</h2><ol>
<li><h5 id="将Java代码编写到扩展名为-java的文件中"><a href="#将Java代码编写到扩展名为-java的文件中" class="headerlink" title="将Java代码编写到扩展名为.java的文件中"></a>将Java代码编写到扩展名为.java的文件中</h5></li>
<li><h5 id="通过javac命令对该java文件进行编译。"><a href="#通过javac命令对该java文件进行编译。" class="headerlink" title="通过javac命令对该java文件进行编译。"></a>通过javac命令对该java文件进行编译。</h5></li>
<li><h5 id="通过java命令对生成的class文件进行运行"><a href="#通过java命令对生成的class文件进行运行" class="headerlink" title="通过java命令对生成的class文件进行运行"></a>通过java命令对生成的class文件进行运行</h5><h2 id="二、步骤一：编写"><a href="#二、步骤一：编写" class="headerlink" title="二、步骤一：编写"></a>二、步骤一：编写</h2></li>
</ol>
<ul>
<li>选择最简单的编辑器:记事本。敲入代码  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>将文件保存成Test.java,这个文件是存放java代码的文件，称为源文件。</li>
<li>注意拓展名是否隐藏<br><img src="http://qd1ql2976.bkt.clouddn.com/2202" alt=""><h2 id="三、步骤二：编译"><a href="#三、步骤二：编译" class="headerlink" title="三、步骤二：编译"></a>三、步骤二：编译</h2><img src="http://qd1ql2976.bkt.clouddn.com/2229" alt=""></li>
<li>有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件。</li>
<li>在该源文件目录下，通过javac编译工具对Test.java文件进行编译。</li>
<li>如果程序没有错误，没有任何提示，但在当前目录下会出现一个Test.class文件，该文件称为字节码文件，也是可以执行的java的程序。<h2 id="四、步骤三：运行"><a href="#四、步骤三：运行" class="headerlink" title="四、步骤三：运行"></a>四、步骤三：运行</h2></li>
<li>有了可执行的java程序(Test.class字节码文件)</li>
<li>通过运行工具java.exe对字节码文件进行执行。</li>
<li>出现提示:缺少一个名称为main的方法。<br><img src="http://qd1ql2976.bkt.clouddn.com/2231" alt=""></li>
<li>因为一个程序的执行需要-一个起始点或者入口，所以在Test类中的加入  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void</span><br><span class="line">main(String] args)&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>对修改后的Test.java源文件需要重新编译，生成新的class文件后，再进行执行。</li>
<li>发现没有编译失败，但也没有任何效果，因为并没有告诉JVM要帮我们做什么事情，也就是没有可以具体执行的语句。</li>
<li>想要和JVM来个互动，只要在main方法中加入一句  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.printn(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure></li>
<li>因为程序进行改动，所以再重新编译，运行即可。<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2></li>
<li>学习编程最容易犯的错是语法错误。</li>
<li>Java要求你必须按照语法规则编写代码。</li>
<li>如果你的程序违反了语法规则。例如:忘记了分号、大括号、引号，或者拼错了单词，java编译器都会报语法错误。</li>
<li>尝试着去看懂编译器会报告的错误信息。</li>
</ul>
<p><img src="http://qd1ql2976.bkt.clouddn.com/2233" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2235" alt=""></p>
<h2 id="六、代码示例"><a href="#六、代码示例" class="headerlink" title="六、代码示例"></a>六、代码示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">对第一个java程序进行总结</span><br><span class="line">1. java程序编写-编译-运行的过程</span><br><span class="line">编写：我们将编写的java代码保存在以&quot;.java&quot;结尾的源文件中</span><br><span class="line">编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java</span><br><span class="line">运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。</span><br><span class="line">而且要求声明为public的类的类名必须与源文件名相同。</span><br><span class="line"></span><br><span class="line">3. 程序的入口是main()方法。格式是固定的。</span><br><span class="line"></span><br><span class="line">4. 输出语句：</span><br><span class="line">System.out.println():先输出数据，然后换行</span><br><span class="line">System.out.print():只输出数据</span><br><span class="line"></span><br><span class="line">5.每一行执行语句都以&quot;;&quot;结束。</span><br><span class="line"></span><br><span class="line">6.编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">public class Hello &#123;</span><br><span class="line">	public static void main(String[] args) &#123;&#x2F;&#x2F;public static void main(String a[]) &#123;&#x2F;&#x2F;arguments:参数</span><br><span class="line">		System.out.print(&quot;Hello World!&quot;);</span><br><span class="line">		System.out.println();&#x2F;&#x2F;换行</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>06.Java基础知识-进制</title>
    <url>/2020/07/06/06-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<h2 id="世界上有10人种人，认识和不认识二进制的。"><a href="#世界上有10人种人，认识和不认识二进制的。" class="headerlink" title="世界上有10人种人，认识和不认识二进制的。"></a>世界上有10人种人，认识和不认识二进制的。</h2><h4 id="所有数字在计算机底层都以-二进制形式存在。"><a href="#所有数字在计算机底层都以-二进制形式存在。" class="headerlink" title="所有数字在计算机底层都以 二进制形式存在。"></a>所有数字在计算机底层都以 二进制形式存在。</h4><h4 id="对于整数，有四种表示方式："><a href="#对于整数，有四种表示方式：" class="headerlink" title="对于整数，有四种表示方式："></a>对于整数，有四种表示方式：</h4><ul>
<li>二进制(binary) ：0,1 ，满2进1.以0b或0B开头。</li>
<li>十进制(decimal) ：0-9 ，满10进1。</li>
<li>八进制(octal) ：0-7 ，满8进1. 以数字0开头表示。</li>
<li>十六进制(hex) ：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。</li>
<li>如：0x21AF +1= 0X21B0<br><img src="http://qd1ql2976.bkt.clouddn.com/2707" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2709" alt=""><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2></li>
<li>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位</li>
<li>二进制的整数有如下三种形式：<ul>
<li>原码：直接将一个数值换成二进制数。最高位是符号位</li>
<li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</li>
<li>负数的补码：其反码加1。</li>
</ul>
</li>
<li>计算机以二进制补码的形式保存所有的整数。<ul>
<li>正数的原码、反码、补码都相同</li>
<li>负数的补码是其反码+1<h2 id="为什么要使用原码、反码、补码表示形式呢？"><a href="#为什么要使用原码、反码、补码表示形式呢？" class="headerlink" title="为什么要使用原码、反码、补码表示形式呢？"></a>为什么要使用原码、反码、补码表示形式呢？</h2>计算机辨别“符号位”显然会让计算机的基础电路设计变得十分复杂! 于是<br>人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法,这样计算机运算的设计就更简单了。<br><img src="http://qd1ql2976.bkt.clouddn.com/2726" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2728" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2730" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2732" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2734" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2736" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2738" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2740" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2742" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2744" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2746" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2748" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2750" alt=""><h2 id="进制间转化"><a href="#进制间转化" class="headerlink" title="进制间转化"></a>进制间转化</h2><h4 id="进制的基本转换"><a href="#进制的基本转换" class="headerlink" title="进制的基本转换"></a>进制的基本转换</h4></li>
</ul>
</li>
<li>十进制 二进制互转<ul>
<li>二进制转成十进制  乘以2 的幂数</li>
<li>十进制转成二进制  除以2 取余数</li>
</ul>
</li>
<li>二进制 八进制互转</li>
<li>二进制 十六进制互转</li>
<li>十进制 八进制互转</li>
<li>十进制 十六进制互转<br><img src="http://qd1ql2976.bkt.clouddn.com/2776" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2778" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2780" alt=""><h2 id="进制间转化-1"><a href="#进制间转化-1" class="headerlink" title="进制间转化"></a>进制间转化</h2><h4 id="进制的基本转换-1"><a href="#进制的基本转换-1" class="headerlink" title="进制的基本转换"></a>进制的基本转换</h4></li>
<li>十进制 二进制互转<ul>
<li>二进制转成十进制  乘以2 的幂数</li>
<li>十进制转成二进制  除以2 取余数</li>
</ul>
</li>
<li>二进制 八进制互转</li>
<li>二进制 十六进制互转</li>
<li>十进制 八进制互转</li>
<li>十进制 十六进制互转<br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/5EC871BA9D5D42D7B5A1CBC281ED4B1E/2776" alt=""><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/3C33F55D34E1419DA549F06B9001E058/2778" alt=""><br><img src="https://note.youdao.com/yws/public/resource/96442cc0fb1bbf3377094a8fbad8ce78/xmlnote/E571E67C2E55469BBF3FB6451CB447FD/2780" alt=""><h2 id="求一个0-255范围内的整数的十六进制值"><a href="#求一个0-255范围内的整数的十六进制值" class="headerlink" title="求一个0~255范围内的整数的十六进制值"></a>求一个0~255范围内的整数的十六进制值</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 如何求一个0~255范围内的整数的十六进制值，例如60的十六进制表示形式3C</span><br><span class="line">		&#x2F;&#x2F; 0~255范围代表二进制控制在8位以内</span><br><span class="line">		int temp &#x3D; 60;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 方式一：自动实现</span><br><span class="line">		System.out.println(&quot;自动实现&quot;);</span><br><span class="line">		String str1 &#x3D; Integer.toBinaryString(temp);</span><br><span class="line">		System.out.println(temp+&quot;转换二进制:\t&quot; + str1);</span><br><span class="line">		</span><br><span class="line">		String str2 &#x3D; Integer.toHexString(temp);</span><br><span class="line">		System.out.println(temp+&quot;转换十六进制:\t&quot; + str2);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 方式二：自动实现</span><br><span class="line">		System.out.println(&quot;手动实现&quot;);</span><br><span class="line">		&#x2F;&#x2F; &amp;位运算符（与）：按底层二进制进行计算 相同为1，不同为0</span><br><span class="line">		&#x2F;&#x2F; 15二进制为1111 与 temp 进行&amp;运算可以求出 temp 二进制后四位的和</span><br><span class="line">		int k &#x3D; temp &amp; 15;</span><br><span class="line">		&#x2F;&#x2F; 判断是否超过9转换为（A-F）</span><br><span class="line">		char k1 &#x3D; (char)(k - 10 + 97);</span><br><span class="line">		&#x2F;&#x2F; 转换为String类型保存</span><br><span class="line">		String i &#x3D; k &gt; 9 ? k1 + &quot;&quot; : k + &quot;&quot; ;</span><br><span class="line">		&#x2F;&#x2F; &gt;&gt;位运算符（右移）：按底层二进制进行右移四位，剩余的正好是前四位</span><br><span class="line">		k &#x3D; temp &gt;&gt; 4;</span><br><span class="line">		&#x2F;&#x2F; 判断是否超过9转换为（A-F）</span><br><span class="line">		k1 &#x3D; (char)(k - 10 + 97);</span><br><span class="line">		&#x2F;&#x2F; 转换为String类型保存</span><br><span class="line">		String j &#x3D; k &gt; 9 ? k1 + &quot;&quot; : k + &quot;&quot; ;</span><br><span class="line">		</span><br><span class="line">		System.out.println(temp+&quot;转换十六进制:\t&quot; + j + i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>进制</tag>
        <tag>二进制</tag>
        <tag>十进制</tag>
        <tag>八进制</tag>
        <tag>十六进制</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub&amp;Git基础</title>
    <url>/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1-概述与目的"><a href="#1-概述与目的" class="headerlink" title="1.概述与目的"></a>1.概述与目的</h2><ol>
<li><h5 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h5>Git是一个免费、开源的版本控制软件</li>
<li><h5 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h5>版本控制是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。（记录文件的所有历史变化、随时可恢复到任何一个历史状态、多人协作开发或修改错误恢复）</li>
<li><h5 id="什么是Github"><a href="#什么是Github" class="headerlink" title="什么是Github"></a>什么是Github</h5>Github是全球最大的社交编程及代码托管网站（<a href="https://github.com/）。" target="_blank" rel="noopener">https://github.com/）。</a><br>Github可以托管各种git库，并提供一个web界面（用户名.github.io/仓库名）</li>
<li><h5 id="Github和Git是什么关系"><a href="#Github和Git是什么关系" class="headerlink" title="Github和Git是什么关系"></a>Github和Git是什么关系</h5>Git是版本控制软件<br>Github是项目代码托管的平台，借助Git来管理项目代码</li>
<li><h5 id="为什么学习github"><a href="#为什么学习github" class="headerlink" title="为什么学习github"></a>为什么学习github</h5>学习优秀的开源项目<br>关注行业前辈了解最新的行业动态<br>借助github托管项目代码</li>
<li><h5 id="简单介绍Git"><a href="#简单介绍Git" class="headerlink" title="简单介绍Git"></a>简单介绍Git</h5>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢?比如说自己在电脑上改了文件A,其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/1.png" class="">
借助Github托管项目代码。<h2 id="2-GitHub基本概念"><a href="#2-GitHub基本概念" class="headerlink" title="2.GitHub基本概念"></a>2.GitHub基本概念</h2></li>
<li><h5 id="仓库-Repository"><a href="#仓库-Repository" class="headerlink" title="仓库(Repository)"></a>仓库(Repository)</h5>仓库用来存放项目代码，每个项目对应一个仓库(Repository)，多个开源项目则有多个仓库（Repositories）。</li>
<li><h5 id="复制克隆项目（fork）"><a href="#复制克隆项目（fork）" class="headerlink" title="复制克隆项目（fork）"></a>复制克隆项目（fork）</h5>完全复制别人的项目到自己的GitHub,丝毫不会影响原有项目的代码与结构。fork的项目是独立存在的！</li>
<li><h5 id="发起请求-Pull-Request"><a href="#发起请求-Pull-Request" class="headerlink" title="发起请求(Pull Request)"></a>发起请求(Pull Request)</h5>发起请求，这个其实是基于Fork的。如果你fork了别人的项目并且在其基础上做了改进，后来觉得改进的很不错，应该要把这些改进让更多的人收益，于是就想把自己的改进合并到原有项目里，这个时候你就可以发起一个PullRequest(简称PR)，原有项目创建人就可以收到这个请求，这个时候你会仔细查看他的代码，并且测试觉得ok了，就会接受他的PR,这个时候他做的改进原有项目就会拥有了。</li>
<li><h5 id="事务卡片-Issue"><a href="#事务卡片-Issue" class="headerlink" title="事务卡片(Issue)"></a>事务卡片(Issue)</h5>发现代码BUG，但是目前没有成型代码，需要讨论时用。</li>
</ol>
<p>举个例子，就是你开源了一个项目，别人发现你的项目中有bug,或者哪些地方做的不够好，他就可以给你提个Issue,即问题，提的问题多了，也就是Issues，然后你.看到了这些问题就可以去逐个修复，修复ok了就可以一个个的Close掉。</p>
<h2 id="3-GitHub上创建仓库"><a href="#3-GitHub上创建仓库" class="headerlink" title="3.GitHub上创建仓库"></a>3.GitHub上创建仓库</h2><p>一个git库（仓库）对应一个开源项目</p>
<p>通过git管理git库</p>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/3.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/4.png" class="">
<h2 id="4-GitHub上管理仓库"><a href="#4-GitHub上管理仓库" class="headerlink" title="4.GitHub上管理仓库"></a>4.GitHub上管理仓库</h2><ol>
<li><h5 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h5><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/5.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/6.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/7.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/8.png" class=""></li>
<li><h5 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h5><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/9.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/10.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/11.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/12.png" class=""></li>
<li><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5>可在commits按钮查看删除信息<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/9.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/13.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/14.png" class="">
<h2 id="5-在本地使用Git"><a href="#5-在本地使用Git" class="headerlink" title="5.在本地使用Git"></a>5.在本地使用Git</h2><img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/15.png" class="">
工作流程：</li>
<li>从远程仓库中克隆 Git 资源作为本地仓库。</li>
<li>从本地仓库中checkout代码然后进行代码修改</li>
<li>在提交前先将代码提交到暂存区。</li>
<li>提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。</li>
<li>在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。</li>
</ol>
<p>下图展示了 Git 的工作流程：</p>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/2.png" class="">
<h5 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Programmingmakesmebald&quot; #名称</span><br><span class="line">git config --global user.email &quot;1731082812@qq.com&quot;   #邮箱</span><br></pre></td></tr></table></figure>
<h5 id="SSH设置"><a href="#SSH设置" class="headerlink" title="SSH设置"></a>SSH设置</h5><p>现在本地生成ssh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 1701082812@qq.com</span><br></pre></td></tr></table></figure>
<p> 一直回车</p>
<p>GitHub上配置：<br>①github②settings③SSH and …④New SSH⑤ title任意⑥key中输入 刚才在本地生成的ssh（<br>将本地刚才生成的id_rsa.pub内容复制到远程的Key中）</p>
<p>测试连通性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果本地和远程成功通信，则可以在 /.ssh目录中 发现known_hosts文件如果失败：多尝试几次、检查回车符</p>
<h5 id="本地仓库初始化代码"><a href="#本地仓库初始化代码" class="headerlink" title="本地仓库初始化代码"></a>本地仓库初始化代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h5 id="在远程建立git项目"><a href="#在远程建立git项目" class="headerlink" title="在远程建立git项目"></a>在远程建立git项目</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①new②建立项目③ 生成  https:&#x2F;&#x2F;github.com&#x2F;Programmingmakesmebald&#x2F;First-GitHub.git</span><br></pre></td></tr></table></figure>

<h5 id="本地项目-远程项目关联"><a href="#本地项目-远程项目关联" class="headerlink" title="本地项目-远程项目关联"></a>本地项目-远程项目关联</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:yanqun&#x2F;mygitremote.git</span><br></pre></td></tr></table></figure>

<h5 id="工作区域（上传文件到Github）"><a href="#工作区域（上传文件到Github）" class="headerlink" title="工作区域（上传文件到Github）"></a>工作区域（上传文件到Github）</h5><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看工作区状态：git status</span><br><span class="line">添加到暂存区  ：git add 文件名.后缀名</span><br><span class="line">提交到本地仓库：git commit -m “提交描述”</span><br><span class="line">上传到远程仓库：git push</span><br></pre></td></tr></table></figure>
<p>第一次发布项目（本地-远程）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .    &#x2F;&#x2F;文件-暂存区.&quot;代表当前目录所有文件</span><br><span class="line">git commit -m “提交描述” &#x2F;&#x2F;暂存区在本地分支（默认master）</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>第一次下载项目（远程-本地）</p>
<p>下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Programmingmakesmebald&#x2F;First-GitHub.git</span><br></pre></td></tr></table></figure>
<p>提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “提交到分支描述”</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>更新（远程-本地）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/16.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/17.png" class="">
<h2 id="6-问题"><a href="#6-问题" class="headerlink" title="6.问题"></a>6.问题</h2><ol>
<li><h5 id="上传时要输入账号密码（私有项目，没有权限）"><a href="#上传时要输入账号密码（私有项目，没有权限）" class="headerlink" title="上传时要输入账号密码（私有项目，没有权限）"></a>上传时要输入账号密码（私有项目，没有权限）</h5></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">①在 .git文件 里面找到config 打开</span><br></pre></td></tr></table></figure>
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/18.png" class="">
<img src="/2020/07/01/GitHub-Git%E5%9F%BA%E7%A1%80/19.png" class="">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">②将 [remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;仓库名.git</span><br><span class="line">改为</span><br><span class="line">[remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;用户名:密码@github.com&#x2F;用户名&#x2F;仓库名.git</span><br><span class="line">列</span><br><span class="line">[remote “origin”]</span><br><span class="line">url &#x3D; https:&#x2F;&#x2F;Rodma1:chenyun123@github.com&#x2F;Rodma1&#x2F;test.git</span><br><span class="line">保存就解决了</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="上传错误-（git-push）"><a href="#上传错误-（git-push）" class="headerlink" title="上传错误 （git push）"></a>上传错误 （git push）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：git pull --rebase origin master</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Git GitHub</category>
      </categories>
      <tags>
        <tag>Git GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客及使用</title>
    <url>/2020/07/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h3><h5 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;blogname&quot;</span><br></pre></td></tr></table></figure>
<h5 id="2-清除"><a href="#2-清除" class="headerlink" title="2. 清除"></a>2. 清除</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<h5 id="3-生成"><a href="#3-生成" class="headerlink" title="3. 生成"></a>3. 生成</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<h5 id="4-部署"><a href="#4-部署" class="headerlink" title="4. 部署"></a>4. 部署</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><h5 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1. 安装node.js"></a>1. 安装node.js</h5><h5 id="2-安装淘宝的cnpm-管理器"><a href="#2-安装淘宝的cnpm-管理器" class="headerlink" title="2. 安装淘宝的cnpm 管理器"></a>2. 安装淘宝的cnpm 管理器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h5 id="3-安装hexo框架"><a href="#3-安装hexo框架" class="headerlink" title="3. 安装hexo框架"></a>3. 安装hexo框架</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h5 id="4-生成博客-初始化博客"><a href="#4-生成博客-初始化博客" class="headerlink" title="4. 生成博客 初始化博客"></a>4. 生成博客 初始化博客</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h5 id="5-启动本地博客服务"><a href="#5-启动本地博客服务" class="headerlink" title="5. 启动本地博客服务"></a>5. 启动本地博客服务</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h5 id="6-本地访问地址"><a href="#6-本地访问地址" class="headerlink" title="6. 本地访问地址"></a>6. 本地访问地址</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h5 id="1-新建文章-1"><a href="#1-新建文章-1" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;文章名&quot; &#x2F;&#x2F;new</span><br></pre></td></tr></table></figure>
<h5 id="2-新建页面"><a href="#2-新建页面" class="headerlink" title="2. 新建页面"></a>2. 新建页面</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-本地运行-预览"><a href="#3-本地运行-预览" class="headerlink" title="3. 本地运行(预览)"></a>3. 本地运行(预览)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s &#x2F;&#x2F;sever</span><br></pre></td></tr></table></figure>
<h5 id="4-清除缓存"><a href="#4-清除缓存" class="headerlink" title="4. 清除缓存"></a>4. 清除缓存</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo c &#x2F;&#x2F;clean</span><br></pre></td></tr></table></figure>
<h5 id="5-生成"><a href="#5-生成" class="headerlink" title="5. 生成"></a>5. 生成</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g &#x2F;&#x2F;generate</span><br></pre></td></tr></table></figure>

<h5 id="6-部署到github"><a href="#6-部署到github" class="headerlink" title="6. 部署到github"></a>6. 部署到github</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d &#x2F;&#x2F;deploy</span><br></pre></td></tr></table></figure>

<h5 id="7-推送到分支"><a href="#7-推送到分支" class="headerlink" title="7. 推送到分支"></a>7. 推送到分支</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<h3 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h3><h5 id="1-配置-config-yml"><a href="#1-配置-config-yml" class="headerlink" title="1. 配置_config.yml"></a>1. 配置_config.yml</h5><p><img src="http://qd1ql2976.bkt.clouddn.com/1687" alt=""></p>
<h5 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2.更换主题"></a>2.更换主题</h5><p><img src="http://qd1ql2976.bkt.clouddn.com/1717" alt=""></p>
<h5 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h5><p>解决代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="http://qd1ql2976.bkt.clouddn.com/1700" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/1702" alt=""></p>
<h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><h5 id="hexo主题网站"><a href="#hexo主题网站" class="headerlink" title="hexo主题网站"></a><a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题网站</a></h5><h6 id="进入主题文件"><a href="#进入主题文件" class="headerlink" title="进入主题文件"></a>进入主题文件</h6><p><img src="http://qd1ql2976.bkt.clouddn.com/1713" alt=""></p>
<h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Fechin&#x2F;hexo-theme-diaspora.git</span><br></pre></td></tr></table></figure>
<p><img src="http://qd1ql2976.bkt.clouddn.com/1726" alt=""></p>
]]></content>
      <categories>
        <category>Hexo 博客</category>
      </categories>
      <tags>
        <tag>Hexo 博客</tag>
      </tags>
  </entry>
  <entry>
    <title>07.Java基础知识-运算符</title>
    <url>/2020/07/06/07-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</p>
<h2 id="一、算术运算符"><a href="#一、算术运算符" class="headerlink" title="一、算术运算符"></a>一、算术运算符</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2792" alt=""><br>算术运算符的注意问题</p>
<ul>
<li>如果对负数取模，可以把模数负号忽略不记，如：5%-2=1。 但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。</li>
<li>对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。 例如：int x=3510;x=x/1000*1000; x的结果是？</li>
<li>“+”除字符串相加功能外，还能把非字符串转换成字符串.例如：System.out.println(“5+5=”+5+5);//打印结果是？ 5+5=55 ?</li>
<li>示例  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之一：算术运算符</span><br><span class="line">+ - + - * &#x2F; % (前)++ (后)++ (前)-- (后)-- +</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">class AriTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;除号：&#x2F;</span><br><span class="line">		int num1 &#x3D; 12;</span><br><span class="line">		int num2 &#x3D; 5;</span><br><span class="line">		int result1 &#x3D; num1 &#x2F; num2;</span><br><span class="line">		System.out.println(result1);&#x2F;&#x2F;2</span><br><span class="line"></span><br><span class="line">		int result2 &#x3D; num1 &#x2F; num2 * num2;</span><br><span class="line">		System.out.println(result2);&#x2F;&#x2F;10</span><br><span class="line"></span><br><span class="line">		double result3 &#x3D; num1 &#x2F; num2;</span><br><span class="line">		System.out.println(result3);&#x2F;&#x2F;2.0</span><br><span class="line"></span><br><span class="line">		double result4 &#x3D; num1 &#x2F; num2 + 0.0;&#x2F;&#x2F;2.0</span><br><span class="line">		double result5 &#x3D; num1 &#x2F; (num2 + 0.0);&#x2F;&#x2F;2.4</span><br><span class="line">		double result6 &#x3D; (double)num1 &#x2F; num2;&#x2F;&#x2F;2.4</span><br><span class="line">		double result7 &#x3D; (double)(num1 &#x2F; num2);&#x2F;&#x2F;2.0</span><br><span class="line">		System.out.println(result5);</span><br><span class="line">		System.out.println(result6);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; %:取余运算</span><br><span class="line">		&#x2F;&#x2F;结果的符号与被模数的符号相同</span><br><span class="line">		&#x2F;&#x2F;开发中，经常使用%来判断能否被除尽的情况。</span><br><span class="line">		int m1 &#x3D; 12;</span><br><span class="line">		int n1 &#x3D; 5;</span><br><span class="line">		System.out.println(&quot;m1 % n1 &#x3D; &quot; + m1 % n1);</span><br><span class="line"></span><br><span class="line">		int m2 &#x3D; -12;</span><br><span class="line">		int n2 &#x3D; 5;</span><br><span class="line">		System.out.println(&quot;m2 % n2 &#x3D; &quot; + m2 % n2);</span><br><span class="line"></span><br><span class="line">		int m3 &#x3D; 12;</span><br><span class="line">		int n3 &#x3D; -5;</span><br><span class="line">		System.out.println(&quot;m3 % n3 &#x3D; &quot; + m3 % n3);</span><br><span class="line"></span><br><span class="line">		int m4 &#x3D; -12;</span><br><span class="line">		int n4 &#x3D; -5;</span><br><span class="line">		System.out.println(&quot;m4 % n4 &#x3D; &quot; + m4 % n4);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;(前)++ :先自增1，后运算</span><br><span class="line">		&#x2F;&#x2F;(后)++ :先运算，后自增1</span><br><span class="line">		int a1 &#x3D; 10;</span><br><span class="line">		int b1 &#x3D; ++a1;</span><br><span class="line">		System.out.println(&quot;a1 &#x3D; &quot; + a1 + &quot;,b1 &#x3D; &quot; + b1);</span><br><span class="line">		</span><br><span class="line">		int a2 &#x3D; 10;</span><br><span class="line">		int b2 &#x3D; a2++;</span><br><span class="line">		System.out.println(&quot;a2 &#x3D; &quot; + a2 + &quot;,b2 &#x3D; &quot; + b2);</span><br><span class="line">		</span><br><span class="line">		int a3 &#x3D; 10;</span><br><span class="line">		++a3;&#x2F;&#x2F;a3++;</span><br><span class="line">		int b3 &#x3D; a3;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;注意点：</span><br><span class="line">		short s1 &#x3D; 10;</span><br><span class="line">		&#x2F;&#x2F;s1 &#x3D; s1 + 1;&#x2F;&#x2F;编译失败</span><br><span class="line">		&#x2F;&#x2F;s1 &#x3D; (short)(s1 + 1);&#x2F;&#x2F;正确的</span><br><span class="line">		s1++;&#x2F;&#x2F;自增1不会改变本身变量的数据类型</span><br><span class="line">		System.out.println(s1);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;问题：</span><br><span class="line">		byte bb1 &#x3D;127;</span><br><span class="line">		bb1++;</span><br><span class="line">		System.out.println(&quot;bb1 &#x3D; &quot; + bb1);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;(前)-- :先自减1，后运算</span><br><span class="line">		&#x2F;&#x2F;(后)-- :先运算，后自减1</span><br><span class="line">		</span><br><span class="line">		int a4 &#x3D; 10;</span><br><span class="line">		int b4 &#x3D; a4--;&#x2F;&#x2F;int b4 &#x3D; --a4;</span><br><span class="line">		System.out.println(&quot;a4 &#x3D; &quot; + a4 + &quot;,b4 &#x3D; &quot; + b4);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二、赋值运算符"><a href="#二、赋值运算符" class="headerlink" title="二、赋值运算符"></a>二、赋值运算符</h2><ul>
<li>符号：=<ul>
<li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。</li>
<li>支持连续赋值。</li>
</ul>
</li>
<li>扩展赋值运算符： +=, -=, *=, /=, %=</li>
<li>示例  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之二：赋值运算符</span><br><span class="line">&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;  &#x2F;&#x3D;  %&#x3D; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">class SetValueTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;赋值符号：&#x3D;</span><br><span class="line">		int i1 &#x3D; 10;</span><br><span class="line">		int j1 &#x3D; 10;</span><br><span class="line"></span><br><span class="line">		int i2,j2;</span><br><span class="line">		&#x2F;&#x2F;连续赋值</span><br><span class="line">		i2 &#x3D; j2 &#x3D; 10;</span><br><span class="line"></span><br><span class="line">		int i3 &#x3D; 10,j3 &#x3D; 20;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;*********************</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		num1 +&#x3D; 2;&#x2F;&#x2F;num1 &#x3D; num1 + 2;</span><br><span class="line">		System.out.println(num1);&#x2F;&#x2F;12</span><br><span class="line"></span><br><span class="line">		int num2 &#x3D; 12;</span><br><span class="line">		num2 %&#x3D; 5;&#x2F;&#x2F;num2 &#x3D; num2 % 5;</span><br><span class="line">		System.out.println(num2);</span><br><span class="line"></span><br><span class="line">		short s1 &#x3D; 10;</span><br><span class="line">		&#x2F;&#x2F;s1 &#x3D; s1 + 2;&#x2F;&#x2F;编译失败</span><br><span class="line">		s1 +&#x3D; 2;&#x2F;&#x2F;结论：不会改变变量本身的数据类型</span><br><span class="line">		System.out.println(s1);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num &#x3D; 10;)</span><br><span class="line">		&#x2F;&#x2F;方式一：num &#x3D; num + 2;</span><br><span class="line">		&#x2F;&#x2F;方式二：num +&#x3D; 2; (推荐)</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num &#x3D; 10;)</span><br><span class="line">		&#x2F;&#x2F;方式一：num &#x3D; num + 1;</span><br><span class="line">		&#x2F;&#x2F;方式二：num +&#x3D; 1; </span><br><span class="line">		&#x2F;&#x2F;方式三：num++; (推荐)</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;练习1</span><br><span class="line">		int i &#x3D; 1;</span><br><span class="line">		i *&#x3D; 0.1;</span><br><span class="line">		System.out.println(i);&#x2F;&#x2F;0</span><br><span class="line">		i++;</span><br><span class="line">		System.out.println(i);&#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;练习2</span><br><span class="line">		int m &#x3D; 2;</span><br><span class="line">		int n &#x3D; 3;</span><br><span class="line">		n *&#x3D; m++; &#x2F;&#x2F;n &#x3D; n * m++;	</span><br><span class="line">		System.out.println(&quot;m&#x3D;&quot; + m);&#x2F;&#x2F;3</span><br><span class="line">		System.out.println(&quot;n&#x3D;&quot; + n);&#x2F;&#x2F;6</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;练习3</span><br><span class="line">		int n1 &#x3D; 10;</span><br><span class="line">		n1 +&#x3D; (n1++) + (++n1);&#x2F;&#x2F;n1 &#x3D; n1 + (n1++) + (++n1);</span><br><span class="line">		System.out.println(n1);&#x2F;&#x2F;32</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="三、比较运算符（关系运算符）"><a href="#三、比较运算符（关系运算符）" class="headerlink" title="三、比较运算符（关系运算符）"></a>三、比较运算符（关系运算符）</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2809" alt=""></p>
<ul>
<li><p>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</p>
</li>
<li><p>比较运算符“==” 不能误写成“=” 。</p>
</li>
<li><p>区分好==和=的区别。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean b1 &#x3D; false;</span><br><span class="line">if(b1&#x3D;&#x3D;true)</span><br><span class="line">System.out.println(&quot;结果为真&quot;);</span><br><span class="line">else</span><br><span class="line">System.out.println(&quot;结果为假&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之三：比较运算符</span><br><span class="line">&#x3D;&#x3D;  !&#x3D;  &gt;  &lt;  &gt;&#x3D; &lt;&#x3D;  instanceof</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">1.比较运算符的结果是boolean类型</span><br><span class="line">2.区分 &#x3D;&#x3D;  和  &#x3D; </span><br><span class="line">*&#x2F;</span><br><span class="line">class CompareTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 10;</span><br><span class="line">		int j &#x3D; 20;</span><br><span class="line"></span><br><span class="line">		System.out.println(i &#x3D;&#x3D; j);&#x2F;&#x2F;false</span><br><span class="line">		System.out.println(i &#x3D; j);&#x2F;&#x2F;20</span><br><span class="line"></span><br><span class="line">		boolean b1 &#x3D; true;</span><br><span class="line">		boolean b2 &#x3D; false;</span><br><span class="line">		System.out.println(b2 &#x3D;&#x3D; b1);&#x2F;&#x2F;false</span><br><span class="line">		System.out.println(b2 &#x3D; b1);&#x2F;&#x2F;true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="四、逻辑运算符"><a href="#四、逻辑运算符" class="headerlink" title="四、逻辑运算符"></a>四、逻辑运算符</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2811" alt=""></p>
<ul>
<li><p>逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。</p>
</li>
<li><p>“&amp;”和“&amp;&amp;”的区别：</p>
<ul>
<li>单&amp;时，左边无论真假，右边都进行运算；</li>
<li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</li>
</ul>
</li>
<li><p>“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</p>
</li>
<li><p>异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。</p>
<ul>
<li>理解：异或，追求的是“异”!</li>
</ul>
</li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之四：逻辑运算符</span><br><span class="line"></span><br><span class="line">&amp;  &amp;&amp; |  || ! ^</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">1.逻辑运算符操作的都是boolean类型的变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">class LogicTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;区分&amp; 与 &amp;&amp;</span><br><span class="line">		&#x2F;&#x2F;相同点1：&amp; 与  &amp;&amp; 的运算结果相同</span><br><span class="line">		&#x2F;&#x2F;相同点2：当符号左边是true时，二者都会执行符号右边的运算</span><br><span class="line">		&#x2F;&#x2F;不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</span><br><span class="line">		&#x2F;&#x2F;开发中，推荐使用&amp;&amp;</span><br><span class="line">		boolean b1 &#x3D; true;</span><br><span class="line">		b1 &#x3D; false;</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		if(b1 &amp; (num1++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;num1 &#x3D; &quot; + num1);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		boolean b2 &#x3D; true;</span><br><span class="line">		b2 &#x3D; false;</span><br><span class="line">		int num2 &#x3D; 10;</span><br><span class="line">		if(b2 &amp;&amp; (num2++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;num2 &#x3D; &quot; + num2);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 区分：| 与 || </span><br><span class="line">		&#x2F;&#x2F;相同点1：| 与  || 的运算结果相同</span><br><span class="line">		&#x2F;&#x2F;相同点2：当符号左边是false时，二者都会执行符号右边的运算</span><br><span class="line">		&#x2F;&#x2F;不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算</span><br><span class="line">		&#x2F;&#x2F;开发中，推荐使用||</span><br><span class="line">		boolean b3 &#x3D; false;</span><br><span class="line">		b3 &#x3D; true;</span><br><span class="line">		int num3 &#x3D; 10;</span><br><span class="line">		if(b3 | (num3++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;num3 &#x3D; &quot; + num3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		boolean b4 &#x3D; false;</span><br><span class="line">		b4 &#x3D; true;</span><br><span class="line">		int num4 &#x3D; 10;</span><br><span class="line">		if(b4 || (num4++ &gt; 0))&#123;</span><br><span class="line">			System.out.println(&quot;我现在在北京&quot;);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;我现在在南京&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;num4 &#x3D; &quot; + num4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="五、位运算符"><a href="#五、位运算符" class="headerlink" title="五、位运算符"></a>五、位运算符</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2813" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2817" alt=""></p>
<ul>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之五：位运算符 （了解）</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">1. 位运算符操作的都是整型的数据</span><br><span class="line">2. &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2</span><br><span class="line">   &gt;&gt; :在一定范围内，每向右移1位，相当于 &#x2F; 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">面试题：最高效方式的计算2 * 8 ？  2 &lt;&lt; 3  或 8 &lt;&lt; 1</span><br><span class="line">*&#x2F;</span><br><span class="line">class BitTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 21;</span><br><span class="line">		i &#x3D; -21;</span><br><span class="line">		System.out.println(&quot;i &lt;&lt; 2 :&quot; + (i &lt;&lt; 2));</span><br><span class="line">		System.out.println(&quot;i &lt;&lt; 3 :&quot; + (i &lt;&lt; 3));</span><br><span class="line">		System.out.println(&quot;i &lt;&lt; 27 :&quot; + (i &lt;&lt; 27));</span><br><span class="line"></span><br><span class="line">		int m &#x3D; 12;</span><br><span class="line">		int n &#x3D; 5;</span><br><span class="line">		System.out.println(&quot;m &amp; n :&quot; + (m &amp; n));</span><br><span class="line">		System.out.println(&quot;m | n :&quot; + (m | n));</span><br><span class="line">		System.out.println(&quot;m ^ n :&quot; + (m ^ n));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;练习：交换两个变量的值</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		int num2 &#x3D; 20;</span><br><span class="line">		System.out.println(&quot;num1 &#x3D; &quot; + num1 + &quot;,num2 &#x3D; &quot; + num2);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方式一：定义临时变量的方式</span><br><span class="line">		&#x2F;&#x2F;推荐的方式</span><br><span class="line">		int temp &#x3D; num1;</span><br><span class="line">		num1 &#x3D; num2;</span><br><span class="line">		num2 &#x3D; temp;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方式二：好处：不用定义临时变量  </span><br><span class="line">		&#x2F;&#x2F;弊端：① 相加操作可能超出存储范围 ② 有局限性：只能适用于数值类型</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 + num2;</span><br><span class="line">		&#x2F;&#x2F;num2 &#x3D; num1 - num2;</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 - num2;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;方式三：使用位运算符</span><br><span class="line">		&#x2F;&#x2F;有局限性：只能适用于数值类型</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 ^ num2;</span><br><span class="line">		&#x2F;&#x2F;num2 &#x3D; num1 ^ num2;</span><br><span class="line">		&#x2F;&#x2F;num1 &#x3D; num1 ^ num2;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;num1 &#x3D; &quot; + num1 + &quot;,num2 &#x3D; &quot; + num2);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图解<br><img src="http://qd1ql2976.bkt.clouddn.com/2815" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2848" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2850" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2852" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2854" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2856" alt=""></p>
</li>
</ul>
<h2 id="六、三元运算符"><a href="#六、三元运算符" class="headerlink" title="六、三元运算符"></a>六、三元运算符</h2><ul>
<li><p>格式:</p>
<ul>
<li>(条件表达式)? 表达式1 ：表达式2；<ul>
<li>条件表达式为true ，运算后的结果是表达式1；</li>
<li>条件表达式为false ，运算后的结果是表达式2；</li>
</ul>
</li>
<li>表达式1和表达式2为同种类型</li>
<li>三元运算符与if-else的联系与区别：<ol>
<li>三元运算符可简化if-else语句</li>
<li>三元运算符要求必须返回一个结果。</li>
<li>if后的代码块可有多个语句</li>
</ol>
</li>
</ul>
</li>
<li><p>示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">运算符之六：三元运算符</span><br><span class="line">1.结构：(条件表达式)? 表达式1 : 表达式2</span><br><span class="line">2. 说明</span><br><span class="line">① 条件表达式的结果为boolean类型</span><br><span class="line">② 根据条件表达式真或假，决定执行表达式1，还是表达式2.</span><br><span class="line">  如果表达式为true，则执行表达式1。</span><br><span class="line">  如果表达式为false，则执行表达式2。</span><br><span class="line">③ 表达式1 和表达式2要求是一致的。</span><br><span class="line">④ 三元运算符可以嵌套使用</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">凡是可以使用三元运算符的地方，都可以改写为if-else</span><br><span class="line">反之，不成立。</span><br><span class="line"></span><br><span class="line">4. 如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。</span><br><span class="line">*&#x2F;</span><br><span class="line">class SanYuanTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;获取两个整数的较大值</span><br><span class="line">		int m &#x3D; 12;</span><br><span class="line">		int n &#x3D; 5;</span><br><span class="line"></span><br><span class="line">		int max &#x3D; (m &gt; n)? m : n;</span><br><span class="line">		System.out.println(max);</span><br><span class="line"></span><br><span class="line">		double num &#x3D; (m &gt; n)? 2 : 1.0;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;(m &gt; n)? 2 : &quot;n大&quot;;&#x2F;&#x2F;编译错误</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;**************************</span><br><span class="line">		n &#x3D; 12;</span><br><span class="line">		String maxStr &#x3D; (m &gt; n)? &quot;m大&quot; : ((m &#x3D;&#x3D; n)? &quot;m和n相等&quot; : &quot;n大&quot;);</span><br><span class="line">		System.out.println(maxStr);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;*****************************</span><br><span class="line">		&#x2F;&#x2F;获取三个数的最大值</span><br><span class="line">		int n1 &#x3D; 12;</span><br><span class="line">		int n2 &#x3D; 30;</span><br><span class="line">		int n3 &#x3D; -43;</span><br><span class="line">		</span><br><span class="line">		int max1 &#x3D; (n1 &gt; n2)? n1 : n2;</span><br><span class="line">		int max2 &#x3D; (max1 &gt; n3)? max1 : n3;</span><br><span class="line">		System.out.println(&quot;三个数中的最大值为：&quot; + max2);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;不建议</span><br><span class="line">		&#x2F;&#x2F;int max3 &#x3D; (((n1 &gt; n2)? n1 : n2) &gt; n3)? ((n1 &gt; n2)? n1 : n2) : n3;</span><br><span class="line">		System.out.println(&quot;三个数中的最大值为：&quot; + max3);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;该写成if-else:</span><br><span class="line">		if(m &gt; n)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、运算符的优先级"><a href="#七、运算符的优先级" class="headerlink" title="七、运算符的优先级"></a>七、运算符的优先级</h2></li>
<li><p>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。</p>
</li>
<li><p>只有单目运算符、三元运算符、赋值运算符是从右向左运算的。<br><img src="http://qd1ql2976.bkt.clouddn.com/2872" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>运算符</tag>
        <tag>算数运算符</tag>
        <tag>赋值运算符</tag>
        <tag>比较运算符</tag>
        <tag>关系运算符</tag>
        <tag>逻辑运算符</tag>
        <tag>位运算符</tag>
        <tag>三目运算符</tag>
        <tag>三元运算符</tag>
        <tag>运算符的优先级</tag>
      </tags>
  </entry>
  <entry>
    <title>05.Java基础知识-变量与数据类型</title>
    <url>/2020/07/05/05-Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h2><ul>
<li><p><strong>变量的概念</strong>：</p>
<ul>
<li>内存中的一个存储区域</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元。包含变量类型、变变量名和存储的值</li>
</ul>
</li>
<li><p><strong>变量的作用</strong>：</p>
<ul>
<li>用于在内存中保存数据</li>
</ul>
</li>
<li><p><strong>使用变量注意</strong>：</p>
<ul>
<li>Java中每个变量必须先声明，后使用</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量的作用域：其定义所在的一对{ }内</li>
<li>变量只有在其作用域内才有效</li>
<li>同一个作用域内，不能定义重名的变量</li>
</ul>
</li>
<li><p><strong>声明变量</strong></p>
<ul>
<li>语法：&lt;数据类型&gt; &lt;变量名称&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int var;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>变量的赋值</strong></p>
<ul>
<li>语法：&lt;变量名称&gt; = &lt;值&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var &#x3D; 10;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>声明和赋值变量</strong></p>
<ul>
<li>语法： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt;</li>
<li>例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int var &#x3D; 10;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>变量的分类-按数据类型</strong></p>
<ul>
<li>对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间。<br><img src="http://qd1ql2976.bkt.clouddn.com/2483" alt=""></li>
</ul>
</li>
<li><p><strong>变量的分类-按声明的位置的不同</strong></p>
<ul>
<li>在方法体外，类体内声明的变量称为成员变量。</li>
<li>在方法体内部声明的变量称为局部变量<br><img src="http://qd1ql2976.bkt.clouddn.com/2486" alt=""></li>
<li>注意：二者在初始化值方面的异同:<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，需显式初始化。<h2 id="二、整数类型"><a href="#二、整数类型" class="headerlink" title="二、整数类型"></a>二、整数类型</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。</p>
</li>
<li><p>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</p>
</li>
<li><p>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long<br><img src="http://qd1ql2976.bkt.clouddn.com/2510" alt=""></p>
</li>
<li><p>500MB 1MB = 1024KB 1KB= 1024B B= byte ? bit?<br>bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。</p>
<h2 id="三、浮点类型"><a href="#三、浮点类型" class="headerlink" title="三、浮点类型"></a>三、浮点类型</h2></li>
<li><p>与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。</p>
</li>
<li><p>浮点型常量有两种表示形式：</p>
<ul>
<li>十进制数形式：如：5.12、512.0f、.512 (必须有小数点）</li>
<li>科学计数法形式:如：5.12e2、512E2、100E-2</li>
</ul>
</li>
<li><p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。</p>
</li>
<li><p>double:双精度，精度是float的两倍。通常采用此类型。</p>
</li>
<li><p>Java 的浮点型常量默认为double型，声明float 型常量，须后加‘f’ 或‘F’ 。<br><img src="http://qd1ql2976.bkt.clouddn.com/2512" alt=""></p>
<h2 id="四、字符类型"><a href="#四、字符类型" class="headerlink" title="四、字符类型"></a>四、字符类型</h2></li>
<li><p>char 型数据用来表示通常意义上“字符”(2字节)</p>
</li>
<li><p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</p>
</li>
<li><p>字符型变量的三种表现形式：</p>
<ul>
<li>字符常量是用单引号(‘ ‘)括起来的单个字符。例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c1 &#x3D; &#39;a&#39;;</span><br><span class="line">char c2&#x3D; &#39;中&#39;;</span><br><span class="line">char c3 &#x3D; &#39;9&#39;;</span><br></pre></td></tr></table></figure></li>
<li>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例如：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c3 &#x3D; ‘\n’; &#x2F;&#x2F; &#39;\n&#39;表示换行符</span><br></pre></td></tr></table></figure>
  <img src="http://qd1ql2976.bkt.clouddn.com/2514" alt=""></li>
<li>直接使用 Unicode值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个十六进制整数。如：\u000a 表示 \n。</li>
</ul>
</li>
<li><p>char类型是可以进行运算的。因为它都对应有Unicode码。</p>
<h2 id="五、布尔类型"><a href="#五、布尔类型" class="headerlink" title="五、布尔类型"></a>五、布尔类型</h2></li>
<li><p>boolean 类型用来判断逻辑条件，一般用于程序流程控制：</p>
<ul>
<li>if条件控制语句；</li>
<li>while循环控制语句；</li>
<li>do-while循环控制语句；</li>
<li>for循环控制语句；</li>
</ul>
</li>
<li><p>boolean类型数据只允许取值true和false，无null。</p>
<ul>
<li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</li>
<li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。———《java虚拟机规范 8版》<h2 id="六、String字符串类型"><a href="#六、String字符串类型" class="headerlink" title="六、String字符串类型"></a>六、String字符串类型</h2></li>
</ul>
</li>
<li><p>String不是基本数据类型，属于引用数据类型</p>
</li>
<li><p>使用方式与基本数据类型一致。例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; “abcd”;</span><br></pre></td></tr></table></figure></li>
<li><p>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str &#x3D; str + “xyz” ;</span><br><span class="line">int n &#x3D; 100;</span><br><span class="line">str &#x3D; str + n;</span><br></pre></td></tr></table></figure>
<h2 id="七、类型转换"><a href="#七、类型转换" class="headerlink" title="七、类型转换"></a>七、类型转换</h2></li>
<li><p>基本数据类型转换</p>
<ul>
<li>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：<img src="http://qd1ql2976.bkt.clouddn.com/2584" alt=""></li>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。</li>
<li>byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</li>
<li>boolean类型不能与其它数据类型运算。</li>
<li>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。</li>
</ul>
</li>
<li><p>强制类型转换</p>
<ul>
<li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</li>
<li>如：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double a &#x3D; 1.23;</span><br><span class="line">int i &#x3D; (int)a;</span><br></pre></td></tr></table></figure></li>
<li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。</li>
<li>如：   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a &#x3D; “43”;</span><br><span class="line">int i &#x3D; Integer.parseInt(a);</span><br></pre></td></tr></table></figure></li>
<li>boolean类型不可以转换为其它的数据类型。</li>
</ul>
</li>
</ul>
<h2 id="八、了解"><a href="#八、了解" class="headerlink" title="八、了解"></a>八、了解</h2><p><img src="http://qd1ql2976.bkt.clouddn.com/2551" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2553" alt=""><br><img src="http://qd1ql2976.bkt.clouddn.com/2555" alt=""></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>变量</tag>
        <tag>整数类型</tag>
        <tag>浮点类型</tag>
        <tag>字符类型</tag>
        <tag>布尔类型</tag>
        <tag>String字符串类型</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM文件上传</title>
    <url>/2020/07/01/SSM%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="SSM–文件上传"><a href="#SSM–文件上传" class="headerlink" title="SSM–文件上传"></a>SSM–文件上传</h1><h3 id="1-配置（applicationContext-Controller-xml）"><a href="#1-配置（applicationContext-Controller-xml）" class="headerlink" title="1.配置（applicationContext-Controller.xml）"></a>1.配置（applicationContext-Controller.xml）</h3><p>在SpringMVC中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传的配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 上传单个文件的最大值，单位Byte，-1表示无限制 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"104857600"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-编写控制器（Controller）"><a href="#2-编写控制器（Controller）" class="headerlink" title="2.编写控制器（Controller）"></a>2.编写控制器（Controller）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testUpload"</span>)</span><br><span class="line">    <span class="function">String <span class="title">testUpload</span><span class="params">(@RequestParam(<span class="string">"miaoshu"</span>)</span> String desc,@<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"文件描述信息:%s"</span>,desc));</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        InputStream input = file.getInputStream();</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        OutputStream out=<span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1atupian\\"</span>+fileName);</span><br><span class="line">        <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = input.read(bs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.print(String.format(<span class="string">"上传成功!"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-前台上传框（jsp）"><a href="#3-前台上传框（jsp）" class="headerlink" title="3.前台上传框（jsp）"></a>3.前台上传框（jsp）</h3><p>form表单中需要注意的是上传的方式必须为Post  method=”post”</p>
<p>必须加上enctype=”multipart/form-data”属性   enctype=”multipart/form-data”</p>
<p>get的方式地址栏改变将显示文件的内容，若文件过大时地址栏的大小不能够放下该文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文件上传：</span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"controller/testUpload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">                请选择文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line">                文件的描述：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"miaoshu"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>SSM文件上传</tag>
      </tags>
  </entry>
</search>
